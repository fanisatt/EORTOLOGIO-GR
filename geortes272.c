// cd /home/fanisatt/CMAKE2/
// gcc -c geortes265.c -lSDL_bgi -lSDL2
// gcc -c input85.c -lSDL_bgi -lSDL2
// gcc -o GReortes3.3 geortes265.o input85.o -lSDL_bgi -lSDL2 -lm -no-pie
// ...and the finest of all :
// gcc -o GReortes3.3 geortes265.o input85.o -L/home/fanisatt/CMAKE2 -lSDL_bgi -Wl,-rpath='${ORIGIN}/lib' -lSDL2 -lm -no-pie


#include<graphics.h>
#include<SDL2/SDL.h>
#include<stdio.h>
#include<time.h>
#include<ctype.h>
#include<string.h>
#include<stdlib.h>
#include<unistd.h>
#include <memory.h>
#include <pwd.h>
#include <errno.h>
#include<sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <limits.h>

#define pause while (!(event())) refresh()
//#define GR 1
//#define EN 0
#define ttf 48 // Συνολικός αριθμός fonts

// Set cursor position
void gotoxy(int x, int y);
 
// Clear terminal screen and set cursor to top left
void clrscr();
// ***************************************************
int inp_fonts_show(char *header, void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon, int *proxchxr, int *proxbkxr , int *proxslxr );
int proodos(char *str, int cur, int hm , int fun);
unsigned short int field_txt_scrollsearch (short int *area, short int *goup , short int *godown, short int *kleise,unsigned char *mainstr, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *cochxr , int *cobkxr, int *coslxr) ;
unsigned char *convert_and_strstr  (unsigned char *mainstr, unsigned char *deigma_txt, unsigned short int *how_many, unsigned short int *cur);
short int find_note (unsigned char *nelement, unsigned short int uyear , short int *mo);
void hide_help_inp(unsigned short int xt1, unsigned short int yt1);
void show_help_inp(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1);
void change_col (int x1,int y1,void *mem1 , int *apocol , int* proscol);
void ROputicon (int x1,int y1,void *mem1 , int *bkxr);
short int check_diary_notes (unsigned short int uyear , short int *mo, short int *yeno);
int diary_input(unsigned char *str, int *pxl,int *pyt,int *pxr,int *pyb,int orio,short int arped, unsigned short int wherp1, char  *diary_filename);
int pers_rec_show(short int *sorton , unsigned short int uday, unsigned short int umonth, unsigned short int uyear );
int pers_rec_inp (short int new, short int old , unsigned short int uday, unsigned short int umonth, unsigned short int uyear);
void year_recur_year_st ( int a , unsigned short int uyear , unsigned char yonly[][32]);
void month_recur_year_st ( int a , unsigned short int uyear , unsigned short int umonth , short int *mo);
void recur_year_st ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate ,short int *mo);
void year_recur_year_w ( int a , unsigned short int uyear , unsigned char yonly[][32]);
void month_recur_year_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo);
void recur_year_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo);
void year_recur_month_bima ( int a , unsigned short int uyear , unsigned char yonly[][32]);
void month_recur_month_bima ( int a , unsigned short int uyear , unsigned short int umonth , short int *mo);
void recur_month_bima ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , short int *mo);
void recur_month_st ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo) ;
void month_recur_month_st ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo);
void year_recur_month_st ( int a , unsigned short int uyear , unsigned char yonly[][32]);
void year_recur_month_w ( int a , unsigned short int uyear , unsigned char yonly[][32]) ;
void month_recur_month_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo);
void recur_month_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo);
void month_recur_week ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo);
void year_recur_week ( int a , unsigned short int uyear , unsigned char yonly[][32]);
void recur_week ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo);
void month_recur_days ( int a , unsigned short int uyear , unsigned short int umonth , short int *mo) ;
void year_recur_days ( int a , unsigned short int uyear,  unsigned char yonly[][32]);
void recur_days ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , short int *mo);
int mini_calendar(unsigned short int *panel_year, unsigned short int *panel_month, unsigned short int *panel_day,unsigned short int *panel_nameday);
short int _mini_show_month (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth,unsigned short int uday, unsigned short int stamonth);
void Rputicon (int x1,int y1,void *mem1 , int *bkxr);
void RNputicon (int x1,int y1,void *mem1 , int *bkxr);
void _Rputicon (int x1,int y1,void *mem1 , int *bkxr);
void _RNputicon (int x1,int y1,void *mem1 , int *bkxr);
void My_readimagefile(char *filename, int x, int y);
int _realputicon (int x1,int y1,void *mem1) ;
void *pro_pedabafont(int pfont , char *fo_file) ;
void sec_moonrise_moonset(unsigned short int year , unsigned short int month , unsigned short int date, short int search);
void moonrise_moonset(unsigned short int year , unsigned short int month , unsigned short int date, short int *mo);
int moonPhases(int year, int month, int day);
void moonPhaseText(int moonNum);
double julianDat(int year, int month, int day);
double proper_ang(double big);
void sunrise_sunset (unsigned short int year , unsigned short int month , unsigned short int date );
void fill_char(char *str,int len,char *ch);
int real_strlen(char *normstr) ;
int fastmenu_show_opt (short int plbut, short int *op, char menu[][120], char *but_name, unsigned short int moux, unsigned short int mouy ) ;
void _outmystr_col_transp(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr,short int transp);
void _transp_fill (int x, int y, int w , int h, int tred , int tgreen , int tblue , int transp);
short int _show_month_greg (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth,unsigned short int stamonth);
int Open_Report_Link(char* filename);
int fileselector( char *popor, char *old , int max);
int Start_strstr(char *big, char *sma);
FILE * read_pipe( char *popor );
int butpers_show(short int *sorton , unsigned short int uday, unsigned short int umonth, unsigned short int uyear );
int pers_inp (short int new, short int old , unsigned short int no, unsigned short int uday, unsigned short int umonth, unsigned short int uyear);
int mobeortes_show(short int *sorton,short int delon );
//int _nice_box_clear (int fnt, int charnumb, int inpx, int inpy, int inpx1, int inpy1, int dist, int *olobkxr, int *bkxrepi);
//void _nice_box (int fnt, char *str,int inpx, int inpy, int inpx1, int inpy1, int dist, int *olobkxr, int * chxrepi, int *bkxrepi);
int pagkosm_show(char *but_name, short int *sorton,short int delon );
int sbutton_show(void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon ) ;
int pieseortes_show(int plbut, char *but_name, short int *sorton,short int delon );
int name_show(int plbut, char *but_name, short int *sorton,short int delon );
int mystrstr (unsigned char *str, unsigned char *deigma) ;
void atona (unsigned char *str) ;
int eortes_show(char *but_name, short int *sorton,short int delon );
void pro_sort_shoint (short int *item,unsigned short int *point,int count);
void qui_sort_shoint (short int *item , unsigned short int *point , int left , int right);
int fastmenu_show(short int plbut, char menu[][120], char *but_name, unsigned short int moux, unsigned short int mouy );
int txt_scrollsearch (unsigned char *str, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *Rclik, int *cochxr , int *cobkxr , int *cobkxr2);
void _txt_show (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr, int *colbkxr2);
void pedaba_calendar(short int arped);
short int _show_month (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth,unsigned short int uday,unsigned short int stamonth);
short int find_dayname (unsigned short int uyear,unsigned short int umonth,unsigned short int uday) ;
//int menu_dbfiles(char *loaddbfile);
//int recent_files_inform (char *ndbpath , char *ndbname) ;
int mystrcpy_lim (unsigned char *str1 , unsigned char * str2 , int orio);
int choise_alert (char *str1,char *str2, short int akyro);
//void * muldbfield_show_button(void *mem_str, unsigned char *pedia, unsigned int ar, unsigned short int orio, unsigned char *but_name, short int *sorton , short int sort_type , short int delon , unsigned short int *disk_dom, unsigned short int *flag_mulsel);
void * mulbutton_show(void *mem_str, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon );
int qnum_input(char *str, int xl,int yt,int xr,int yb,int orio,int num_type);
int qtext_input(char *str, int xl,int yt,int xr,int yb,int orio);
//int criterio_show (int *cochxr , int *cobkxr);
int mystr_show(short int font, unsigned char *mystr, char *headername, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr );
void _outfanis_colxr(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr, int *cchxr, int *cbkxr);
int filehelp_show(short int font, char *filename, char *helpname, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr ) ;
unsigned short int hlp_txt_scroll (short int font, unsigned short int cur, unsigned char *str, unsigned short int ar, short int xl , short int yt , short int xr , short int yb , int *cochxr , int *cobkxr);
//void *prosans_21();
//int spec_alert (int id,char *seleo,char *seleo1, char *img_file , int *spbkxr);
//int photofield_show_button(void *mem_str, unsigned int ar, short int arped, short int arped2, short int *sorton , unsigned short int *disk_dom);
//int info_dbsec(short int arped , unsigned short int *ar_dom);
//void *proimpact_20();
int smmenu_show(short int plbut, char menu[][120], char *but_name, unsigned short int moux, unsigned short int mouy );
int bmptodisk_new (char *bmpname, unsigned int size_bytes,int width, int height);
//void *procaviar_22();
void *convertinp_strstr  (short int left_right, char  *str, short int arped, unsigned short int *how_many, unsigned short int *cur);
//void *prosans_18();
int fonts_show(int isxfont, char *header, void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon, int *proxchxr, int *proxbkxr , int *proxslxr );
int info_dbfnt();
//void *protimes_18();
void hide_help(unsigned short int xt1, unsigned short int yt1);
void show_help(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1);
//void *proarial_12();
//int input_compl_search ();
//unsigned short int field_txt_scrollsearch (short int arped, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *cochxr , int *cobkxr, int *coslxr);
//unsigned char * convert_and_strstr  (short int arped, unsigned short int *how_many, unsigned short int *cur);
void what_mytime (time_t mytime, char *str);
int mystrcmp (unsigned char *str1 , unsigned char *str2);
int input_dbsearch_text(unsigned char *inp_str , short int arped );
int input_dbsearch_date(unsigned char *iso_str , unsigned char *meg_str, unsigned char *mik_str , short int arped );
int input_dbsearch_num(unsigned char *iso_str , unsigned char *meg_str, unsigned char *mik_str, short int type, short int arped );
int input_cardnum(unsigned char *inp_str);
//int dbfield_show_button(void *mem_str, unsigned char *data, unsigned int ar, unsigned short int orio, unsigned char *but_name, short int *sorton , short int sort_type , short int delon , unsigned short int *disk_dom );
//int info_dbfdata(short int arped , unsigned short int *ar_dom);
void pro_sort_usint (unsigned short int *item,int count);
void qui_sort_usint (unsigned short int *item , int left , int right);
void pro_sort_uint (unsigned int *item,unsigned short int *point,int count);
void qui_sort_uint (unsigned int *item , unsigned short int *point , int left , int right);
void pro_sort_double (double *item,unsigned short int *point,int count);
void qui_sort_double (double *item , unsigned short int *point , int left , int right);
void pro_sort_signedlong (long int *item,unsigned short int *point,int count);
void qui_sort_signedlong (long int *item , unsigned short int *point , int left , int right);
//int info_dbfds() ;
//int change_mikrodbpos(short int proel, int dx, int dy, int *xl, int *yt ,int *xr , int *yb);
int mypolystr (unsigned char *mega , unsigned char *mikro);
void _field_txt_show (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr);
int _outmystr_center_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr);
void _outmystr_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr, int *bbk);
int mystrcpy (unsigned char *str1 , unsigned char * str2);
void * named_button_load(unsigned short int *ptr_orio, unsigned short int *ptr_ar, char *full_name);
int mytext_toclipboard (char *data);
void qui_sort_24b(void *vitem , unsigned short int *point , int left , int right);
void pro_sort_24b(void *vitem, unsigned short int *point,int count);
int button_show(void *mem, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon );
void pro_sort_ulong (unsigned long int *item,unsigned short int *point,int count);
void qui_sort_ulong (unsigned long int *item , unsigned short int *point , int left , int right);
//void * button_load(unsigned short int *ptr_orio, unsigned short int *ptr_ar, char *but_name);
void _outfanis_colsel(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr);
void _outfanis_center_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr);
void _outfanis_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr);
int normtext_tomy(char *normstr , char *mystr);
void what_time (char *str);
int mytext_tonorm(unsigned char *mystr , char *normstr, int orio);
int input_alert (int id,char *seleo, char *inp_str, short int orio);
unsigned short int field_txt_scroll (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int xb , unsigned short int orio , int *cochxr , int *cobkxr , short int *area );
int _puticon (int x1,int y1,void *mem1,int transp);
int _outnoto_col(int x, int y, char *str, int lang, int *chxr, int *bkxr);
int _outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr);
void _bareacls (int x,int y,int r,int d,int *cbkxr);
void _areacls (int x,int y,int r,int d,int kok,int pra,int mpl);
int _outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
int _putNOTicon (int x1,int y1,void *mem1);
int _outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
int text_input(char *str, int xl,int yt,int xr,int yb,int orio);
void pro_sort_int (int *item,unsigned short int *point,int count);
void qui_sort_int (int *item , unsigned short int *point , int left , int right);
int putNOTicon (int x1,int y1,void *mem1);
int outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
double convert_str(short int len , char *str);
int num_input(char *str, int xl,int yt,int xr,int yb,int orio,int num_type);
int outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
//int inkualizer (int *chrxr , int *bkgxr , int *selxr);
void bareacls (int x,int y,int r,int d,int *cbkxr);
void information (int id,char *seleo,char *seleo1);
void *sfalmata();
int alert (int id,char *seleo,char *seleo1);
int outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr);
int outnoto_col(int x, int y, char *str, int lang,int *chxr,int *bkxr);
int puticon (int x1,int y1,void *mem1,int transp);
int change_pos(int *xl, int *yt ,int *xr , int *yb);
int change_dim(int xl, int yt ,int *mxright , int *mybottom);

void fontoicW (int x , int y, int red, int green, int blue, void *mem1);
int puticW(int x, int y, void *mem_w);
void *icWtomem (char *filename);
int Wbmptodisk (char *bmpname, unsigned int size_bytes,short int width, short int height);
int outnoto_sma(int x, int y, char *str, int lang);
int outnoto_big(int x, int y, char *str, int lang, int syntx , int synty);
int outnoto(int x, int y, char *str, int lang);
//void *pronoto();
void *icontomem (char *filename,int transp);
int bmptodisk (char *bmpname, unsigned int size_bytes,int width, int height);
int input(unsigned char *str, int *pxl,int *pyt,int *pxr,int *pyb,int orio,short int arped , unsigned short int wherp1);
void proinput ();
void fidicls(int x, int y, int x1, int y1 , int red , int green, int blue);
void cls();
int outsouv(int x, int y, char *str, int lang);
//void * prosouv();
void areacls (int x,int y,int r,int d,int kok,int pra,int mpl);
void qcls (int kok,int pra,int mpl);
void efecls (int x,int y,int w,int h,int kok,int pra,int mpl);
int txt_scroll_min (unsigned char *str, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *Rclik, int *cochxr , int *cobkxr , int *cobkxr2) ;
long int inp_numb();
int my_esc=0;
int my_err=0;
char eid[44]={' ' , '!' , '\"' , '#' ,'$' ,'%' ,'&' ,'\'' ,'(' ,')' ,'*' ,'+' ,',' ,'-' ,'.' ,'/' ,'0' ,'1' ,'2' ,'3' ,'4' ,'5' ,'6' ,'7' ,'8' ,'9' ,':' ,';' ,'<' ,'=' ,'>', '?', '@', '[', '\\', ']' ,'^' ,'_' ,'`' ,'{' ,'|' ,'}' ,'~'};

unsigned char etm[22][3] =
{53 , '`' , '~' , 30 , '1' , '!' , 31 , '2', '@' , 32 , '3' , '#' , 33 , '4' , '$' , 34 , '5', '%' , 35 , '6' , '^' , 36 , '7' , '&' , 37 , '8' , '*' , 38 , '9' , '(' ,
39 , '0' , ')' , 45 , '-' , '_' , 46 , '=' , '+' , 47 , '[' , '{' , 48 , ']' , '}' , 49 , '\\' , '|' , 51 , ';' , ':' , 52 , '\'' , '\"' , 54 , ',' , '<', 55 , '.' , '>' ,
56 , '/' , '?' , 44, ' ' , ' '};

unsigned short int unico[69][2];

struct viewporttype info , info_2 , info_3 , info_4 , info_5 ;
struct viewporttype *info_p , *info_p2 , *info_p3 , *info_p4 , *info_p5;
void *mem_small=0 ;

/*
void *greek_addr=NULL, *souv_addr=NULL , *mem_sarial=0;
void *mem_small=0 , *mem_times = 0 , *mem_sans = 0 , *mem_caviar =0 , *mem_impact = 0 , *mem_sanser21=0 ; 
void *mem_NOTOSANS18N=0;
*/

// fonts

void *mem_Font[ttf];

struct fansouv {
    char who;
    short int wid;
    short int hei;
    void *where;
} myfont[ttf][165] ; // Σύνολο χαρακτήρων +1//


/*
struct fansouv nouv[165] , sarial[165] , times18[165] , sanser18[165] , caviar22[165] , impact20[165], sanser21[165] , NOTSNS_18N[165] , NOTSNS_18B[165] , NOTSNS_20N[165] , NOTSNS_20B[165] , NOTSNS_10B[165] , NOTSRF_20N[165] , NOTSRF_20B[165] ;
struct fansouv THEOKR_22[165];
*/


struct fansouv *souv , *nouv , *gouv, *sarial ;
short int myfont_hei[ttf];
short int myfont_wid[ttf];
char myfont_name [ttf][30]; 

struct fachars {
unsigned int scacod [57];
unsigned char faprint [57][2];
unsigned int sort [57][2];
} engl , grek ;

char user_name[82];
char file_1[1024];
char file_2[1024];
char str1kb[1386];
unsigned char file_3[512];
char path_name[1024];
char user_path[512];
short int keyb_gr =0 ;
short int keyb_us =0 ;

SDL_Event sdlev;
int win_id , win_id_2 , winid4 , winid5 , winwho ;
unsigned int sdlwin1 , sdlwin2 ;
int chxr[3];
int bkxr[3];
int slxr[3];

char *sfalma=NULL;
int topbkxr[3];
int topchxr[3];
int topslxr[3];
int dbbkxr[3];
int dbchxr[3];
int dbslxr[3];
int bkxr1[3];
int chxr1[3];
int slxr1[3];
int eisag[3];
int delerg[3];
int klperg[3];
int sxedom[3];
int parous[3];
int klperg[3];
int syncardchxr[3];
int syncardbkxr[3];
unsigned short int mmed[24];


struct db_bu {
    unsigned short int butt_orio;
    unsigned short int butt_ar;
    unsigned char butt_name[50];
    void *mem_butt;
    unsigned char butt_data[128];
    int butt_elem;
    unsigned short int butt_sorton;
} dbbut [10];

struct ope_bu {
     unsigned short int butt_orio;
    unsigned short int butt_ar;
    unsigned char butt_name[40];
    void *mem_butt;
    unsigned char butt_data[40];
    int butt_elem;
    unsigned short int butt_sorton;
} open_buts ;

// struct Data Base Fields (dbfds)
struct {
     unsigned short int fd_orio;
    unsigned short int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    unsigned short int fd_sorton;
} dbfds ;

// struct Data Base Field Data (dbfdata)
struct {
    unsigned short int fd_orio;
    unsigned int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    unsigned short int fd_sorton;
    short int fd_sort_type ;
    unsigned short int fd_arped;
} dbfdata;


short int dbmaxbut ;           // Πόσα συνολικά buttons είναι φορτωμένα ! (μέχρι 10 / 0-9 / αρχική τιμή -1)
short int delon ; //Καλαθάκι αχρήστων για τη button show !

//struct fanfield *ptr_pedio[100];         // Μέγιστος αριθμός πεδίων
//struct fanlabel *ptr_etiket[50];        // Μέγιστος αριθμός ετικετών

//char savedbpath[768] , LDdbfile[1024] ;
//char *loaddbfile;
char str1024 [2048];        // Γενικής Χρήσης str
int pdaba[4] , pdaca;
unsigned short int dblasize, dbfisize , dbplgr=0 , dbplera, dbpg=1 , dbcurpage=1 , dbar =0 , dbrecxr , dbscrxr ,dbmag , dbtop , dbselxr , dbred , dbgreen , dbblack , dbyel , dbhelpcol;
short int dbfinum , dblanum ;
unsigned char dbtime[100];
time_t loctime , metatime , protime ;
char *ptr_char=NULL;
struct tm *diary;
//FILE *fpdb = NULL , *fpcard = NULL  ,*fpdom = NULL ;
unsigned short int dbkey , prodbkey;
unsigned char synolo_butstr[230]; //Για τα 10 ονόματα των 10 το πολύ φορτωμένων λιστών
unsigned char *synolo_fds , *synolo_fdata ;
unsigned int size_fds=512;
unsigned int size_fdata;

// char mmestr[24][110];
//unsigned int Xt,Xb,Yt,Yb,Wt,Wb,Ht,Hb ; // Menu Line , x and y Coordinates / Width - Height of screen elements 
//unsigned short int topinfxt, topinfyt , topinfxb, topdbnamext, toppgxt , dbcard , dbcard_opt=0, dbtotcardxt , dbtotcardxb;
//char top_str[40] , card_str [10];
//void *memx1=0 , *memy1=0 , *memx2 =0 , *memy2=0 ; // Δέσμευση μνήμης για τις συντεταγμένες όλων των rectangles (πεδία + labels) - απόδοση της μνήμης σε int * και στο τέλος απελευθέρωση των memx... 
//unsigned short int *dbx1 , *dby1 , *dbx2 , *dby2 ; // Εδώ είναι τα arrays των συντεταγμένων.
//short int dbrecs =0 ; // (Το άθροισμα των στοιχείων που αντιστοιχούν σε rectangles στις σελίδες της βάσης δεδομένων)
//short int db_elem[150][2] ;
//void *memk[100] , *memcp[100] ;
//unsigned short int limk[100] , xlimk[100] , xlim=0 , xmemk=0;
unsigned char *keimk , *ceimk;
//unsigned short int curk[100];
//unsigned int dbcardsize =0 , alma_deigma = 0;
time_t cardwhen ;

union {
    unsigned int ldate;
    unsigned char mydate[4]; // mydate[3]=Year/256 , mydate[2]=year%256 , mydate[1]=month , mydate[0]=day;
} cardiary;

union {
    unsigned short int wotim;
    unsigned char dyomikra[2];
} dysena;

unsigned short int hdhlpxt , hdhlpyt ;
int * baserg , *baserg1;
short int seflag=0;

// struct font button (dbfnt)
struct {
     unsigned short int fn_orio;
    unsigned short int fn_ar;
    unsigned char fn_name[30];
    void *mem_fn;
    unsigned char fn_data[20];
    int fn_elem;
    unsigned short int fn_sorton;
} dbfnt;

unsigned char  *synolo_fnts ;
unsigned int size_fnts=256;
void *inp_mem_ghost = 0;
unsigned short int gocards , firstcrit; // gocards = πόσες κάρτες ικανοποιούν κριτήρια , firstcrit = ο α/α της πρώτης κάρτας ...

char submenu[21][120] , submenu_1[21][120] ;;
unsigned short int dbaspro;

struct {
    unsigned int fd_ar;
    unsigned short int fd_sorton;
    void *mem_fd;
} dbsec;

unsigned int size_sec ;
unsigned char *synolo_sec ;
int helpchxr[3] , helpbkxr[3] ;
FILE *fpch ;
char missing[40];

unsigned short int *epil_pos =0 ;
unsigned short int tot_opts=0;
short int user_opts=0;
unsigned short int mulsel ;
//unsigned char crits[65534]; // Αν είναι 1 τότε η κάρτα ικανοποιεί τα κριτήρια εύρεσης.
char *dropfile;
unsigned char langex=0;
//short int logand=1;
unsigned char normdeigma[22] ;
//int fide_fpdb , fide_fpcard ,fide_fpdom, fide_lims ;
//char Strcardfp [1024] , Strdomfp[1024] ;
//unsigned char wasopdb=0 , wasopca=0 , wasopdo=0 ;

// EIDIKA GIA APPLICATION EORTES

# define ar_son 3290
# define ar_kon 308
# define ar_seo 688
# define ar_keo 43
# define ar_pagk 480

union koita {
    short int tog;
    char dm[2];
};

unsigned char enames[20000];
unsigned char egiortes[60000];
unsigned char pagk[ar_pagk][240] ; 
short int pagk_dm[ar_pagk] , etpagk_dm[ar_pagk] ;
unsigned char sonoma[ar_son][20] , seort[ar_seo][70] ;
unsigned char sonoma_a[ar_son][20] ;
unsigned char konoma[ar_kon][20] , keort[ar_keo][70] ;
unsigned char konoma_a[ar_kon][20];
short int santist[ar_son] , kantist[ar_kon] ;
short int vrika[ar_seo+ar_kon][2];
// Ταξινόμηση ονομάτων με βάση αύξων αριθμό εορτής
unsigned char ase_sonoma[ar_son][20] , ake_konoma[ar_kon][20];
short int ase_aa[ar_son] , ake_aa[ar_kon];
//
union koita ssee[ar_seo] , ksee[ar_keo] , k1see[ar_keo], gsee , prosee, etksee[ar_keo] ;
short int gyear=0 , gday=0, gmonth=0 , gnday=0;
short int an_pasx[ar_keo] ;
short int sinplin;
unsigned char mother[36] , father[36] ;
short int mo_dm,fa_dm ,mo1_dm, fa1_dm , etfa_dm , etmo_dm ;
int inpx , inpy , inpx1, inpy1, metr ;
unsigned char notes_str[60004];
unsigned char diary_notes[60004];
unsigned char omonth[13][12];
int inpbox=1 , Xx, Yy , Xxt , Yyt ;
SDL_Window *window;
SDL_DisplayMode DM , DM_2;

struct myepet {
    short int mob ; // 0 - 3 (σταθερή - κινητή - μητέρα - πατέρας)
    short int arkin;
    short int when;
    unsigned short int year ;
    unsigned char tex[70];
    unsigned char ktex[70];
    short int alarm ;
} ;

struct myepet pers[730] ;
short int pers1[730] ; 
short int pers_aldate[730][7];
short int etpers[730] ;
unsigned short int etpersyear[730] ;
short int ar_per , ar_per_1; //μέχρι 720 !!
unsigned char ettex[730][70] ;
char big_char [3096];
int status, fsel_code ;
char efarm_path[26] ;
int nofire , nochrom ;
void *remem;
pid_t pid ;
char *orisma[3]; 
int ar_pagk_1;
unsigned short int nefro , gamos , aytism , lepra , epilhc , spaui , spanies , ebook , pesontes , sleep_1 ;
unsigned short int diskop , noise , kanavi, gelio , asma , piano , apodhm_1 , apodhm_2 ;
unsigned short int cooperat , faros , noe17 , paralia , katoikia , arxitekt , birds ;
unsigned short int egg , orasi , streetart , xap , sofia , troxaio , antiagora , tuba , emporio ;
unsigned short int sklhr_plak , apostr_ast , surfing , admin ;
unsigned short int beer,geniada,ahelp,free_software,parhgoria,euronight,paulos_melas,wine_tour,kyst_inosi ;
unsigned int pran , pran_1;
short int win1h=0 , win2h=0 , win1m=0 , win2m=0 ;
int size_info ;
unsigned short int etseort[32] ;
unsigned char only_1[13][32] , only[13][32];
unsigned char DIaryn[13][32] , etDIaryn[13][32] , vrika_note[13][32] ;
short int ORL ;
int srise_h , srise_m , sset_h , sset_m ;

int timeZone = 2;
int moonNum = -1;
char* moonPhaseStr;
char MoonStr[100];
char moonrise_txt [100] , moonset_txt[100] ;
short int moon_ord ;

int notes_font , eortes_font , names_font , ponom_font , eortologio_font , pagkosm_font , personal_font , mobeort_font ;

char *Header = NULL ;

DIR * fold_p;

char eggr_str[40] , picts_str[40] ; 

struct RECURRENT {
   short int freq ; 
   unsigned short int enaryear;
   unsigned short int enarmonth;
   unsigned short int enardate;
   unsigned short int enarday;
   unsigned short int perasyear;
   unsigned short int perasmonth;
   unsigned short int perasdate;
   unsigned short int perasday;
   unsigned short int step ;
   unsigned short int weekday ;
   unsigned short int monthlast ;
   unsigned short int which ;
   unsigned short int alarm ;
   unsigned short int anast ;
   short int basic_option;
   unsigned short int extra1;
   unsigned char keim[70];
} rcr[250] , etrcr[250] ;

short int clue [250];
short int proclue [250];
short int ar_clue = 0 , etar_clue = 0 ;

union DMAK {
    unsigned int ak;
    unsigned short int mm ;
    unsigned short int yr[2];
    unsigned char damo[4];
} si , ami, tmi , tar , pre , eos , tyear ;

struct  YearRec {
    unsigned short int dom;
    unsigned short int date ;
} ;

struct YearRec *mri ,*mri_1 , *mra , *mra_1 , *mrs ;

unsigned int arst , arma ;
unsigned int c_arst = 0, c_arma = 0 ;
unsigned short int szYR ;
void *mem_g =NULL , *mem_a=NULL ;

/*
Κυρ = 1 , Δευ = 2 , Τρι = 3 , Τετ = 4, Πεμ = 5 , Παρ = 6 , Σαβ = 7 !

freq

freq = 0 : τίποτε - δεν παίζει .

freq = 1 : Κάθε rcr[].step ημέρες

freq = 7 : Κάθε εβδομάδα - συνδυάζεται με weekday
Παράδειγμα : κάθε εβδομάδα την Πέμπτη -> weekday = 5

freq = 30 : Κάθε Μήνα 
Παράδειγμα για freq = 30
Κάθε μήνα στις 23 του μήνα : monthdate = 23 , monthlast=0;
Κάθε μήνα την τελευταία ημέρα του μήνα  monthlast=1 , monthdate=0

freq = 31
Κάθε μήνα την 1η Κυριακή : which=1 , weekday=1
Κάθε μήνα το τελευταίο Σάββατο : which=5 , weekday = 7

freq = 32
Κάθε 6 μήνες με έναρξη σήμερα   (enardate) - step = 6 , monthlast = 0 ;
Κάθε 4 μήνες την τελευταία ημέρα του μηνός : monthlast=1 , step=6  

freq = 365 : Κάθε χρόνο
Παράδειγμα
Στις 20 του μηνός Σεπ : which=0 , rcr[].tosoi=1, yeardate=20 , yearmonth=9
Την τελευταία Κυριακή του χρόνου : rcr[].tosoi=1, which = 5 , yearmonth=12 , yearday = 1 
Την 2η Τετάρτη του μηνός Μαρτίου : rcr[].tosoi=1, which = 2 , yearmonth=3 , yearday = 4


freq = 1000 : Κάθε τόσα χρόνια
Παράδειγμα
Κάθε 3 χρόνια στις 23 Απρ : years=3 , years_month=4 , years_date = 23

Μετά από επιλογή στο μενού για το κάθε 2η Τρίτη ή κάθε τελευταία Κυριακή κλπ :
user_ans = ...έστω 12 (από 0 έως και 34)
which = (user_ans/7) + 1 ; άρα 2
monthday (ή yearday με δεδομένο το yearmonth) = (user_ans % 7) + 1 ; 
άρα 6 - Παρασκ.

*/

short int win_count = 0 ;
short int Diary ;
char Diary_path [1024];
char diary_entry[128];
char diary_filename[40] , pre_diary_filename[40];
char etdiary_filename[40] ;
short int shlp = 0 ;
void *mem_atono = NULL ;
unsigned char temp_notes[60004];
unsigned char nelement[22] ;
void *pomem = 0;
unsigned char please_wait[50];
short int syscalls , appimage ;
short int secwin=0;

enum local_font { souvenir=0 , notosans_22n , 
    arial_12, times_18 , 
    sanserif_18, caviar , 
    impact , sanserif_21, 
    notosans_10b , notosans_11b, 
    notosans_12n, notosans_12b, 
    notosans_14n, notosans_14b, 
    notosans_16n, notosans_16b, 
    notosans_18n , notosans_18b , 
    notosans_20n , notosans_20b,
    notosans_24n , notosans_28n, notosans_32n,
    notoserif_20n, notoserif_20b,
    theokritos ,  
    neohell_13b , neohell_14b , neohell_16n , neohell_18n ,  
    neohell_20n, neohell_20b , neohell_22n, neohell_22b , neohell_24n, neohell_28n , neohell_32n ,
    calligra_20n, calligra_22n , calligra_24n , 
    bookman_14n,bookman_16n,bookman_18n,
    bookman_20n, bookman_22n, bookman_24n, bookman_28n, bookman_32n } ;

/////// MAIN /////////////////////////// MAIN  ////////////////////////////////// M A I N ///////////////////////////////////// MAIN //////////////////////////

int main(int argc , char *argv[] )
{

SDL_Cursor* cursor;
uid_t uid ;
struct passwd *pw ;
struct fansouv *whouv;

union pixcols{
  int ltimi;
  unsigned char xro[4];
} pixel ;

union {
    long unsigned int big;
    unsigned char sma[8];
} xitem [3] ;

struct XX4_bytes {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};

struct XX4_bytes *item , check_item ;

unsigned int *Gitem ;
long int *Litem ;
double *Fitem;
time_t *Ditem;
int gkribkxr[3] ,blackchxr[3];
FILE *fp ,*fpout=NULL ;
int fide_fp , fide_fpout;
char str[512];
char ch,cha, chb, chc, ch_state;
unsigned char ch2 , what , ch3 , *gen_ergo , deigma[28] ;
unsigned short int ch1 , cur ,mbut , ar ,low , *ar_dom , *new_dom , thesi , p ,f1 ;
short int w, h , a1 , m , a , c , kyk , posafoto , papiso , tokyk=100 , rego=0 ;
register int i , f;
unsigned int mem_need  ;
void *mem1 = 0 , *mem2=0 , *mem3=0, *item_mem=0 ,*new_dom_vo=0 , *mem_search , *mem4=0;
void *mem_butmenu=0 , *mem_pgdn=0 , *mem_pgup=0 , *mem_chain=0 , *mem_kato=0 , *mem_savecard =0 , *mem_leftcard =0 , *mem_rightcard =0 , *mem_sumdb=0 , *ardom_mem=0 , *mem_usersel=0 ;
void *mem_addcard=0 ;
int *mem_int , *pgchxr;
int size , start ;
unsigned short int ch_mod,ch_scan;
const Uint8 *state ;
int mx, my, mx1, my1 ,x ,y ,diaf1 , user_ans , Cx1, Cy1, Cx2, Cy2 ,dx, dy , i1 ;
long int lbig , Lidb ;
double fbig , Fidb;
unsigned int Gidb ;
unsigned short int sGidb , sG ;
double big_d , big_t;
unsigned short int bmenuxt, bmenuyt, bmenuxb, bmenuyb ,ektos ,ox1, ox2, oy1, oy2 , gx2, gy2, dbwxr , butpgupxt , butpgdnxt , topdbnamext , topdbnamexb , cardlext, cardrixt , cardsaxt , cardNoxt , cardNoxb , dbasext  , cardnewxt , uhupgxt , uhupgxb, cardareaxt , cardareaxb ;  
unsigned short int search_flagxt , how_many ;
char new_dbname[64];
unsigned char dbopen;
unsigned char *list_str , *eplfi ,*percho ;
int inp_pedaba[4];
int redchxr[3] , greenchxr[3]; int orangechxr[3];
char *ptr_ch , totcard_str[10];
short int back_arped , proel, progvn , dbpgup=0 , dbpgdn=0 , alma=0 , cardribut=0, cardlebut=0 , cardsabut=0 , cardnewbut=0 , cardareabut=0 ;
short int critflag=0 , dbfname=0 , dbincards=0;
short int by , rby , sumcrit, rl ;
unsigned char nu[4];
char photopath[1024];
unsigned char *deigma_text ;
unsigned char klik ;
unsigned char savenow=0;
int savebkxr[3];
//int fide_rlist , fide_notes , fide_exp ;
unsigned char ex_file=0;

char keyb_path[30]; char locals_path[30]; char dir_path [30] ;

char *font_filename[ttf];
char app_name[128];

// TELOS METABLHTVN
//See man getlogin_r


info_p = &info;
info_p2 = &info_2;
info_p3 = &info_3;
info_p4 = &info_4 ;
info_p5 = &info_5 ;
size_info = sizeof ((struct viewporttype) info) ;
if( SDL_Init( SDL_INIT_VIDEO ) < 0 ) { printf( "SDL could not initialize! SDL_Error: %s\n", SDL_GetError() ); return 0;}
//Να δούμε το maximum της οθόνης
SDL_GetCurrentDisplayMode(0, &DM);
Xx = DM.w;
Yy = DM.h;

if (Xx<1280 || Yy<760) {printf ("Screen Resolution Very Small - Exit \n") ; return 0;}
/*
x=(x-1280)/2;
y=(y-760)/2;
setwinoptions("D A Y S",x,y,-1);
gkribkxr[0]=gkribkxr[1]=gkribkxr[2]=100;
blackchxr[0]=blackchxr[1]=blackchxr[2]=0;
//SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
initwindow (1280,760);
//setactivepage(0);
sdlbgifast();
win_id=getcurrentwindow();
getviewsettings (info_p);
setblendmode (SDL_BLENDMODE_BLEND);
qcls(100,100,100);
*/

// Δείκτες πινάκων Fonts
// Fonts Names - width - height

for (f=0 ; f<ttf ; f++) { mem_Font[f]= 0; } // Μηδενίζω void δείκτες των fonts

for (f=0 ; f<730 ; f++) {
    pers[f].tex[0] = 255 ;
    pers[f].ktex[0] = 255 ;
}

for (f=0 ; f<250 ; f++) {
    rcr[f].keim[0] = 255;
}

diary_filename[0] = '\0'; pre_diary_filename[0] = '\0' ;

souv = myfont[souvenir] ; nouv = myfont[notosans_22n] ; 
//sarial = myfont[arial_12];
sarial = myfont[notosans_11b];

font_filename[souvenir] = "SOUVENIR_16N.dat" ;
font_filename[notosans_22n] = "NOTOSANS_22N.dat" ;
font_filename[arial_12] = "Arial_12.dat" ;
font_filename[times_18] = "TIMES_18.dat" ;
font_filename[sanserif_18] = "SnsSrf_18.dat" ;
font_filename[caviar] = "Caviar_22.dat" ;
font_filename[impact] = "Impact_20.dat" ;
font_filename[sanserif_21] = "SnSerif_21.dat" ;

font_filename[notoserif_20n] = "NOTOSERIF_20N.dat" ;
font_filename[notoserif_20b] = "NOTOSERIF_20Bo.dat" ;
font_filename[theokritos] = "GFS_Theokritos_22.dat" ;

font_filename[notosans_10b] = "NOTOSANS_10Bo.dat" ;
font_filename[notosans_11b] = "NOTOSANS_11Bo.dat" ;
font_filename[notosans_12n] = "NOTOSANS_12N.dat" ;
font_filename[notosans_12b] = "NOTOSANS_12Bo.dat" ;
font_filename[notosans_14n] = "NOTOSANS_14N.dat" ;
font_filename[notosans_14b] = "NOTOSANS_14Bo.dat" ;
font_filename[notosans_16n] = "NOTOSANS_16N.dat" ;
font_filename[notosans_16b] = "NOTOSANS_16Bo.dat" ;
font_filename[notosans_18n] = "NOTOSANS_18N.dat" ;
font_filename[notosans_18b] = "NOTOSANS_18Bo.dat" ;
font_filename[notosans_20n] = "NOTOSANS_20N.dat" ;
font_filename[notosans_20b] = "NOTOSANS_20bo.dat" ;
font_filename[notosans_24n] = "NOTOSANS_24N.dat" ;
font_filename[notosans_28n] = "NOTOSANS_28N.dat" ;
font_filename[notosans_32n] = "NOTOSANS_32N.dat" ;

font_filename[neohell_13b] = "NEOHELL_13Bo.dat" ;
font_filename[neohell_14b] = "NEOHELL_14B.dat" ;

font_filename[neohell_16n] = "NEOHELL_16N.dat" ;
font_filename[neohell_18n] = "NEOHELL_18N.dat" ;

font_filename[neohell_20n] = "GFS_NEOHELLENIC_20N.dat" ;
font_filename[neohell_20b] = "GFS_NEOHELLENIC_20Bo.dat" ;
font_filename[neohell_22n] = "GFS_NEOHELLENIC_22N.dat" ;
font_filename[neohell_22b] = "GFS_NEOHELLENIC_22Bo.dat" ;
font_filename[neohell_24n] = "GFS_NEOHELLENIC_24N.dat" ;
font_filename[neohell_28n] = "GFS_NEOHELLENIC_28N.dat" ;
font_filename[neohell_32n] = "GFS_NEOHELLENIC_32N.dat" ;

font_filename[calligra_20n] = "CALIGRAF_20.dat" ;
font_filename[calligra_22n] = "CALIGRAF_22.dat" ;
font_filename[calligra_24n] = "CALIGRAF_24.dat" ;

font_filename[bookman_14n] = "BOOKMAN_14N.dat" ;
font_filename[bookman_16n] = "BOOKMAN_16N.dat" ;
font_filename[bookman_18n] = "BOOKMAN_18N.dat" ;
font_filename[bookman_20n] = "BOOKMAN_20N.dat" ;
font_filename[bookman_22n] = "BOOKMAN_22N.dat" ;
font_filename[bookman_24n] = "BOOKMAN_24N.dat" ;
font_filename[bookman_28n] = "BOOKMAN_28N.dat" ;
font_filename[bookman_32n] = "BOOKMAN_32N.dat" ;

/*
myfont_hei[souvenir]=18;  // souv
//myfont_wid[souvenir]=16; 
myfont_hei[notosans_22n]=26;  //nouv
//myfont_wid[notosans_22n]=19;
myfont_hei[arial_12]=13; // Arial 12
//myfont_wid[arial_12]=12;
myfont_hei[times_18]=19; // Times 18
//myfont_wid[times_18]=18;
myfont_hei[sanserif_18]=22; // SansSer 18
//myfont_wid[sanserif_18]=18;
myfont_hei[caviar]=25; // Caviar Dreams 22
//myfont_wid[caviar]=22;
myfont_hei[impact]=23; // Impact 20
//myfont_wid[impact]=20;
myfont_hei[sanserif_21]=25; // SansSer 21
//myfont_wid[sanserif_21]=21;

myfont_hei[notosans_18n]=24; // NOTOSANS_18N
//myfont_wid[notosans_18n]=16;
myfont_hei[notosans_18b]=24; // NOTOSANS_18B
//myfont_wid[notosans_18b]=18;

myfont_hei[notosans_20n]=26; // NOTOSANS_20N
//myfont_wid[notosans_20n]=18;

myfont_hei[notosans_20b]=26; // NOTOSANS_20B
//myfont_wid[notosans_20b]=19;

myfont_hei[notoserif_20n]=25; // NOTOSERIF_20N
//myfont_wid[notoserif_20n]=20;

myfont_hei[notoserif_20b]=25; // NOTOSERIF_20B
//myfont_wid[notoserif_20b]=20;

myfont_hei[theokritos]=23; // gfs_theokritos
//myfont_wid[theokritos]=21;

myfont_hei[notosans_10b]=14; // NOTOSANS_10B
//myfont_wid[notosans_10b]=10;

myfont_hei[notosans_11b]=13; // NOTOSANS_11B
//myfont_wid[notosans_11b]=11;

myfont_hei[notosans_12n]=15; // NOTOSANS_12N
//myfont_wid[notosans_12n]=12;

myfont_hei[notosans_12b]=15; // NOTOSANS_12B
//myfont_wid[notosans_12b]=13;

myfont_hei[notosans_14n]=18; // NOTOSANS_14N
//myfont_wid[notosans_14n]=13;

myfont_hei[notosans_14b]=18; // NOTOSANS_14B
//myfont_wid[notosans_14b]=14;

myfont_hei[notosans_16n]=20; // NOTOSANS_16N
//myfont_wid[notosans_16n]=15;

myfont_hei[notosans_16b]=21; // NOTOSANS_16B
//myfont_wid[notosans_16b]=16;

myfont_hei[neohell_13b]=15 ; // neohell_13B - wid 13

myfont_hei[neohell_14b]=15 ; // neohell_14b - wid 13

myfont_hei[neohell_16n]=18 ; // neohell_16n - wid 14
myfont_hei[neohell_18n]=20 ; // neohell_18n - wid 16

myfont_hei[neohell_20n]=22; // neohell_20N
//myfont_wid[neohell_20n]=18;

myfont_hei[neohell_20b]=23; // neohell_20B
//myfont_wid[neohell_20b]=20;

myfont_hei[neohell_22n]=24; // neohell_22N
//myfont_wid[neohell_22n]=20;

myfont_hei[neohell_22b]=25; // neohell_22B
//myfont_wid[neohell_22b]=20;

myfont_hei[neohell_24n]=27; // neohell_24N - wid = 21

myfont_hei[neohell_28n]=31; // neohell_28N - wid = 25

myfont_hei[neohell_32n]=34; // neohell_32N
//myfont_wid[neohell_32n]=28;

myfont_hei[calligra_20n]=23; // calligra_20
//myfont_wid[calligra_20n]=23;

myfont_hei[calligra_22n]=25; // calligra_22
//myfont_wid[calligra_22n]=23;

myfont_hei[calligra_24n]=27; // calligra_24 - wid 23

myfont_hei[notosans_24n]=29; // NOTOSANS_24N - wid = 21
myfont_hei[notosans_28n]=33; // NOTOSANS_28N - wid = 25
myfont_hei[notosans_32n]=38; // NOTOSANS_32N - wid = 28

myfont_hei[notosans_24n]=29; // NOTOSANS_24N - wid = 21

myfont_hei[bookman_14n]=15; // wid 14
myfont_hei[bookman_16n]=18; // wid 16
myfont_hei[bookman_18n]=21; // wid 18
myfont_hei[bookman_20n]=23; // wid 20
myfont_hei[bookman_22n]=25; // wid 22
myfont_hei[bookman_24n]=27; // wid 24
myfont_hei[bookman_28n]=31; // wid 27
myfont_hei[bookman_32n]=36; // BOOKMAN_32N - wid = 31

*/

strcpy (myfont_name[souvenir] , "Souvenir 16");
strcpy (myfont_name[notosans_22n] , "NotoSans 22n");
strcpy (myfont_name[arial_12] , "Arial 12");
strcpy (myfont_name[times_18] , "Times 18");
strcpy (myfont_name[sanserif_18] , "Sans Serif 18");
strcpy (myfont_name[caviar] , "Caviar Dreams 22");
strcpy (myfont_name[impact] , "Impact 20");
strcpy (myfont_name[sanserif_21] , "Sans Serif 21");
strcpy (myfont_name[notosans_18n] , "NotoSans 18n");
strcpy (myfont_name[notosans_18b] , "NotoSans 18b");
strcpy (myfont_name[notosans_20n] , "NotoSans 20n");
strcpy (myfont_name[notosans_20b] , "NotoSans 20b");
strcpy (myfont_name[notoserif_20n] , "NotoSerif 20n");
strcpy (myfont_name[notoserif_20b] , "NotoSerif 20b");
strcpy (myfont_name[theokritos] , "GFS Theokritos 22");
strcpy (myfont_name[notosans_10b] , "NotoSans 10b");
strcpy (myfont_name[notosans_11b] , "NotoSans 11b");
strcpy (myfont_name[notosans_12n] , "NotoSans 12n");
strcpy (myfont_name[notosans_12b] , "NotoSans 12b");
strcpy (myfont_name[notosans_14n] , "NotoSans 14n");
strcpy (myfont_name[notosans_14b] , "NotoSans 14b");
strcpy (myfont_name[notosans_16n] , "NotoSans 16n");
strcpy (myfont_name[notosans_16b] , "NotoSans 16b");
strcpy (myfont_name[notosans_24n] , "NotoSans 24n");
strcpy (myfont_name[notosans_28n] , "NotoSans 28n");
strcpy (myfont_name[notosans_32n] , "NotoSans 32n");
strcpy (myfont_name[neohell_13b] , "NeoHellenic 13b");
strcpy (myfont_name[neohell_14b] , "NeoHellenic 14b");
strcpy (myfont_name[neohell_16n] , "NeoHellenic 16n");
strcpy (myfont_name[neohell_18n] , "NeoHellenic 18n");
strcpy (myfont_name[neohell_20n] , "NeoHellenic 20n");
strcpy (myfont_name[neohell_20b] , "NeoHellenic 20b");
strcpy (myfont_name[neohell_22n] , "NeoHellenic 22n");
strcpy (myfont_name[neohell_22b] , "NeoHellenic 22b");
strcpy (myfont_name[calligra_20n] , "Calligra 20");
strcpy (myfont_name[calligra_22n] , "Calligra 22");
strcpy (myfont_name[calligra_24n] , "Calligra 24");
strcpy (myfont_name[neohell_24n] , "NeoHellenic 24n");
strcpy (myfont_name[neohell_28n] , "NeoHellenic 28n");
strcpy (myfont_name[neohell_32n] , "NeoHellenic 32n");

strcpy (myfont_name[bookman_14n] , "Bookman 14n");
strcpy (myfont_name[bookman_16n] , "Bookman 16n");
strcpy (myfont_name[bookman_18n] , "Bookman 18n");
strcpy (myfont_name[bookman_20n] , "Bookman 20n");
strcpy (myfont_name[bookman_22n] , "Bookman 22n");
strcpy (myfont_name[bookman_24n] , "Bookman 24n");
strcpy (myfont_name[bookman_28n] , "Bookman 28n");
strcpy (myfont_name[bookman_32n] , "Bookman 32n");

strcpy (file_1,"/bin/setxkbmap");
 if(!access(file_1, F_OK )) strcpy (keyb_path,file_1) ; else strcpy (keyb_path,"/usr/bin/setxkbmap") ;
 
 strcpy (file_1,"/bin/dir");
 if(!access(file_1, F_OK )) strcpy (dir_path,file_1) ; else strcpy (dir_path,"/usr/bin/dir") ;
 
strcpy (file_1,"/bin/locale");
 if(!access(file_1, F_OK )) strcpy (locals_path,file_1) ; else strcpy (locals_path,"/usr/bin/locale") ;

fsel_code=0;

if (!fsel_code) {
strcpy (efarm_path,"/usr/bin/yad");
if(!access(efarm_path, F_OK ))  fsel_code=1; 
if (!fsel_code) {
strcpy (efarm_path,"/bin/yad");
if( ( !access(efarm_path, F_OK )  ) ) fsel_code=1;  } 
}

if (!fsel_code) {
strcpy (efarm_path,"/usr/bin/zenity");
if(!access(efarm_path, F_OK ))  fsel_code=3;
if (!fsel_code) {
strcpy (efarm_path,"/bin/zenity");
if( ( !access(efarm_path, F_OK )  ) ) fsel_code=3;}
}


if (!fsel_code) {
    strcpy (efarm_path,"/bin/kdialog");
    if(!access(efarm_path, F_OK ))  fsel_code=2;
    if (!fsel_code) {
    strcpy (efarm_path,"/usr/bin/kdialog");
    if( (!access(efarm_path, F_OK ) ) ) fsel_code=2; }
}

if(!access("/usr/bin/firefox", F_OK )) nofire=0; else nofire=1;
if(!access("/usr/bin/google-chrome", F_OK )) nochrom=0 ; else nochrom=1 ;


inp_pedaba[0]=22111963; inp_pedaba[1]=404976; inp_pedaba[2]=99; inp_pedaba[3]=167330;

topbkxr[0]=topbkxr[1]=topbkxr[2]=0;
topchxr[0]=topchxr[2]=92; topchxr[1]=240;
topslxr[0]=32; topslxr[1]=19; topslxr[2]=192;

dbbkxr[0]=dbbkxr[1]=dbbkxr[2]=30;
dbchxr[0]=dbchxr[2]=92; dbchxr[1]=206;
dbslxr[0]=32; dbslxr[1]=19; dbslxr[2]=140;

helpchxr[0]=helpchxr[1]=helpchxr[2]=0;
helpbkxr[0]=helpbkxr[2]=60 ; helpbkxr[1]=180 ;

eisag[0]=0 ; eisag[1]=41 ; eisag[2]=0 ; // Πρασινωπό  
sxedom[0]=sxedom[2]=168 ; sxedom[1]=0; // ροζ
parous[0]=0 ; parous[1]=30 ; parous[2]=255 ; // Μπλέ  
klperg[0]=klperg[1]=klperg[2]=46 ;  // Γκρί 
delerg[0]=129 ; delerg[1]=delerg[2]=0 ; // Κοκκινωπό
dbrecxr = 777; dbscrxr=778; dbmag=779; dbtop=780;dbred=781;dbselxr=782;dbgreen=783;dbblack=784;dbyel=785;
dbhelpcol=790; dbaspro=791 ;
setrgbpalette(dbrecxr,dbchxr[0],dbchxr[1],dbchxr[2]);
setrgbpalette(dbscrxr,dbbkxr[0],dbbkxr[1],dbbkxr[2]);
setrgbpalette(dbselxr,dbslxr[0],dbslxr[1],dbslxr[2]);
setrgbpalette(dbblack,0,0,0);
setrgbpalette(dbyel,255,255,0);
setrgbpalette(dbhelpcol,255,255,0);

setrgbpalette(dbmag,255,0,255);
setrgbpalette(dbred,255,0,0);
setrgbpalette(dbgreen,0,255,0);
setrgbpalette(dbaspro,255,255,255);
setrgbpalette(dbtop,topbkxr[0],topbkxr[1],topbkxr[2]);

bkxr[0]=48;bkxr[1]=57;bkxr[2]=0;
chxr[0]=40;chxr[1]=255;chxr[2]=229;
slxr[0]=47;slxr[1]=0;slxr[2]=76;

bkxr1[0]=48;bkxr1[1]=57;bkxr1[2]=0;
chxr1[0]=40;chxr1[1]=255;chxr1[2]=229;
slxr1[0]=47;slxr1[1]=0;slxr1[2]=76;

savebkxr[0]=255 ; savebkxr[1]=215; savebkxr[2]=0 ;

syncardchxr[0]=254 ; syncardchxr[1]=108 ; syncardchxr[2]=255 ; 
syncardbkxr[0] = 11 ; syncardbkxr[1] = 78 ; syncardbkxr[2] = 82 ; 


//dbfisize=sizeof(struct fanfield );
//dblasize=sizeof (struct fanlabel);
pdaba[0]=112263; pdaba[1]=559500; pdaba[2]=120; pdaba[3]=17330;

// DISCOVER CURRENT (running application) DIRECTORY path_name
pran=0;

if (!pran) {

auto char buf[PATH_MAX];
auto ssize_t apl_dir = readlink("/proc/self/exe", buf,PATH_MAX-1);
i=0;
if (apl_dir==-1) { printf ("Can't Get Application Directory pathname - Abort !\n"); goto gamidia; }
for (f=0 ; f<800 ; f++) {
    path_name[f] = buf[f];
    if (path_name[f]=='\0') {i=1; break;}
}

if (!i) { printf ("Application Directory Pathname too long - Abort !\n"); goto gamidia;}
while (path_name[f] != '/') { f-- ;}

i=f; i1=0;
do {
i++;
app_name[i1++] = path_name[i]; 
}
while (path_name[i]!= '\0') ;

path_name[f+1] = '\0';
printf ("path = %s\n" , path_name); printf ("application = %s\n",app_name);
/*
ptr_char = getcwd (path_name, 800) ;
if (ptr_char==NULL) {
    if (errno==ENAMETOOLONG) printf ("Directorys pathname too long. Abort !\n");
    else printf ("Can't Get Directory's pathname - Abort !\n");
goto gamidia;
}
*/
}

// Έλεγχος αν τρέχει appimage είτε κανονικά είτε στη φάση της κατασκευής.
ptr_char = strstr(path_name,"AppDir");
if (ptr_char==NULL) {
	ptr_char = strstr(path_name,"tmp");
	if (ptr_char==NULL) {
        appimage = 0 ;
		}
		else { appimage=1; }
	}
	else appimage=2; // Είναι μέσα στο AppDir....
	

// DISCOVER THE USER NAME - define user_path (και για Εικόνες και Έγγραφα)

i=1 ;
f = getlogin_r(user_name,40) ;
if (f) {
    ptr_char = getlogin();
    if (ptr_char!=NULL) {sprintf (user_name,"%1.39s", ptr_char); sprintf(user_path,"/home/%s/",user_name); }
    else 
    {
    uid = geteuid();
    pw = getpwuid(uid);
        if (pw) {sprintf (user_name,"%1.39s", pw->pw_name);sprintf(user_path,"/home/%s/",user_name);}
        else {
            printf ("Can't Get User's Name to define the /Home/Users_pathname !\n");
            strcpy (user_path,"/home/");
            i=0 ;
        }
    }
} else {
    sprintf(user_path,"/home/%s/",user_name);
}


if (i) {
    f=0;
    sprintf(file_1,"%s%s",user_path,"Έγγραφα");
    fold_p = opendir(file_1) ;
    if (fold_p != NULL) { f=1; strcpy (eggr_str,"Έγγραφα/") ; closedir (fold_p) ; }
    if (!f) {
        sprintf(file_1,"%s%s",user_path,"Documents");
        fold_p = opendir(file_1) ;
        if (fold_p != NULL) { f=1; strcpy (eggr_str,"Documents/"); closedir (fold_p) ; }
    }
    if (!f) eggr_str[0] = '\0';
    
    f=0 ;

    sprintf(file_1,"%s%s",user_path,"Εικόνες");
    fold_p = opendir(file_1) ;
    if (fold_p != NULL) { f=1 ; strcpy (picts_str,"Εικόνες/") ; closedir (fold_p) ; }
    if (!f) {
        sprintf(file_1,"%s%s",user_path,"Pictures");
        fold_p = opendir(file_1) ;
        if (fold_p != NULL) { f=1; strcpy (picts_str,"Pictures/") ; closedir (fold_p) ; }
    }
    if (!f) picts_str[0] = '\0';
}
else {
    eggr_str[0] = '\0'; picts_str[0] = '\0';
}

f=i=0;

/*
if (! (getlogin_r(user_name,40))) sprintf(path_name,"/home/%s%s",user_name,"/Eortescalcd/");
    else { 
            ptr_char=getlogin();

            if (ptr_char!=NULL) {sprintf (user_name,"%1.19s", ptr_char); sprintf(path_name,"/home/%s%s",user_name,"/Eortescalcd/");}
                else 
                {
                uid = geteuid();
                pw = getpwuid(uid);
                    if (pw) {sprintf (user_name,"%1.19s", pw->pw_name); sprintf(path_name,"/home/%s%s",user_name,"/Eortescalcd/");}
                    else exit (0);
                }}
*/


ptr_char=0;
// ELEGXOS GIA AGGLIKO - ELLHNIKO PLHKTROLOGIO
/*
sprintf(str1024,"setxkbmap -query > %s%s",path_name,"kbmap.txt");
system(str1024);
sprintf(file_1,"%s%s",path_name,"kbmap.txt");
fp=fopen(file_1,"r");
if (fp==NULL) {perror("I/O Problem"); goto gamidia;}
str[0]='\0';
do{
fgets(str,30,fp);
*/
sprintf(big_char,"%s -query",keyb_path);
fp = NULL ;

// Περισυλλογή στοιχείων...
fp=read_pipe(big_char) ;
f=0;

if (fp!=NULL) { 
    
    syscalls=1 ;
    str[0]='\0';
    while ( fgets(str,30,fp) ) {
    ptr_char=strstr(str,"layout");
    if (ptr_char!=NULL) 
        {
        if (!f) { f=1; }
        ptr_char=strstr(str,"us");
        if (ptr_char!=NULL) { keyb_us=1 ; f=2; } 
        ptr_char=strstr(str,"uk");
        if (ptr_char!=NULL) { keyb_us=1 ; f=2; }
        ptr_char=strstr(str,"gr");
        if (ptr_char!=NULL) { keyb_gr=1 ; f=2; } 
        break;
        }
        else if (ferror(fp)) {clearerr(fp); break ;}
        else continue;
    }

    if (ferror(fp)) {clearerr(fp); pclose(fp);}
    else pclose(fp); 
    fp=NULL;
    
    if (f==1) {printf("Forced US and GR support for the keyboard \n");}
    keyb_us=1; keyb_gr=1;
    
}
else 
{
    syscalls = 0 ;
    if (appimage==1) printf ("To application image δεν είναι πλήρως λειτουργικό στο συγκεκριμένο περιβάλλον !\n");
    else if (!appimage)  printf ("Η εφαρμογή δεν είναι πλήρως λειτουργική στο συγκεκριμένο περιβάλλον !\n");
    fsel_code = 0 ;
    nofire=1; nochrom=1;
    printf("Forced US and GR support for the keyboard \n");keyb_us=1; keyb_gr=1;
}




f=0; i=0;

    // ELEGXOS GIA ELLHNIKH GLVSSA

    strcpy (big_char,locals_path);  
    fp=NULL ;
    fp=read_pipe(big_char) ;
    if (fp!=NULL) {
        auto char *ptr_temp ;
        
        str[0]='\0';
        do{
        fgets(str,30,fp);
        printf("%s\n",str);
        ptr_char=strstr(str,"LANG");
        if (ptr_char!=NULL) 
            { 
            i=1;
            ptr_temp=strstr(str,"el");
            if (ptr_temp!=NULL) { keyb_gr=1 ; f=1; } 
            ptr_temp=strstr(str,"GR");
            if (ptr_temp!=NULL) { keyb_gr=1 ; f=1; } 
            break;
            }
            else continue;
        }
        while ( ! feof(fp) ) ;
        if (ferror(fp)) {clearerr(fp); pclose(fp);}
        else pclose(fp); fp=NULL;
    }
    else {
        printf ("Problem with Locale identification !\n");
    }

    if (f) { printf ("Normal Greek Lang. Support!\n");}
    else if (i) { keyb_gr=1; printf ("Forced Greek Lang. Support!\n"); }
    else {
        syscalls = 0 ; fsel_code = 0 ; nofire=1; nochrom=1;
        if (appimage==1) printf ("To application image δεν φαίνεται πλήρως λειτουργικό στο συγκεκριμένο περιβάλλον !\n");
        else if (!appimage) printf ("Η εφαρμογή δεν φαίνεται πλήρως λειτουργική στο συγκεκριμένο περιβάλλον !\n");
        printf ("Forced Greek Lang. Support!\n");
    }

//sprintf (file_2,"%s%s",path_name,"TMP/zenout.dat");
//fpout=freopen(file_2,"w",stdout);

//if ( fpout==NULL ) { printf("stdout redirection problem\n") ; }
//fide_fpout = fileno (fpout);

if (!appimage)
{
		// Δειγματοληπτικός Ελεγχος Τοποθέτησης κανονικού εκτελέσιμου αρχείου σε σχέση με τον φάκελο της εφαρμογής
		sprintf(file_1,"%s%s",path_name,"lib/libSDL_bgi.so");
		if (access(file_1, F_OK )) {
		    printf("Please run the executable file from inside the applications folder!\n");
		    printf("Παρακαλώ τρέξτε το εκτελέσιμο αρχείο μέσα από το φάκελο της εφαρμογής!\n");
		    goto gamidia;
		}
}

Diary = 0 ;
// Έλεγχο για φάκελλο .EORT_SETTINGS - TMP - Diary
sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS");
fold_p = opendir(str1kb) ;
if (fold_p==NULL) { // Δεν υπάρχει ο .EORT_SETTINGS
    int st ;
    st = mkdir(str1kb, 0777);
    if (st==-1) {
        printf ("Δεν είναι δυνατή η δημιουργία του φακέλλου .EORT_SETTINGS μέσα στο %s ! Αναγκαίος τερματισμός..\n" , user_path);
        goto gamidia;
    }
    
    // Δημιουργία του TMP
     sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS/TMP");
     st = mkdir(str1kb, 0777);
        if (st==-1) {
        printf ("Δεν είναι δυνατή η δημιουργία του φακέλλου TMP μέσα στο %s%s !\n" , user_path,".EORT_SETTINGS/");
        printf ("Αναγκαίος τερματισμός..\n");
        goto gamidia;
    }
    
    // Δημιουργία του DIARY
     sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS/DIARY");
     st = mkdir(str1kb, 0777);
        if (st==-1) {
            Diary = 0 ;
            printf ("Δεν είναι δυνατή η δημιουργία του φακέλλου DIARY μέσα στο %s%s !\n" , user_path,".EORT_SETTINGS/");
    }
    else { Diary = 1; strcpy (Diary_path , str1kb) ; }
}
else { 
    // *********************** Υπάρχει ο .EORT_SETTINGS
    closedir (fold_p); 
    // Τσεκάρω για Diary
    sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS/DIARY");
    fold_p = opendir(str1kb) ;
    if (fold_p==NULL) {
        int st ;
        st = mkdir(str1kb, 0777);
        if (st==-1) {
        printf ("Δεν είναι δυνατή η δημιουργία του φακέλλου DIARY μέσα στο %s%s !\n" , user_path,".EORT_SETTINGS/");
        Diary = 0 ;
        }
        else { Diary=1; strcpy (Diary_path , str1kb) ; }
    }
    else {
        Diary = 1 ;
        closedir (fold_p);
        strcpy (Diary_path , str1kb) ;
    }
    
    // Τσεκάρω για TMP
    sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS/TMP");
    fold_p = opendir(str1kb) ;
    if (fold_p==NULL) {
        int st ;
        st = mkdir(str1kb, 0777);
        if (st==-1) {
        printf ("Δεν είναι δυνατή η δημιουργία του φακέλλου TMP μέσα στο %s%s !\n" , user_path,".EORT_SETTINGS/");
        printf ("Αναγκαίος τερματισμός..\n");
        goto gamidia;
        }
    }
    else {
        closedir (fold_p);
    }
}

fold_p = NULL ;
if (Diary) {strcat (Diary_path,"/");}

// ΕΛΕΓΧΟΣ ΓΙΑ inpbox
    sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS/NotesBox.dat");
    
    if (!access(str1kb, F_OK )) {
    fp=fopen(str1kb,"rb");
    if (fp==NULL) {
        printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
        fp=fopen(str1kb,"wb");
        fide_fp=fileno(fp);
        fwrite (&inpbox,4,1,fp);
        fdatasync (fide_fp);
        fsync (fide_fp);
        fclose(fp);
        }
    else {
        fread (&inpbox,4,1,fp);
        fclose (fp) ;
        }
    }   
    else {
    // Δεν βρέθηκε το inpox στον φάκελο Settings - άρα είναι πρώτη φορά - αρχικοποιώ !
    	inpbox=1;
        fp=fopen(str1kb,"wb");
        fide_fp=fileno(fp);
        fwrite (&inpbox,4,1,fp);
        fdatasync (fide_fp);
        fsync (fide_fp);
        fclose(fp);
    
   }


// WINDOW OPEN
h = (inpbox) ? 760 : 760-223 ;
Xx=(Xx-1280)/2;
Yy=(Yy-h)/2;
setwinoptions("Ημερολόγιο & Εορτολόγιο - GReortes v.3.3",Xx,Yy,-1);
initwindow (1280,h);
win_count = 1 ;
sdlbgifast();
win_id=getcurrentwindow();
winid4 = win_id ;
winwho = 1 ;
sdlwin1 = SDL_GetWindowID(bgi_window);
pran=sdlwin1 ;
getviewsettings (info_p);
memcpy (info_p4 , info_p , size_info);

//setblendmode (SDL_BLENDMODE_BLEND);

gkribkxr[0]=159 ; gkribkxr[1]= 155; gkribkxr[2]=116;
qcls(gkribkxr[0],gkribkxr[1],gkribkxr[2]);
blackchxr[0]=blackchxr[1]=blackchxr[2]=0;


// Προπαρασκευές !!!
// fonts

for (f=0 ; f<ttf ; f++) {
    
    mem_Font[f] = pro_pedabafont (f , font_filename[f]) ;
    if (mem_Font[f]==NULL) printf ("Problem loading font file : %s\n", font_filename[f]);
}

mx=0;
for (f=0 ; f<ttf ; f++) {
    if (mem_Font[f]==NULL) { mx=1; break;}
}


if (mx) { goto gamidia; }
mx=0;
proinput();
sfalma=sfalmata(); 
if(sfalma==NULL) goto gamidia;


// ΑΝΑΓΝΩΣΗ ΕΛΛΗΝΙΚΩΝ UNICODES //
sprintf(file_1,"%s%s",path_name,"GrUni.txt");

fp=fopen(file_1,"r");
for(f=0;f<69;f++) {
    fread(&ch,1,1,fp);
    fread(&cha,1,1,fp);
    unico[f][0]=(ch*256)+cha;
    unico[f][1]=95+f;}
if (ferror(fp)) {clearerr(fp); fclose(fp); perror ("Disk I/O Problem ");}  
else fclose(fp);  fp=NULL;


//create_colfiles (); // ΜΟΝΟ ΜΙΑ ΦΟΡΑ ΤΡΕΧΕΙ ΑΥΤΟ - DHMIOYRGEI TO ARXEIO DOMVN XRVMATVN !!!


//*******************************************************************************************************
//bmptodisk_new("/home/fanisatt/CMAKE2/dates_sort.bmp",5578,34,40);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Left_17.bmp",2858,40,17);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Save_25.bmp",2638,25,25);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Load_25.bmp",2638,25,25);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/save_alert.bmp",325387,90,90);
//M E T A F O R A BMP EIKONAS STO DISKO SE MORFH ico ??
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Pedia_en.bmp",1167458 ,758,385);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/Yes_Key.bmp",3738 ,30,30);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/No_Key.bmp",3738 ,30,30);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/rinks_26.bmp",3502 ,29,29);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/seardb.bmp",2730 ,36,18);
// bmptodisk_new("/home/fanisatt/CMAKE/ICONS/sm_DB.bmp",2082 ,27,18);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/card_left.bmp",1650  ,21,18);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/card_right.bmp",1650  ,21,18);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/arrows_18.bmp",1434 ,18,18);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Colors_17.bmp",2178,30,17);
// bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Fonter_17.bmp",1294,17,17);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/pedaba_db2.bmp",654858,480,341);
//mem1=icontomem("/home/fanisatt/CMAKE/ICONS/upload_database_21015.ico",255);
//puticon(300,300,mem1,255);
// inkualizer (chxr , bkxr , slxr);
//readimagefile ("/home/fanisatt/CMAKE/ICONS/paste.bmp",100,100,0,0);
//information(1,"Για να δούμε πόσο μαλάκας είσαι...",NULL);
//gouv = myfont[0];
//metr=num_input(str, x, y, x1, y1, 27,3);
//big_d= convert_str(metr , str);
//sprintf (str, "Πρόσθεση %f + 100.34 = %f ! - Long int Size = %d " , big_d, big_d+100.34,sizeof(long int) );
//outnoto (100,300,str,1) ;
//areacls(300,300,600,326,bkxr[0],bkxr[1],bkxr[2]);
//x=300 ; y=300 ; x1=600; y1=326;
//gouv = myfont[1];
//metr=text_input(str, x, y, x1, y1, 40);
//getch();

// KLHSH THS INPUT
      //  gouv=myfont[1];
      //  metr=input(str, &x, &y, &x1, &y1, 3000);
      //  while (metr==-10) metr=input(str, &x, &y, &x1, &y1, 3000);
      
gouv=myfont[1];
redchxr[0]=orangechxr[0]=255; redchxr[1]=redchxr[2]=greenchxr[0]=greenchxr[2]=0;
greenchxr[1]=255; orangechxr[1]=160;orangechxr[2]=122;


if (keyb_gr) strcpy (missing , "Το αρχείο λείπει!");
else strcpy (missing , "Missing File!");
normtext_tomy(missing,0);

//ch3=255;
//gen_ergo=&ch3;

if (keyb_gr) {strcpy(str1024,"Από τον Φ. Αττάρδ");
    normtext_tomy(str1024,0);
    _outmystr_col(notosans_12n,str1024,info.right-143,info.bottom-16,info.right-1,blackchxr,gkribkxr);}
else {strcpy(str1024,"By F.Attard");
    normtext_tomy(str1024,0);
    _outmystr_col(notosans_12n,str1024,info.right-85,info.bottom-16,info.right-1,blackchxr,gkribkxr);}



EVENT_HANDLER :

    strcpy (submenu[0],"ΑΝΤΙΓΡΑΦΗ στοιχείων ημέρας στον Clipboard");
    strcpy (submenu[1],"Αναζήτηση ονόματος (ελεύθερη)");
    strcpy (submenu[2],"Δείτε Ονόματα - Αναζητείστε (Α-Μ)");
    strcpy (submenu[3],"Δείτε Ονόματα - Αναζητείστε (Ν-Ω)");
    strcpy (submenu_1[4],"Eορτολόγιο ");
    strcpy (submenu[5],"Αναζήτηση εορτής (ελεύθερη)");
    strcpy (submenu_1[6],"Χριστούγεννα ");
    strcpy (submenu_1[7],"Πάσχα ");
    strcpy (submenu_1[8],"Γιορτή Μητέρας ");
    strcpy (submenu_1[9],"Γιορτή Πατέρα ");
    strcpy (submenu[10],"Παγκόσμιες-Διεθνείς (και άλλες) Ημέρες");
    strcpy (submenu[11],"Πάγιες/Ετήσιες Υπομνήσεις");
    strcpy (submenu[12],"Προσθήκη Πάγιας/Ετήσιας Υπόμνησης");
    strcpy (submenu[13],"Άνοιξε / Κλείσε Σημειωματάριο");
    strcpy (submenu_1[14],"Μηνιαία Αναφορά ");
    strcpy (submenu_1[15] , "Πίνακας Έτους ");
    strcpy (submenu[17] , "Προσθήκη Περιοδικής Υπόμνησης");
    strcpy (submenu[16] , "Περιοδικές Υπομνήσεις");
    strcpy (submenu_1[18],"Καταχώρηση Ημερολογίου ");
    strcpy (submenu_1[19],"Αναζήτηση Ημερολογίου ");
    strcpy (submenu[20],"Έξοδος από την Εφαρμογή");
    
    
    strcpy (omonth[1],"Ιαν."); strcpy (omonth[2],"Φεβ."); strcpy (omonth[3],"Μαρ."); strcpy (omonth[4],"Απρ.");
    strcpy (omonth[5],"Μάι."); strcpy (omonth[6],"Ιούν."); strcpy (omonth[7],"Ιούλ."); strcpy (omonth[8],"Αύγ.");
    strcpy (omonth[9],"Σεπ."); strcpy (omonth[10],"Οκτ."); strcpy (omonth[11],"Νοε."); strcpy (omonth[12],"Δεκ.");


// Είναι για τις σημειώσεις

notes_str[0]=255;
diary_notes[0] = 255 ;
// sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS/NotesBox.dat");
sprintf(str1kb,"%s.EORT_SETTINGS/draftnotes.dat",user_path);
if (!access(str1kb, F_OK )) {
// Δοκιμάζω αν υπάρχουν και αν διαβάζονται οι σημειώσεις στο φάκελο SETTINGS
    fp=fopen(str1kb,"rb");
    if (fp!=NULL) {
        i=0;
        fread (&what,1,1,fp);
        do {
            if (what<164 || what==200) {notes_str[i++]=what ;}
            fread(&what,1,1,fp);
        }while (what!=255 && i<60000);
        notes_str[i]=255;
        fclose(fp);
    }
    else {
        printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
        information (0,"Προτείνεται ο έλεγχος του δίσκου!!",0);
        notes_str[0]=notes_str[1]=255;
        fp=fopen(str1kb,"wb");
        fide_fp=fileno(fp);
        fwrite (notes_str,2,1,fp);
        fdatasync(fide_fp);
        fsync(fide_fp);
        fclose(fp);
        strcpy (notes_str,"Σημειώσεις...");
        normtext_tomy (notes_str,0);
    }
}
else {
    // Μήπως υπάρχουν σημειώσεις έξω από τον Settings ?
    sprintf(file_1,"%sdraftnotes.dat",user_path);
    fp=fopen(file_1,"rb");
    if (fp!=NULL) {
        // Είναι έξω από SETTINGS
        i=0;
        fread (&what,1,1,fp);
        do {
            if (what<164 || what==200) {notes_str[i++]=what ;}
            fread(&what,1,1,fp);
        }while (what!=255 && i<60000);
        notes_str[i]=255;
        fclose(fp);
        
        // Θα Μεταφέρω στη νέα θέση τώρα !
        
        fp=fopen(str1kb,"wb");
        if (fp!=NULL) {
            fide_fp = fileno (fp) ;
            i=0;
            while (notes_str[i]!=255 && i<60000) i++;
            notes_str[i]=255;
            if (i) {fwrite (notes_str,1,i+1,fp);}
            else {notes_str[1]=255; fwrite (notes_str,2,1,fp); }
            fdatasync (fide_fp);
            fsync(fide_fp);
            fclose(fp);
            fp=NULL;
        }
        else {
        information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου !!");
        }
    }
    else {
        // Δεν βρέθηκαν πουθενά σημειώσεις οπότε αρχικοποιώ ...
        notes_str[0]=notes_str[1]=255;
        fp=fopen(str1kb,"wb");
        if (fp!=NULL) {
            fide_fp=fileno(fp);
            fwrite (notes_str,2,1,fp);
            fdatasync (fide_fp);
            fsync(fide_fp);
            fclose(fp);
            
        }
        else {printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");}
        strcpy (notes_str,"Σημειώσεις...");
        normtext_tomy (notes_str,0);
    }

}
// Είναι για τις προσωπικές επετείους
// sprintf(str1kb,"%s%s",user_path,".EORT_SETTINGS/NotesBox.dat");
sprintf (str1kb,"%s%s",user_path,".EORT_SETTINGS/UserToDo.dat");
if (!access(str1kb, F_OK )) {
// Δοκιμάζω αν υπάρχουν και αν διαβάζονται οι προσωπικές ετήσιες υπομνήσεις στο φάκελο SETTINGS
    fp=fopen(str1kb,"rb");
    if (fp!=NULL) {
        fread(&ar_per,2,1,fp);
        if (ar_per) {
        f=sizeof (struct myepet) ;
        fread (pers,f,ar_per,fp);
        if (ferror(fp)) {information (6-keyb_gr,str1kb,0);clearerr(fp) ; ar_per=0;}
        }
    fclose(fp);
    }
    else {
        // Αφού κάτι δεν πήγε καλά...Μηδενίζω - ξαναγράφω
    information (0,"Δεν άνοιξε σωστά το αρχείο πάγιων υπομνήσεων!","Θα γίνει αρχικοποίηση ..");
    ar_per=0 ;
    fp=fopen(str1kb,"wb");
    fide_fp=fileno(fp);
    fwrite (&ar_per,2,1,fp);
    fdatasync (fide_fp);
    fsync(fide_fp);
    fclose(fp);
    }
}
else {
        
    auto unsigned short int szpet;
   
    // Δεν ήταν στο φάκελο SETTINGS,  οπότε ...
    sprintf (file_1,"%s%s",user_path,"UserToDo.dat");
    
    fp=fopen(file_1,"rb");
    if (fp!=NULL) {
        // Βρέθηκε το παλαιό αρχείο υπομνήσεων στο /home/user και άνοιξε κανονικά....
        
        fread(&ar_per,2,1,fp);
        
        if (ar_per) {
            
            auto struct oldmyepet {
            short int mob ; // 0 - 3 (σταθερή - κινητή - μητέρα - πατέρας)
            short int arkin;
            short int when;
            unsigned short int year ;
            unsigned char tex[70];
            unsigned char ktex[70];
            } clev[ar_per] ;
        
            szpet = sizeof (struct oldmyepet) ;
            
            fread (clev,szpet,ar_per,fp);
            if (ferror(fp)) {information (6-keyb_gr,file_1,0);clearerr(fp) ; ar_per=0;}
        
        
        fclose(fp);
        
        // Τοποθετώ στον SETTINGS
        
        fp=fopen(str1kb,"wb");
        if (fp!=NULL) {
            fide_fp = fileno (fp) ;
            fwrite(&ar_per,2,1,fp);
            fdatasync (fide_fp);
                
            for (f=0 ; f<ar_per; f++) { 
                pers[f].mob = clev[f].mob;
                pers[f].arkin = clev[f].arkin;
                pers[f].when = clev[f].when;
                pers[f].year = clev[f].year;
                for (i=0;i<70;i++) {
                    pers[f].tex[i] = clev[f].tex[i];
                    pers[f].ktex[i] = clev[f].ktex[i];
                }
                pers[f].alarm = 0 ;
            }
            szpet=sizeof (struct myepet) ;
            fwrite (pers,szpet,ar_per,fp);
            fdatasync (fide_fp);
            i=fsync (fide_fp);
            if (ferror(fp) || (i) ) { information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");clearerr(fp) ; }
            fclose(fp);
        }
        else  {
            information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
            printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
            goto gamidia;
        }
    }
    else {
        // ar_per παλιού αρχείου = 0 !!
        fclose (fp);
        fp=fopen(str1kb,"wb");
        if (fp!=NULL) {
            fide_fp = fileno (fp) ;
            fwrite(&ar_per,2,1,fp);
            fdatasync (fide_fp);
            i=fsync (fide_fp);
            if (ferror(fp) || (i) ) { information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");clearerr(fp) ; }
            fclose(fp);
            }
        else {
            information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
            printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
            }
        }
    }
        else { 
                    // ΑΡΧΙΚΟΠΟΙΩ ΑΡΧΕΙΟ ΥΠΟΜΝΗΣΕΩΝ
            ar_per=0 ;
            fp=fopen(str1kb,"wb");
            if (fp!=NULL) {
                fide_fp=fileno(fp);
                fwrite (&ar_per,2,1,fp);
                fdatasync (fide_fp);
                fsync(fide_fp);
                fclose(fp);
                }
                else {
                    information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
                    printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
                }
            }
    }
    
    
// Ενέργειες για τις επαναλαμβανόμενες προσωπικές υπομνήσεις

sprintf (str1kb,"%s%s",user_path,".EORT_SETTINGS/Recursing.dat");

if (!access(str1kb, F_OK )) { // Βρέθηκε το αρχείο
// Δοκιμάζω αν διαβάζονται οι recursing υπομνήσεις στο φάκελο .EORT_SETTINGS
    fp=fopen(str1kb,"rb");
    if (fp!=NULL) { // Άνοιξε το αρχείο κανονικά
        fread(&ar_clue,2,1,fp);
        if (ar_clue) {
        f=sizeof (struct RECURRENT) ;
        fread (rcr,f,ar_clue,fp);
        if (ferror(fp)) {information (6-keyb_gr,str1kb,0);clearerr(fp) ; ar_clue=0;}
        }
    fclose(fp);
    }
    else { // Το αρχείο βρέθηκε μεν - ΔΕΝ άνοιξε κανονικά όμως
        // Αφού κάτι δεν πήγε καλά...Μηδενίζω - ξαναγράφω
        information (0,"Πρόβλημα στο αρχείο περιοδ. υπομνήσεων!","Θα γίνει αρχικοποίηση ..");
        ar_clue=0 ;
        fp=fopen(str1kb,"wb");
        fide_fp=fileno(fp);
        fwrite (&ar_clue,2,1,fp);
        fdatasync (fide_fp);
        fsync(fide_fp);
        fclose(fp);
    }
}
else {
 
    // ΔEN βρέθηκε το αρχείο οπότε αρχικοποιώ !

    ar_clue = 0 ;
    fp=fopen(str1kb,"wb");
    if (fp==NULL) {
        information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
        printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
    }
    else {
        fide_fp=fileno(fp);
        fwrite (&ar_clue,2,1,fp);
        fdatasync (fide_fp);
        fsync(fide_fp);
        fclose(fp);
    }
}
/*
notes_font = notosans_20n;
eortes_font =  bookman_20n ;
names_font = neohell_24n ;
ponom_font = notosans_18n ;
eortologio_font = notosans_18n ;
pagkosm_font = bookman_20n; 
personal_font = notosans_18n;
mobeort_font = neohell_24n ;
*/
    f = 0;
    sprintf (str1kb,"%s%s",user_path,".EORT_SETTINGS/UserFonts.dat");
    if (!access(str1kb, F_OK )) { 
        fp=fopen(str1kb,"rb");
        if (fp!=NULL) {
            fread(&notes_font,4,1,fp);
            fread(&eortes_font,4,1,fp);
            fread(&names_font,4,1,fp);
            fread(&ponom_font,4,1,fp);
            fread(&eortologio_font,4,1,fp);
            fread(&pagkosm_font,4,1,fp);
            fread(&personal_font,4,1,fp);
            fread(&mobeort_font,4,1,fp);
            if ( ferror(fp) ) { information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!"); clearerr(fp) ; f=1 ; }
            fclose (fp) ;
        }
        else {
            f=1;
            printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
            information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
        }
    }
    else {
        fp=fopen(str1kb,"wb");
        if (fp!=NULL) {
            fide_fp=fileno(fp);
            notes_font = notosans_20n;
            eortes_font =  bookman_20n ;
            names_font = neohell_24n ;
            ponom_font = notosans_18n ;
            eortologio_font = notosans_18n ;
            pagkosm_font = bookman_20n; 
            personal_font = notosans_18n;
            mobeort_font = neohell_24n ;
            fwrite(&notes_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&eortes_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&names_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&ponom_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&eortologio_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&pagkosm_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&personal_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&mobeort_font,4,1,fp);
            fdatasync (fide_fp);
            fsync (fide_fp);
            fclose (fp);
        }
        else {
            f=1;
            information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
            printf ("Προτείνεται ο έλεγχος του δίσκου..!!\n");
        }
    }
    
if (f) {
    notes_font = notosans_20n;
    eortes_font =  bookman_20n ;
    names_font = neohell_24n ;
    ponom_font = notosans_18n ;
    eortologio_font = notosans_18n ;
    pagkosm_font = bookman_20n; 
    personal_font = notosans_18n;
    mobeort_font = neohell_24n ;
}
    
normdeigma[0]=255;
i=info_dbfnt();
if (!i) {information (2-keyb_gr,0,0); goto gamidia;}
if (keyb_gr) sprintf(str1024,"Επιλέξατε Γραμματοσειρά");
else sprintf(str1024,"Choose Character Font");
normtext_tomy(str1024 , dbfnt.fn_name);

//Μηδενίζω δείκτες μνήμης των 10 buttons  - ορίζω όριο=50 - μηδενίζω σημαία sorting!
for (f=0;f<10;f++) { dbbut[f].mem_butt=0; dbbut[f].butt_sorton=0; dbbut[f].butt_orio=50;}


// DIAGRAFH META


                                                        // E V E N T    HANDLER !
 // ΠΡΟΕΤΟΙΜΑΣΙΕΣ ΕΟΡΤΟΛΟΓΙΟΥ (ΑΠΟ EXCEL)

/*

//DIABASMA arxeivn excel seortes kai seortes_dates.dat
strcpy (file_1,path_name);
strcat (file_1,"ex_seortes.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_seo ; i++) {
    f=0;
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    while (what!=200) {
        seort[i][f++]=what;
        fread(&what,1,1,fp);
    }
    seort[i][f]=255;
}
rewind (fp) ; fclose (fp) ;


strcpy (file_1,path_name);
strcat (file_1,"ex_seortes_dates.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_seo ; i++) {
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    ssee[i].dm[0]=(what-16)*10;
    fread(&what,1,1,fp);
    ssee[i].dm[0]+=(what-16);
    fseek(fp,1,SEEK_CUR);
    fread(&what,1,1,fp);
    ssee[i].dm[1]=(what-16)*10;
    fread(&what,1,1,fp);
    ssee[i].dm[1]+=(what-16);
    fread(&what,1,1,fp);
    while (what!=200) fread(&what,1,1,fp);
}
rewind (fp) ; fclose (fp) ;

 
//DIABASMA arxeivn excel keortes kai keortes_dates.dat
strcpy (file_1,path_name);
strcat (file_1,"ex_keortes.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_keo ; i++) {
    f=0;
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    while (what!=200) {
        keort[i][f++]=what;
        fread(&what,1,1,fp);
    }
    keort[i][f]=255;
}
rewind (fp) ; fclose (fp) ;

strcpy (file_1,path_name);
strcat (file_1,"ex_keortes_dates.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<38 ; i++) {
    fread(&what,1,1,fp);
    sinplin=(what-16)  ?  -1 : 1;
    fread(&what,1,1,fp);
    an_pasx[i]=(what-16)*10;
    fread(&what,1,1,fp);
    an_pasx[i]+=(what-16);
    an_pasx[i]*=sinplin;
    fread(&what,1,1,fp);
    ksee[i].tog=an_pasx[i];
    while (what!=200) fread(&what,1,1,fp);
}

for(i=38;i<ar_keo;i++) {
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    ksee[i].dm[0]=(what-16)*10;
    fread(&what,1,1,fp);
    ksee[i].dm[0]+=(what-16);
    fseek(fp,1,SEEK_CUR);
    fread(&what,1,1,fp);
    ksee[i].dm[1]=(what-16)*10;
    fread(&what,1,1,fp);
    ksee[i].dm[1]+=(what-16);
    fread(&what,1,1,fp);
    while (what!=200) fread(&what,1,1,fp);
}

rewind (fp) ; fclose (fp) ;



// ΕΓΓΡΑΦΗ ΠΙΝΑΚΩΝ seort και ssee
strcpy (file_1,path_name);
strcat (file_1,"PIN_SEORTES.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (seort,70,ar_seo,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);


strcpy (file_1,path_name);
strcat (file_1,"PIN_SSEE.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (ssee,2,ar_seo,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);


// ΕΓΓΡΑΦΗ ΠΙΝΑΚΩΝ keort και ksee
strcpy (file_1,path_name);
strcat (file_1,"PIN_KEORTES.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (keort,70,ar_keo,fp);
fsync(fide_fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PIN_KSEE.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (ksee,2,ar_keo,fp);
fsync(fide_fp);
fclose(fp);


//DIABASMA arxeivn excel ex_sonoma kai ex_santist.dat
strcpy (file_1,path_name);
strcat (file_1,"ex_sonoma.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_son ; i++) {
    f=0;
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    while (what!=200) {
        sonoma[i][f++]=what;
        fread(&what,1,1,fp);
    }
    sonoma[i][f]=255;
}
rewind (fp) ; fclose (fp) ;

strcpy (file_1,path_name);
strcat (file_1,"ex_santist.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_son ; i++) {
    fseek(fp,1,SEEK_CUR);
    fread(&what,1,1,fp);
    santist[i]=(what-16)*100;
    fread(&what,1,1,fp);
    santist[i]+=(what-16)*10;
    fread(&what,1,1,fp);
    santist[i]+=(what-16);
    santist[i]--;
    fread(&what,1,1,fp);
    while (what!=200) fread(&what,1,1,fp);
    if (feof(fp)) break ;
}
rewind (fp) ; fclose (fp) ;


//DIABASMA arxeivn excel ex_konoma kai ex_kantist.dat
strcpy (file_1,path_name);
strcat (file_1,"ex_konoma.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_kon ; i++) {
    f=0;
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    while (what!=200) {
        konoma[i][f++]=what;
        fread(&what,1,1,fp);
    }
    konoma[i][f]=255;
}
rewind (fp) ; fclose (fp) ;

strcpy (file_1,path_name);
strcat (file_1,"ex_kantist.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_kon ; i++) {
    
    fread(&what,1,1,fp);
    kantist[i]=(what-16)*10;
    fread(&what,1,1,fp);
    kantist[i]+=(what-16);
    kantist[i]--;
    fread(&what,1,1,fp);
    while (what!=200) fread(&what,1,1,fp);
    if (feof(fp)) break ;
}
rewind (fp) ; fclose (fp) ;



// ΕΓΓΡΑΦΗ ΠΙΝΑΚΩΝ PIN_SONOMA και PIN_SANTIST
strcpy (file_1,path_name);
strcat (file_1,"PIN_SONOMA.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (sonoma,20,ar_son,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PIN_SANTIST.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (santist,2,ar_son,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);



// ΕΓΓΡΑΦΗ ΠΙΝΑΚΩΝ PIN_KONOMA και PIN_KANTIST
strcpy (file_1,path_name);
strcat (file_1,"PIN_KONOMA.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (konoma,20,ar_kon,fp);
fsync(fide_fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PIN_KANTIST.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (kantist,2,ar_kon,fp);
fsync(fide_fp);
fclose(fp);



// PROETOIMASIA EGGRAFHS EIDIKOY PINAKA PIN_SONOMA_A

for (f=0;f<ar_son;f++) {
    mystrcpy(sonoma_a[f],sonoma[f]) ;
    i=0;
    while (sonoma_a[f][i]!=255) i++;
    by=i; //strlen (sonoma_a[f])

    for (i=0;i<by;i++) {
        
            switch (sonoma_a[f][i]) {

                case 96:
                case 131:
                case 132:
                sonoma_a[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                sonoma_a[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                sonoma_a[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                sonoma_a[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                sonoma_a[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                sonoma_a[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                sonoma_a[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                sonoma_a[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                sonoma_a[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                sonoma_a[f][i]=128;
                break;

                case 130:
                sonoma_a[f][i]=119;
            }
        
        if ( (sonoma_a[f][i]>68) && (sonoma_a[f][i]<95) ) sonoma_a[f][i]-=26;
    }
    
}

// ΕΓΓΡΑΦΗ EIDKOY ΠΙΝΑΚA PIN_SONOMA_AT
strcpy (file_1,path_name);
strcat (file_1,"PIN_SONOMA_AT.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (sonoma_a,20,ar_son,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);



// PROETOIMASIA EGGRAFHS EIDIKOY PINAKA PIN_KONOMA_AT

for (f=0;f<ar_kon;f++) {
    mystrcpy(konoma_a[f],konoma[f]) ;
    i=0;
    while (konoma_a[f][i]!=255) i++;
    by=i; //strlen (konoma_a[f])

    for (i=0;i<by;i++) {
        
            switch (konoma_a[f][i]) {

                case 96:
                case 131:
                case 132:
                konoma_a[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                konoma_a[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                konoma_a[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                konoma_a[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                konoma_a[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                konoma_a[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                konoma_a[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                konoma_a[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                konoma_a[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                konoma_a[f][i]=128;
                break;

                case 130:
                konoma_a[f][i]=119;
            }
        
        if ( (konoma_a[f][i]>68) && (konoma_a[f][i]<95) ) konoma_a[f][i]-=26;
    }
    
}



// ΕΓΓΡΑΦΗ EIDKOY ΠΙΝΑΚA PIN_SONOMA_AT
strcpy (file_1,path_name);
strcat (file_1,"PIN_SONOMA_AT.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (sonoma_a,20,ar_son,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);


// ΕΓΓΡΑΦΗ EIDKOY ΠΙΝΑΚA PIN_KONOMA_AT
strcpy (file_1,path_name);
strcat (file_1,"PIN_KONOMA_AT.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (konoma_a,20,ar_kon,fp);
fsync(fide_fp);
fclose(fp);


//DIABASMA arxeivn excel ex_seort_sonoma kai ex_seort_aa.dat
strcpy (file_1,path_name);
strcat (file_1,"ex_seort_sonoma.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_son ; i++) {
    f=0;
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    while (what!=200) {
        ase_sonoma[i][f++]=what;
        fread(&what,1,1,fp);
    }
    ase_sonoma[i][f]=255;
}
rewind (fp) ; fclose (fp) ;

strcpy (file_1,path_name);
strcat (file_1,"ex_seort_aa.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_son ; i++) {
    fseek(fp,1,SEEK_CUR);
    fread(&what,1,1,fp);
    ase_aa[i]=(what-16)*100;
    fread(&what,1,1,fp);
    ase_aa[i]+=(what-16)*10;
    fread(&what,1,1,fp);
    ase_aa[i]+=(what-16);
    ase_aa[i]--;
    fread(&what,1,1,fp);
    while (what!=200) fread(&what,1,1,fp);
    if (feof(fp)) break ;
}
rewind (fp) ; fclose (fp) ;


//DIABASMA arxeivn excel ex_keort_konoma kai ex_keort_aa.dat
strcpy (file_1,path_name);
strcat (file_1,"ex_keort_konoma.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_kon ; i++) {
    f=0;
    fread(&what,1,1,fp);
    if (feof(fp)) break ;
    while (what!=200) {
        ake_konoma[i][f++]=what;
        fread(&what,1,1,fp);
    }
    ake_konoma[i][f]=255;
}
rewind (fp) ; fclose (fp) ;

strcpy (file_1,path_name);
strcat (file_1,"ex_keort_aa.dat");
fp=fopen(file_1,"rb");
for (i=0 ; i<ar_kon ; i++) {
    
    fread(&what,1,1,fp);
    ake_aa[i]=(what-16)*10;
    fread(&what,1,1,fp);
    ake_aa[i]+=(what-16);
    ake_aa[i]--;
    fread(&what,1,1,fp);
    while (what!=200) fread(&what,1,1,fp);
    if (feof(fp)) break ;
}
rewind (fp) ; fclose (fp) ;


// ΕΓΓΡΑΦΗ ΠΙΝΑΚΩΝ PIN_SEORT_SONOMA kai PIN_SEORT_AA.dat
strcpy (file_1,path_name);
strcat (file_1,"PIN_SEORT_SONOMA.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (ase_sonoma,20,ar_son,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PIN_SEORT_AA.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (ase_aa,2,ar_son,fp);
fdatasync(fide_fp);
fsync(fide_fp);
fclose(fp);


// ΕΓΓΡΑΦΗ ΠΙΝΑΚΩΝ PIN_KEORT_KONOMA και PIN_KEORT_AA
strcpy (file_1,path_name);
strcat (file_1,"PIN_KEORT_KONOMA.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (ake_konoma,20,ar_kon,fp);
fsync(fide_fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PIN_KEORT_AA.dat");
fp=fopen(file_1,"wb");
fide_fp=fileno(fp);
fwrite (ake_aa,2,ar_kon,fp);
fsync(fide_fp);
fclose(fp);

*/


PROKAN :

// ΔΙΑΒΑΣΜΑ ΠΙΝΑΚΩΝ seort και ssee
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_SEORTES.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (seort,70,ar_seo,fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_SSEE.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (ssee,2,ar_seo,fp);
fclose(fp);

// ΔΙΑΒΑΣΜΑ ΠΙΝΑΚΩΝ keort και ksee
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_KEORTES.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (keort,70,ar_keo,fp);
fclose(fp);

mytext_tonorm (keort[12],str1kb,70);
strcat(str1kb," (Kυρ. Σταυροπροσκηνύσεως)");
normtext_tomy (str1kb,keort[12]);

strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_KSEE.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (ksee,2,ar_keo,fp);
fclose(fp);

for (f=0;f<38;f++) {an_pasx[f]=ksee[f].tog;}

// DIABASMA ΠΙΝΑΚΩΝ PIN_SONOMA και PIN_SANTIST
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_SONOMA.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (sonoma,20,ar_son,fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_SANTIST.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (santist,2,ar_son,fp);
fclose(fp);

// DIABASMA EIDIKOY ΠΙΝΑΚA PIN_SONOMA_AT
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_SONOMA_AT.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (sonoma_a,20,ar_son,fp);
fclose(fp);

// DIABASMA ΠΙΝΑΚΩΝ PIN_KONOMA και PIN_KANTIST
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_KONOMA.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (konoma,20,ar_kon,fp);
fclose(fp);


strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_KANTIST.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (kantist,2,ar_kon,fp);
fclose(fp);

// DIABASMA EIDIKOY ΠΙΝΑΚA PIN_SONOMA_AT
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_KONOMA_AT.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (konoma_a,20,ar_kon,fp);
fclose(fp);


// ΔΙΑΒΑΣΜΑ ΠΙΝΑΚΩΝ PIN_SEORT_SONOMA kai PIN_SEORT_AA.dat
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_SEORT_SONOMA.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (ase_sonoma,20,ar_son,fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_SEORT_AA.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (ase_aa,2,ar_son,fp);
fclose(fp);

// DIABASMA ΠΙΝΑΚΩΝ PIN_KEORT_KONOMA και PIN_KEORT_AA
strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_KEORT_KONOMA.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (ake_konoma,20,ar_kon,fp);
fclose(fp);

strcpy (file_1,path_name);
strcat (file_1,"PINS/PIN_KEORT_AA.dat");
fp=fopen(file_1,"rb");
if(fp==NULL) {information(6-keyb_gr,file_1,NULL); goto gamidia;}
fread (ake_aa,2,ar_kon,fp);
fclose(fp);

//DOKIMOYLA
// Παγκόσμιες Ημέρες
// ΙΑΝΟΥΑΡΙΟΣ

f=0;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ειρήνης");
gsee.dm[0]=1; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Κοινού Κτήματος");
gsee.dm[0]=1; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Γραφής-Κώδικα Μπράιγ");
gsee.dm[0]=4; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αγκαλιάς");
gsee.dm[0]=21; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Εκπαίδευση ");
gsee.dm[0]=24; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα των Τελωνείων");
gsee.dm[0]=26; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μνήμης για τα Θύματα του Ολοκαυτώματος");
gsee.dm[0]=27; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog;f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Προστασίας των Προσωπικών Δεδομένων");
gsee.dm[0]=28; gsee.dm[1]=1;
pagk_dm[f]=gsee.tog; f++;


// Φεβρουάριος

strcpy (pagk[f], "Παγκόσμια Ημέρα Υγροτόπων");
gsee.dm[0]=2; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ανθρώπινης αδελφοσύνης");
gsee.dm[0]=4; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Καρκίνου");
gsee.dm[0]=4; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ασφαλούς Πλοήγησης στο Διαδίκτυο*");
gsee.dm[0]=5; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Κλειτοριδεκτομής");
gsee.dm[0]=6; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ελληνικής Γλώσσας");
gsee.dm[0]=9; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα μνήμης του Εθνικού μας ποιητή, Διονύσιου Σολωμού");
gsee.dm[0]=9; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Οσπρίων");
gsee.dm[0]=10; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα του 112");
gsee.dm[0]=11; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Γυναικών και Κοριτσιών στην Επιστήμη ");
gsee.dm[0]=11; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Ερυθράς Χειρός (ΟΧΙ στην στρατολόγηση παιδιών σε πολέμους)");
gsee.dm[0]=12; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Προφυλακτικού");
gsee.dm[0]=13; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Κινηματογράφου");
gsee.dm[0]=13; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ραδιοφώνου");
gsee.dm[0]=13; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Heavy Metal");
gsee.dm[0]=13; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα των Ερωτευμένων (Αγίου Βαλεντίνου)");
gsee.dm[0]=14; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Συγγενών Καρδιοπαθειών");
gsee.dm[0]=14; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαική Ημέρα Σεξουαλικής Υγείας");
gsee.dm[0]=14; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Παιδικού Καρκίνου");
gsee.dm[0]=15; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Κοινωνικής Δικαιοσύνης");
gsee.dm[0]=20; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μητρικής Γλώσσας");
gsee.dm[0]=21; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα του Ξεναγού");
gsee.dm[0]=21; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Σκέψης (Προσκοπισμού - Οδηγισμού)");
gsee.dm[0]=22; gsee.dm[1]=2;
pagk_dm[f]=gsee.tog; f++;

// Μάρτιος

strcpy (pagk[f], "Ημέρα Μηδενικών Διακρίσεων");
gsee.dm[0]=1; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Αυτοβασανισμού");
gsee.dm[0]=1; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πολιτικής Προστασίας");
gsee.dm[0]=1; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Άγριας Ζωής (Φυτών & Ζώων)");
gsee.dm[0]=3; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ακοής");
gsee.dm[0]=3; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Λογοθεραπείας");
gsee.dm[0]=6; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Δράσης των Σιδηροδρομικών*");
gsee.dm[0]=6; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Μνήμης των Δικαίων");
gsee.dm[0]=6; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του ενδοσχολικού εκφοβισμού & ενδοσχολικής βίας");
gsee.dm[0]=6; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Πανελλήνια Ημέρα κατά της Σχολικής Βίας και του Εκφοβισμού");
gsee.dm[0]=6; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα της Γυναίκας");
gsee.dm[0]=8; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης για τα θύματα της τρομοκρατίας στην Ευρώπη ");
gsee.dm[0]=11; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Λογοκρισίας στο Διαδίκτυο");
gsee.dm[0]=12; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μπριζόλας και Πεολειχίας");
gsee.dm[0]=14; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα της Σταθεράς π (3,14)");
gsee.dm[0]=14; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Καταναλωτή");
gsee.dm[0]=15; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Επαφής");
gsee.dm[0]=15; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Αστυνομικής Βαρβαρότητας");
gsee.dm[0]=15; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Κινητοποιήσεων κατά της Κατοχής του Ιράκ");
gsee.dm[0]=18; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Φροντιστή (Εταιρεία Alzheimer");
gsee.dm[0]=18; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα της Γης");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αποχής από το Κρέας");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Στοματικής Υγείας");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Αστρολογίας");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Θεάτρου για τα Παιδιά και τους Νέους");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Γαλλοφωνίας");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Σπουργιτιού");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ευτυχίας");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αφήγησης");
gsee.dm[0]=20; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Ρατσισμού");
gsee.dm[0]=21; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Χρωμάτων");
gsee.dm[0]=21; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ναβρούζ (ή Νορούζ)");
gsee.dm[0]=21; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Δασών-Δασοπονίας");
gsee.dm[0]=21; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ποίησης");
gsee.dm[0]=21; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για το Σύνδρομο Down");
gsee.dm[0]=21; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Κουκλοθεάτρου");
gsee.dm[0]=21; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Ευγένειας στους Δρόμους");
gsee.dm[0]=22; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για το Νερό");
gsee.dm[0]=22; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μετεωρολογίας");
gsee.dm[0]=23; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για το Δικαίωμα στην Αλήθεια (Παραβιάσεις Ανθρωπίνων Δικαιωμάτων)");
gsee.dm[0]=24; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Φυματίωσης");
gsee.dm[0]=24; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "ΕΘΝΙΚΗ ΕΠΕΤΕΙΟΣ της Ελληνικής Επανάστασης του 1821");
gsee.dm[0]=25; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Αλληλεγγύης για τους Κρατούμενους-Αγνοούμενους Υπαλλήλους του ΟΗΕ");
gsee.dm[0]=25; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μνήμης Θυμάτων Δουλεμπορίου");
gsee.dm[0]=25; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Ανάγνωσης Έργων του Τόλκιν");
gsee.dm[0]=25; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα του Αγέννητου Παιδιού");
gsee.dm[0]=25; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Θεάτρου");
gsee.dm[0]=27; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Κοινωνικής Εργασίας");
gsee.dm[0]=27; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Θεάτρου Σκιών");
gsee.dm[0]=28; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αντιγράφων Ασφαλείας (backup)");
gsee.dm[0]=31; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Διεμφυλικής Ορατότητας");
gsee.dm[0]=31; gsee.dm[1]=3;
pagk_dm[f]=gsee.tog; f++;

// Απρίλιος

strcpy (pagk[f], "Ημέρα Γαστρονομικού Βιβλίου");
gsee.dm[0]=1; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Παιδικού Βιβλίου");
gsee.dm[0]=2; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αυτισμού");
gsee.dm[0]=2; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αδεσπότων Ζώων");
gsee.dm[0]=4; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα κατά των Ναρκών");
gsee.dm[0]=4; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Πανελλήνια Ημέρα Προσφύγων");
gsee.dm[0]=5; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μαξιλαροπολέμου");
gsee.dm[0]=5; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Συνείδησης *");
gsee.dm[0]=5; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αθλητισμού για την Ανάπτυξη και την Ειρήνη");
gsee.dm[0]=6; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Υγείας");
gsee.dm[0]=7; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα μνήμης για την γενοκτονία στη Ρουάντα");
gsee.dm[0]=7; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα του Έθνους των Ρομά");
gsee.dm[0]=8; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ζωγράφισε Ένα Πουλί (DABDay)");
gsee.dm[0]=8; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Aσθενείας Πάρκινσον");
gsee.dm[0]=11; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Πτήσης του Ανθρώπου στο Διάστημα");
gsee.dm[0]=12; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για τα Παιδιά του Δρόμου");
gsee.dm[0]=12; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τέχνης");
gsee.dm[0]=15; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Δράσης κατά των Στρατιωτικών Δαπανών");
gsee.dm[0]=15; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Φωνής");
gsee.dm[0]=16; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αγροτικής Πάλης");
gsee.dm[0]=17; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αιμορροφιλίας");
gsee.dm[0]=17; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πολιτιστικής Κληρονομιάς");
gsee.dm[0]=18; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ραδιοερασιτεχνισμού");
gsee.dm[0]=18; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Φιλελληνισμού και Διεθνούς Αλληλεγγύης");
gsee.dm[0]=19; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Κινέζικης Γλώσσας");
gsee.dm[0]=20; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Δημιουργικότητας και Καινοτομίας");
gsee.dm[0]=21; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Γης");
gsee.dm[0]=22; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα της Μάνας Γης");
gsee.dm[0]=22; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Βιβλίου-Πνευματικών Δικαιωμάτων");
gsee.dm[0]=23; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Αγγλικής Γλώσσας");
gsee.dm[0]=23; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης Γενοκτονίας των Αρμενίων");
gsee.dm[0]=24; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Γλυπτικής");
gsee.dm[0]=24; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Κατάργησης των Πειραμάτων σε Ζώα");
gsee.dm[0]=24; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Πολυμέρεια και την Διπλωματία για την Ειρήνη");
gsee.dm[0]=24; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Ελονοσίας");
gsee.dm[0]=25; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μονίμων Αντιπροσώπων του ΟΗΕ");
gsee.dm[0]=25; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για τα Κορίτσια στις Τεχνολογίες Πληροφορίών και Επικοινωνιών");
gsee.dm[0]=25; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα του DNA");
gsee.dm[0]=25; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Γονικής Αποξένωσης");
gsee.dm[0]=25; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Διανοητικής Ιδιοκτησίας");
gsee.dm[0]=26; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μνήμης της Καταστροφής του Τσέρνομπιλ");
gsee.dm[0]=26; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Σχεδίου (Design)");
gsee.dm[0]=27; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για την Υγεία και την Ασφάλεια στην Εργασία");
gsee.dm[0]=28; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μνήμης Εργατών");
gsee.dm[0]=28; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Χορού");
gsee.dm[0]=29; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ευχής");
gsee.dm[0]=29; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης για τα Θύματα του Χημικού Πολέμου");
gsee.dm[0]=29; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ανοσολογίας");
gsee.dm[0]=29; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα για την Ενεργό Γήρανση και τη Διαγενεακή Αλληλεγγύη");
gsee.dm[0]=29; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τζαζ");
gsee.dm[0]=30; gsee.dm[1]=4;
pagk_dm[f]=gsee.tog; f++;

// Μάιος

strcpy (pagk[f], "Εργατική Πρωτομαγιά / Διεθνής Ημέρα Εργατών");
gsee.dm[0]=1; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα των Blogger");
gsee.dm[0]=2; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τόνου");
gsee.dm[0]=2; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ελευθερίας του Τύπου - Ελευθεροτυπίας");
gsee.dm[0]=3; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα του Πολέμου των Άστρων");
gsee.dm[0]=4; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Πανευρωπαϊκή Ημέρα Ανεξάρτητης Διαβίωσης");
gsee.dm[0]=5; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Μελανώματος");
gsee.dm[0]=5; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μαιών");
gsee.dm[0]=5; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα του Πορτογαλόφωνου Πολιτισμού");
gsee.dm[0]=5; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Δίαιτας");
gsee.dm[0]=6; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης και Τιμής για τους Πεσόντες της Αεροπορίας Στρατού (Ελλάδα)");
gsee.dm[0]=7; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ερυθρού Σταυρού και Ερυθράς Ημισελήνου");
gsee.dm[0]=8; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Θαλασσαιμίας (Μεσογειακής Αναιμίας)");
gsee.dm[0]=8; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ώρα Μνήμης και Συμφιλίωσης για όσους έχασαν τη ζωή τους κατά τη διάρκεια του Δευτέρου Παγκοσμίου Πολέμου");
gsee.dm[0]=8; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Ευρώπης");
gsee.dm[0]=9; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Αργκάν (φυτό Αργκάν γένους Argania)");
gsee.dm[0]=10; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Αδελφών Νοσοκόμων");
gsee.dm[0]=12; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Περιοδοντολογίας");
gsee.dm[0]=12; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Οικογένειας");
gsee.dm[0]=15; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Αντιρρησιών Συνείδησης");
gsee.dm[0]=15; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ευαισθητοποίησης για την Οζώδη Σκλήρυνση");
gsee.dm[0]=15; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την ειρηνική συμβίωση");
gsee.dm[0]=16; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Φωτός");
gsee.dm[0]=16; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Πανσελήνου του Μαΐου ή του Βούδα");
gsee.dm[0]=16; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Κοιλιοκάκης/Δυσανεξίας στη Γλουτένη");
gsee.dm[0]=16; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα κατά της Ομοφυλοφοβίας");
gsee.dm[0]=17; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τηλεπικοινωνιών και Κοινωνίας της Πληροφορίας");
gsee.dm[0]=17; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Υπέρτασης");
gsee.dm[0]=17; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μουσείων");
gsee.dm[0]=18; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ενημέρωσης για το Εμβόλιο κατά του AIDS");
gsee.dm[0]=18; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης για τη Γενοκτονία των Ελλήνων στο Μικρασιατικό Πόντο");
gsee.dm[0]=19; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Ηπατίτιδας");
gsee.dm[0]=19; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ιδιοπαθών Φλεγμονωδών Νόσων του Εντέρου");
gsee.dm[0]=19; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα μνήμης για την γενοκτονία των στην Cambodia");
gsee.dm[0]=20; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μέλισσας");
gsee.dm[0]=20; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μετρολογίας");
gsee.dm[0]=20; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα για τη Θάλασσα");
gsee.dm[0]=20; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πολιτισμού και Πολιτισμικής Διαφορετικότητας");
gsee.dm[0]=21; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πολιτιστικής Ποικιλομορφίας για τον Διάλογο και την Ανάπτυξη");
gsee.dm[0]=21; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Τσαγιού");
gsee.dm[0]=21; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Βιοποικιλότητας");
gsee.dm[0]=22; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Χελώνας");
gsee.dm[0]=23; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για τον Τερματισμό του Μαιευτικού Συρίγγιου");
gsee.dm[0]=23; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Πάρκων");
gsee.dm[0]=24; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ιχθυομετανάστευσης");
gsee.dm[0]=24; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Εξαφανισμένων Παιδιών");
gsee.dm[0]=25; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Αφρικής");
gsee.dm[0]=25; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Πετσέτας (ωτοστόπ)");
gsee.dm[0]=25; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Υπερηφάνειας των Κομπιουτεράδων");
gsee.dm[0]=25; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Κυανοκράνων");
gsee.dm[0]=29; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για την Υγεία του Πεπτικού Συστήματος");
gsee.dm[0]=29; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Καπνίσματος");
gsee.dm[0]=31; gsee.dm[1]=5;
pagk_dm[f]=gsee.tog; f++;

// Ιούνιος

strcpy (pagk[f], "Παγκόσμια Ημέρα Γονέων");
gsee.dm[0]=1; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Γάλακτος");
gsee.dm[0]=1; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ιερόδουλων");
gsee.dm[0]=2; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ποδηλάτου");
gsee.dm[0]=3; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα κατά της Επιθετικότητας εναντίον των Παιδιών");
gsee.dm[0]=4; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Περιβάλλοντος");
gsee.dm[0]=5; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την καταπολέμηση της Παράνομης, Μη Καταγγελλόμενης και μη Ρυθμιζόμενης Αλιείας");
gsee.dm[0]=5; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Ρωσικής Γλώσσας στα Ηνωμένα Έθνη");
gsee.dm[0]=6; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για την Ασφάλεια Τροφίμων");
gsee.dm[0]=7; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ωκεανών");
gsee.dm[0]=8; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά των Εγκεφαλικών Όγκων");
gsee.dm[0]=8; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Παιδικής Εργασίας");
gsee.dm[0]=12; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ενημέρωσης για τον Αλφισμό");
gsee.dm[0]=13; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ευαισθητοποίησης για τη Λευκοπάθεια");
gsee.dm[0]=13; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Σόφτμπολ");
gsee.dm[0]=13; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αιμοδοσίας - Εθελοντή Αιμοδότη");
gsee.dm[0]=14; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα των Weblogger");
gsee.dm[0]=14; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Κακομεταχείρισης των Ηλικιωμένων");
gsee.dm[0]=15; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Γονιμότητας");
gsee.dm[0]=15; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ανέμου");
gsee.dm[0]=15; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Οικογενειακών Εμβασμάτων");
gsee.dm[0]=16; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Ερημοποίησης και της Ξηρασίας");
gsee.dm[0]=17; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Βιώσιμης Γαστρονομίας");
gsee.dm[0]=18; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Εξάλειψη της Σεξουαλικής Βίας σε ‘Ενοπλες Συγκρούσεις");
gsee.dm[0]=19; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Δρεπανοκυττάρωσης");
gsee.dm[0]=19; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής ημέρα για την εξάλειψη της σεξoυαλικής βίας κατά τη διάρκεια των ενόπλων συγκρούσεων");
gsee.dm[0]=19; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Προσφύγων");
gsee.dm[0]=20; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Μουσικής");
gsee.dm[0]=21; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Υδρογραφίας");
gsee.dm[0]=21; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τροχοσανίδας (Skateboard)");
gsee.dm[0]=21; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Γιόγκα");
gsee.dm[0]=21; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Εορτασμού του Ηλιοστασίου");
gsee.dm[0]=21; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ουμανιστή (Ανθρωπιστή)");
gsee.dm[0]=21; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Υδρογραφίας");
gsee.dm[0]=21; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Σκαραβαίου");
gsee.dm[0]=22; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τροπικών Δασών");
gsee.dm[0]=22; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ολυμπιακή Ημέρα");
gsee.dm[0]=23; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα των Ηνωμένων Εθνών για τη Δημόσια Υπηρεσία");
gsee.dm[0]=23; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Χηρών");
gsee.dm[0]=23; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αδελφών");
gsee.dm[0]=25; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα των Ναυτικών (Θαλασσοπόρων)");
gsee.dm[0]=25; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα των Στρουμφ");
gsee.dm[0]=25; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά των Ναρκωτικών και της Παράνομης Διακίνησής τους");
gsee.dm[0]=26; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα κατά των Βασανιστηρίων");
gsee.dm[0]=26; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μικρομεσαίων Επιχειρήσεων");
gsee.dm[0]=27; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ομοφυλοφιλικής Υπερηφάνειας");
gsee.dm[0]=28; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Σκληροδερμίας");
gsee.dm[0]=29; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αστεροϊδών");
gsee.dm[0]=30; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Κοινοβουλευτισμού");
gsee.dm[0]=30; gsee.dm[1]=6;
pagk_dm[f]=gsee.tog; f++;

// Ιούλιος

strcpy (pagk[f], "Παγκόσμια Ημέρα ΑΤΙΑ");
gsee.dm[0]=2; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Φεστιβάλ");
gsee.dm[0]=4; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αλλεργίας");
gsee.dm[0]=8; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πληθυσμού");
gsee.dm[0]=11; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Νεανικών Δεξιοτήτων");
gsee.dm[0]=15; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Διεθνούς Δικαιοσύνης");
gsee.dm[0]=17; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Νέλσον Μαντέλα");
gsee.dm[0]=18; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα για τα Θύματα Εγκλημάτων Μίσους");
gsee.dm[0]=22; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα των Υπναράδων (Φιλανδία)");
gsee.dm[0]=27; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ηπατίτιδας");
gsee.dm[0]=28; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τίγρης");
gsee.dm[0]=29; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Φιλίας");
gsee.dm[0]=30; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Εμπορίας Ανθρώπων");
gsee.dm[0]=30; gsee.dm[1]=7;
pagk_dm[f]=gsee.tog; f++;


// Αύγουστος

strcpy (pagk[f], "Παγκόσμια Ημέρα Προσκοπικού Μαντηλιού");
gsee.dm[0]=1; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα μνήμης για την γενοκτονία των Ρομά");
gsee.dm[0]=2; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα μνήμης για την γενοκτονία των Ασσυρίων");
gsee.dm[0]=7; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Οργασμού");
gsee.dm[0]=8; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Γάτας");
gsee.dm[0]=8; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αυτοχθόνων Λαών-Ιθαγενών");
gsee.dm[0]=9; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Νεολαίας");
gsee.dm[0]=12; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα του Ελέφαντα");
gsee.dm[0]=12; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αριστερόχειρων");
gsee.dm[0]=13; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ανθρωπισμού - Ανθρωπιστικής Δράσης");
gsee.dm[0]=19; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Φωτογραφίας");
gsee.dm[0]=19; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά των Κουνουπιών");
gsee.dm[0]=20; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μνήμης και Τιμής στα Θύματα της Τρομοκρατίας");
gsee.dm[0]=21; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μνήμης των Θυμάτων Πράξεων Βίας που βασίζονται στη Θρησκεία ή την Πίστη");
gsee.dm[0]=22; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Μνήμης για τα Θύματα του Σταλινισμού και του Ναζισμού");
gsee.dm[0]=23; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για την Υπενθύμιση του Δουλεμπορίου και της Κατάργησής του");
gsee.dm[0]=23; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα κατά των Πυρηνικών Δοκιμών");
gsee.dm[0]=29; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Εξαφανισμένων");
gsee.dm[0]=30; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ατόμων με Αφρικανική Καταγωγή *");
gsee.dm[0]=31; gsee.dm[1]=8;
pagk_dm[f]=gsee.tog; f++;

// Σεπτέμβριος


strcpy (pagk[f], "Παγκόσμια Ημέρα Σεξoυαλικής Υγείας");
gsee.dm[0]=4; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Taekwondo");
gsee.dm[0]=4; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Φιλανθρωπίας");
gsee.dm[0]=5; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Καθαρoύ Αέρα και Μπλε Ουρανών");
gsee.dm[0]=7; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Εξάλειψη του Αναλφαβητισμού");
gsee.dm[0]=8; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Φυσικοθεραπείας");
gsee.dm[0]=8; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Κυστικής Ίνωσης");
gsee.dm[0]=8; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα πρόληψης/κατά της Αυτοκτονίας");
gsee.dm[0]=10; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα των Ηνωμένων Εθνών για την Συνεργασία των Χωρών του Νότου");
gsee.dm[0]=12; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Σήψης");
gsee.dm[0]=13; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Εθνικής Μνήμης της Γενοκτονίας των Ελλήνων της Μικράς Ασίας από το τουρκικό Κράτος");
gsee.dm[0]=14; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα κατά του Καρκίνου του Προστάτη");
gsee.dm[0]=15; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Εβδομάδα Κινητικότητας (16-22 Σεπ)");
gsee.dm[0]=16; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Δημοκρατίας");
gsee.dm[0]=15; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ευαισθητοποίησης για το Λέμφωμα");
gsee.dm[0]=15; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για τη Διατήρηση του στρώματος του Όζοντος");
gsee.dm[0]=16; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Εβδομάδα Ιδιοπαθούς Πνευμονικής Ίνωσης(17-25 Σεπ.)");
gsee.dm[0]=17; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ισότητας των Αμοιβών");
gsee.dm[0]=18; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ανάγνωσης Ηλεκτρονικού Βιβλίου");
gsee.dm[0]=18; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ελέγχου των Υδάτων");
gsee.dm[0]=18; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Ευρωπαϊκής Συνεργασίας");
gsee.dm[0]=21; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ειρήνης");
gsee.dm[0]=21; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αλτσχάιμερ");
gsee.dm[0]=21; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Ελληνικού Εμπορίου");
gsee.dm[0]=22; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Μετακινήσεων (Ευρωπαϊκή Ημέρα Χωρίς Αυτοκίνητο)");
gsee.dm[0]=22; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα των Χόμπιτ");
gsee.dm[0]=22; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αμφισεξουαλικότητας");
gsee.dm[0]=23; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα των Νοηματικών Γλωσσών");
gsee.dm[0]=23; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ναυτιλίας(24-30 Σεπ)");
gsee.dm[0]=24; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αντισύλληψης");
gsee.dm[0]=26; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Ολική Κατάργηση των Πυρηνικών Όπλων");
gsee.dm[0]=26; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Γλωσσών");
gsee.dm[0]=26; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αντισύλληψης");
gsee.dm[0]=26; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τουρισμού");
gsee.dm[0]=27; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Λύσσας");
gsee.dm[0]=28; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Καθολική Πρόσβαση στην Πληροφόρηση");
gsee.dm[0]=28; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ναυτική Ημέρα");
gsee.dm[0]=29; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Καρδιάς");
gsee.dm[0]=29; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ενημέρωσης για την Απώλεια και τη Σπατάλη του Φαγητού");
gsee.dm[0]=29; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης των Εθνικών μας Ευεργετών");
gsee.dm[0]=30; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μετάφρασης και Διερμηνείας");
gsee.dm[0]=30; gsee.dm[1]=9;
pagk_dm[f]=gsee.tog; f++;

// Οκτώβριος

strcpy (pagk[f], "Παγκόσμια Ημέρα Ηλικιωμένων");
gsee.dm[0]=1; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Χορτοφαγίας");
gsee.dm[0]=1; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Καφέ");
gsee.dm[0]=1; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μη Βίας");
gsee.dm[0]=2; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Δράσης της Παγκόσμιας Συνδικαλιστικής Ομοσπονδίας");
gsee.dm[0]=3; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα των Ζώων");
gsee.dm[0]=4; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Εκπαιδευτικών");
gsee.dm[0]=5; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα κατά της Πoρνείας");
gsee.dm[0]=5; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αξιοπρεπούς Εργασίας");
gsee.dm[0]=7; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Βαμβακιού");
gsee.dm[0]=7; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ταχυδρομείων");
gsee.dm[0]=9; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ψυχικής Υγείας");
gsee.dm[0]=10; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Θανατικής Ποινής");
gsee.dm[0]=10; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μικρών Κοριτσιών");
gsee.dm[0]=11; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Παχυσαρκίας");
gsee.dm[0]=11; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Ισπανικής Γλώσσας");
gsee.dm[0]=12; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Αρθρίτιδας");
gsee.dm[0]=12; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Μείωσης των Φυσικών Καταστροφών");
gsee.dm[0]=13; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Θρόμβωσης");
gsee.dm[0]=13; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Προτύπων (Τυποποίησης)");
gsee.dm[0]=14; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα της Γυναίκας της Υπαίθρου (Αγρότισσας)");
gsee.dm[0]=15; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα του Λευκού Μπαστουνιού");
gsee.dm[0]=15; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πλυσίματος Χεριών");
gsee.dm[0]=15; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Διατροφής/Επισιτισμού/Φαγητού-Τροφίμων");
gsee.dm[0]=16; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Σπονδυλικής Στήλης");
gsee.dm[0]=16; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Άρτου");
gsee.dm[0]=16; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Εξάλειψη της Φτώχειας");
gsee.dm[0]=17; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μυοσκελετικού Τραύματος");
gsee.dm[0]=17; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Γραβάτας");
gsee.dm[0]=18; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Πανευρωπαϊκή Ημέρα κατά της Εμπορίας Ανθρώπων");
gsee.dm[0]=18; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Βιοηθικής");
gsee.dm[0]=19; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Οστεοπόρωσης");
gsee.dm[0]=20; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Στατιστικής");
gsee.dm[0]=20; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ελεγκτών Εναέριας Κυκλοφορίας");
gsee.dm[0]=20; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Βιομηχανοποίησης/Εκβιομηχάνισης της Αφρικής");
gsee.dm[0]=20; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για τον Τραυλισμό");
gsee.dm[0]=22; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα του ΟΗΕ");
gsee.dm[0]=24; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πληροφόρησης για την Ανάπτυξη");
gsee.dm[0]=24; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Μεσογειακή Ημέρα Ακτών");
gsee.dm[0]=24; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Πολιομυελίτιδας");
gsee.dm[0]=24; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ζυμαρικών");
gsee.dm[0]=25; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Καρκίνου του Μαστού");
gsee.dm[0]=25; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Ευαισθητοποίησης για τα Μεσοφυλικά Άτομα");
gsee.dm[0]=26; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Πολιτικής Δικαιοσύνης");
gsee.dm[0]=25; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Εργοθεραπείας");
gsee.dm[0]=27; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Οπτικοακουστικής Κληρονομιάς");
gsee.dm[0]=27; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "ΕΘΝΙΚΗ ΕΠΕΤΕΙΟΣ ΤΟΥ ΌΧΙ (Β'ΠΠ)");
gsee.dm[0]=28; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Δωρεάς Οργάνων Σώματος και Μεταμοσχεύσεων");
gsee.dm[0]=28; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Κινουμένου Σχεδίου");
gsee.dm[0]=28; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Αγνοουμένων Κύπρου");
gsee.dm[0]=29; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ψωρίασης");
gsee.dm[0]=29; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά των Εγκεφαλικών Επεισοδίων");
gsee.dm[0]=29; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ορθοπεδικών Νοσοκόμων");
gsee.dm[0]=30; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αποταμίευσης");
gsee.dm[0]=31; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πόλεων");
gsee.dm[0]=31; gsee.dm[1]=10;
pagk_dm[f]=gsee.tog; f++;

// Νοέμβριος

strcpy (pagk[f], "19 Ημέρες Ακτιβισμού κατά της Παιδικής Κακοποίησης (1-19 Νοε.)");
gsee.dm[0]=1; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Εβδομάδα Μητρικού Θηλασμού (1 - 7 Νοε.)");
gsee.dm[0]=1; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Πανελλήνια Ημέρα Δωρεάς Οργάνων");
gsee.dm[0]=1; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αυστηράς Χορτοφαγίας (World Vegan Day)");
gsee.dm[0]=1; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για τον Τερματισμό της Ατιμωρησίας για Εγκλήματα Κατά των Δημοσιογράφων");
gsee.dm[0]=2; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ενημέρωσης για το Τσουνάμι");
gsee.dm[0]=5; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για την Παρεμπόδιση της Εκμετάλλευσης του Περιβάλλοντος στον Πόλεμο και τις Ένοπλες Συγκρούσεις");
gsee.dm[0]=6; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πολεοδομίας – Χωροταξίας");
gsee.dm[0]=8; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ακτινολογίας");
gsee.dm[0]=8; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Αλληλεγγύης Μεσοφυλικών");
gsee.dm[0]=8; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα κατά του Φασισμού και του Αντισημιτισμού");
gsee.dm[0]=9; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Επιστήμης για την Ειρήνη και την Ανάπτυξη");
gsee.dm[0]=10; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Ιδιωτικής Ασφάλισης");
gsee.dm[0]=11; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για την Πνευμονία");
gsee.dm[0]=12; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης Πεσόντων Πυροσβεστών");
gsee.dm[0]=12; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Πνευμονίας");
gsee.dm[0]=12; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Καλοσύνης");
gsee.dm[0]=13; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Καρκίνου του Παγκρέατος");
gsee.dm[0]=13; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του Διαβήτη");
gsee.dm[0]=14; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα του Φυλακισμένου Συγγραφέα");
gsee.dm[0]=15; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ανεκτικότητας");
gsee.dm[0]=16; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Επέτειος του Πολυτεχνείου (1973)");
gsee.dm[0]=17; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Τιμής στην Ελληνική Νεολαία");
gsee.dm[0]=17; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Μαύρης Γάτας (Ιταλία)");
gsee.dm[0]=17; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Σπουδαστών");
gsee.dm[0]=17; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Πρόωρου Τοκετού");
gsee.dm[0]=17; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα για την Προστασία των Παιδιών από τη Γενετήσια Εκμετάλλευση και Κακοποίηση");
gsee.dm[0]=18; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Ευαισθητοποίησης για τα Αντιβιοτικά");
gsee.dm[0]=18; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αντρών");
gsee.dm[0]=19; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα (Δημόσιας) Τουαλέτας");
gsee.dm[0]=19; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια ημέρα κατά της κακοποίησης των παιδιών");
gsee.dm[0]=19; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα για την Εκβιομηχάνιση της Αφρικής");
gsee.dm[0]=20; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για τα Δικαιώματα του Παιδιού");
gsee.dm[0]=20; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης Υπερφυλικών");
gsee.dm[0]=20; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα των Ενόπλων Δυνάμεων (Ελλάδα)");
gsee.dm[0]=21; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Τηλεόρασης");
gsee.dm[0]=21; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Χαιρετισμού");
gsee.dm[0]=21; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για τον Τερματισμό της Ατιμωρησίας");
gsee.dm[0]=23; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Πανελλαδικού Εορτασμού της Εθνικής Αντίστασης");
gsee.dm[0]=25; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα για την Εξάλειψη της Βίας κατά των Γυναικών");
gsee.dm[0]=25; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα μνήμης για την γενοκτονία των Ουκρανών");
gsee.dm[0]=25; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Θεάτρου στην Εκπαίδευση");
gsee.dm[0]=27; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Αλληλεγγύης για τον Παλαιστινιακό Λαό");
gsee.dm[0]=29; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Μνήμης για τα Θύματα του Χημικού Πολέμου");
gsee.dm[0]=30; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Πόλεων για την Ζωή");
gsee.dm[0]=30; gsee.dm[1]=11;
pagk_dm[f]=gsee.tog; f++;

// Δεκέμβριος

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά του AIDS");
gsee.dm[0]=1; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα για την Εξάλειψη της Δουλείας");
gsee.dm[0]=2; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ατόμων με Αναπηρία");
gsee.dm[0]=3; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα της Βασκικής Γλώσσας");
gsee.dm[0]=3; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Τραπεζών");
gsee.dm[0]=4; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Εθελοντισμού για την Οικονομική και Κοινωνική Ανάπτυξη");
gsee.dm[0]=5; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Εδάφους");
gsee.dm[0]=5; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Πολιτικής Αεροπορίας");
gsee.dm[0]=7; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Διαφθοράς");
gsee.dm[0]=9; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Hμέρα μνήμης των θυμάτων Γενοκτονιών και Πρόληψης του Εγκλήματος αυτού");
gsee.dm[0]=9; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ανθρωπίνων Δικαιωμάτων");
gsee.dm[0]=10; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ιδιοκτησίας");
gsee.dm[0]=10; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Βουνού");
gsee.dm[0]=11; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Ουδετερότητας");
gsee.dm[0]=12; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Καθολικής Υγειονομικής Κάλυψης");
gsee.dm[0]=12; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Αγάπης");
gsee.dm[0]=14; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Μαϊμούς");
gsee.dm[0]=14; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα Ελλήνων Πυροσβεστών");
gsee.dm[0]=17; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Παγκόσμια Ημέρα Μετανάστη");
gsee.dm[0]=18; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Ημέρα της Αραβικής Γλώσσας");
gsee.dm[0]=18; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Ανθρώπινης Αλληλεγγύης");
gsee.dm[0]=20; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

strcpy (pagk[f], "Διεθνής Ημέρα Επιδημιολογικής Ετοιμότητας(2020)");
gsee.dm[0]=27; gsee.dm[1]=12;
pagk_dm[f]=gsee.tog; f++;

// Παγκόσμιες Κινητές

nefro=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Νεφρού"); // 2η Πέμπτη Μαρτίου
f++;

gamos=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα του Γάμου");  // 2η Κυριακή Φλεβάρη
f++;

aytism=f;
strcpy (pagk[f], "Διεθνής Ημέρα Προσευχής για τους Πάσχοντες από Αυτισμό"); // 2η Κυριακή Φλεβάρη
f++;

lepra=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα κατά της Λέπρας"); // τελευταία Κυριακή του Ιανουαρίου 
f++;

epilhc=f;
strcpy (pagk[f], "Διεθνής Ημέρα κατά της Επιληψίας"); // 2η Δευτέρα Φεβρ. 
f++;

spaui=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Κατάποσης Σπαθιών"); // Τελευταίο Σάββ. Φεβρ. 
f++;

spanies=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Σπάνιων Παθήσεων"); // Τελευταία ημέρα Φεβρ. 
f++;

ebook=f;
strcpy (pagk[f], "Παγκόσμια Εβδομάδα Ψηφιακού Βιβλίου"); // 1η Κυρ. Μαρτίου 
f++;

pesontes=f;
strcpy (pagk[f], "Ημέρα Μνήμης Πεσόντων Αστυνομικών(Ελλάδα)"); // 57 ημέρες πριν το Πάσχα - Α' Ψυχοσάββατο 
f++;

sleep_1=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Ύπνου"); // Τρίτη Παρασκευή του Μαρτίου 
f++;

diskop=f;
strcpy (pagk[f], "Ημέρα του Δισκοπωλείου"); // Τρίτο Σάββατο Απριλίου 
f++;

noise=f;
strcpy (pagk[f], "Διεθνής Ημέρα κατά του Θορύβου"); // Τελευταία Τετάρτη Απριλίου
f++;

kanavi=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα για τη Νομιμοποίηση της Κάνναβης"); // 1ο Σάββατο Μαίου
f++;

gelio=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Γέλιου"); // 1η Κυριακή Μαίου
f++;

asma=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Άσθματος"); // 1η Τρίτη του Μάη
f++;

piano=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Πιάνου"); // H 88η ημέρα του χρόνου, όσα και τα πλήκτρα του πιάνου
f++;

apodhm_1=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Αποδημητικών Πτηνών"); // 2o Σαβ. Μαίου
f++;

apodhm_2=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Αποδημητικών Πτηνών"); // 2o Σαβ. Οκτ
f++;

cooperat=f ;
strcpy (pagk[f], "Παγκόσμια Ημέρα Συνεταιρισμών"); // 1o Σαβ. Ιουλίου
f++;

faros=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Φάρων"); // Τρίτη Κυριακή Αυγούστου
f++;

noe17=f;
strcpy (pagk[f], "Ημέρα Μνήμης των Θυμάτων της Εγκληματικής Δράσης της Τρομοκρατίας στην Ελλάδα"); // Τρίτη Κυριακή Ιανουαρίου
f++;

paralia=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Εθελοντικού Καθαρισμού των Ακτών"); // 3o Σάββατο Σεπτεμβρίου
f++;

katoikia=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Κατοικίας - Ανθρώπινων Οικισμών"); // 1η Δευτέρα Οκτωβρίου
f++;

arxitekt=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Αρχιτεκτονικής"); // 1η Δευτέρα Οκτωβρίου
f++;

birds=f;
strcpy (pagk[f], "Πανευρωπαϊκή Γιορτή των Πουλιών (Σ/Κ)"); // 1o Σ/Κ Οκτωβρίου
f++;

egg=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Αυγού"); // δεύτερη Παρασκευή του Οκτωβρίου
f++;

orasi=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Όρασης (Κατά της Τύφλωσης)"); // δεύτερη Πέμπτη του Οκτωβρίου
f++;

streetart=f;                      // τελευταίο Σάββατο του Οκτωβρίου
strcpy (pagk[f], "Παγκόσμια Ημέρα των Τεχνών του Δρόμου και της Ελεύθερης Έκφρασης στο Δημόσιο Χώρο");
f++;

xap=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Χρόνιας Αποφρακτικής Πνευμονοπάθειας"); // τρίτη Τετάρτη του Νοεμβρίου
f++;

sofia=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Φιλοσοφίας"); // τρίτη Πέμπτη του Νοεμβρίου
f++;

troxaio=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Μνήμης Θυμάτων Τροχαίων Ατυχημάτων"); //  τρίτη Κυριακή του Νοεμβρίου
f++;

antiagora=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Αγοραστικής Αποχής / Ημέρα Αντικαταναλωτισμού"); // τελευταίο Σάββατο του Νοεμβρίου
f++;

tuba=f;
strcpy (pagk[f], "Διεθνής Ημέρα της Τούμπας (Tuba)"); // πρώτη Παρασκευή κάθε Μαΐου 
f++;

emporio=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Δίκαιου Εμπορίου"); // το δεύτερο Σάββατο του Μαΐου 
f++;

sklhr_plak=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Σκλήρυνσης Κατά Πλάκας"); // τελευταία Τετάρτη του Μαΐου
f++;

apostr_ast=f;
strcpy (pagk[f], "Ημέρα Τιμής των Αποστράτων της Ελληνικής Αστυνομίας"); // Αγίων Πάντων
f++;

surfing=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Κυματοδρομίας (Σέρφινγκ)"); // 21 Ιουνίου ή 20 Ιουνίου τα δίσεκτα έτη 
f++;

admin=f;
strcpy (pagk[f], "Διεθνής Ημέρα του Διαχειριστή Συστημάτων"); // τελευταία Παρασκευή κάθε Ιουλίου
f++;

beer = f;
strcpy (pagk[f], "Διεθνής Ημέρα Μπύρας"); //  πρώτη Παρασκευή του Αυγούστου
f++;

geniada = f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Γενειάδας (μουσάτων και γενειοφόρων)"); //  πρώτο Σάββατο του Σεπτεμβρίου
f++;

ahelp = f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Πρώτων Βοηθειών"); //   δεύτερο Σάββατο κάθε Σεπτεμβρίου
f++;

free_software = f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Ελεύθερου Λογισμικού"); //   τρίτο Σάββατο κάθε Σεπτεμβρίου
f++;

parhgoria=f;
strcpy (pagk[f], "Παγκόσμια Ημέρα Ξενώνων και Παρηγορητικής Φροντίδας"); //    δεύτερο Σάββατο του Οκτωβρίου
f++;

euronight = f;
strcpy (pagk[f], "Ευρωπαϊκή Νύχτα Χωρίς Ατυχήματα"); //    τρίτο Σάββατο του Οκτωβρίου
f++;

paulos_melas = f;
strcpy (pagk[f], "Ημέρα του Μακεδονικού Αγώνα"); //    πρώτη Κυριακή μετά την 13η Οκτωβρίου
f++;

wine_tour = f;
strcpy (pagk[f], "Ευρωπαϊκή Ημέρα Οινοτουρισμού"); //    δεύτερη Κυριακή του Νοεμβρίου
f++;

kyst_inosi = f;
strcpy (pagk[f], "Ευρωπαϊκή Εβδομάδα Ευαισθητοποίησης για την Κυστική Ίνωση"); //    τρίτη Δευτέρα του Νοεμβρίου
f++;

// Τελικά....
ar_pagk_1 = f;
//printf ("pagkosmies = %d / proetoimasm. = 480\n" ,f);
for(f=0;f<ar_pagk_1;f++) {normtext_tomy (pagk[f],0);}

// ΤΕΛΟΣ ΠΑΓΚΟΣΜΙΩΝ


strcpy (mother,"Ημέρα της Μητέρας");
normtext_tomy (mother,0);
strcpy (father,"Ημέρα του Πατέρα");
normtext_tomy(father,0);

//ΦΟΡΤΩΜΑ BUTTONS

sprintf (str1024,"%s%s",path_name,"PINS/ONOM_A_M.inp");
dbbut[0].mem_butt = named_button_load(&dbbut[0].butt_orio, &dbbut[0].butt_ar, str1024);
if (!dbbut[0].mem_butt) goto gamidia;
sprintf(str1kb,"ΚΑΤΑΛΟΓΟΣ ΟΝΟΜΑΤΩΝ (Α-Μ)");
normtext_tomy(str1kb,dbbut[0].butt_name);


sprintf (str1024,"%s%s",path_name,"PINS/ONOM_N_V.inp");
dbbut[1].mem_butt = named_button_load(&dbbut[1].butt_orio, &dbbut[1].butt_ar, str1024);
if (!dbbut[1].mem_butt) goto gamidia;
sprintf(str1kb,"ΚΑΤΑΛΟΓΟΣ ΟΝΟΜΑΤΩΝ (Ν-Ω)");
normtext_tomy(str1kb,dbbut[1].butt_name);

sprintf (str1024,"%s%s",path_name,"PINS/WHICH.inp");
dbbut[2].mem_butt = named_button_load(&dbbut[2].butt_orio, &dbbut[2].butt_ar, str1024);
if (!dbbut[2].mem_butt) goto gamidia;
sprintf(str1kb,"Καθορισμός Ημέρας της Εβδομάδος");
normtext_tomy(str1kb,dbbut[2].butt_name);

ORL=0;

    if (!access("/usr/bin/xed", F_OK )) {
        ORL=1;
    }
    else if(!access("/usr/bin/kwrite", F_OK )) {
        ORL=1;
    }
    else if(!access("/usr/bin/featherpad", F_OK )) {
        ORL=1;
    }
    else if(!access("/usr/bin/geany", F_OK )) {
        ORL=1;
    }
    else if(!access("/usr/bin/kate", F_OK )) {
        ORL=1;
    }
    else if(!access("/usr/bin/gedit", F_OK )) {
        ORL=1;
    }
    else {ORL=0;}



// ΠΡΟΕΤΟΙΜΑΣΙΑ ΠΙΝΑΚΩΝ ΜΝΗΜΗΣ mri και mra
arst = 512 ; arma = 128 ;
szYR = sizeof (struct YearRec) ;
mem_g = malloc ( arst * szYR ) ;
if (mem_g==NULL) { printf ("Out of Memory - Abort !\n"); goto gamidia; }
mem_a = malloc ( arst * szYR ) ;
if (mem_a==NULL) { printf ("Out of Memory - Abort !\n"); goto gamidia; }
mri = (struct YearRec*) mem_g ;
mri_1 = mri ;
mra = (struct YearRec*) mem_a ;
mra_1 = mra ;
    
pedaba_calendar(-1);                                                
                                    
//KLEINEI SHMEIVMATARIO
sprintf(file_1,"%s.EORT_SETTINGS/draftnotes.dat",user_path);

fp=fopen(file_1,"r+b");
if (fp!=NULL) {
    fide_fp = fileno (fp) ;
    i=0;
    while (notes_str[i]!=255 && i<60000) i++;
    notes_str[i]=255;
    if (i) {fwrite (notes_str,1,i+1,fp);}
    else {notes_str[1]=255; fwrite (notes_str,2,1,fp); }
    fdatasync (fide_fp);
    fsync(fide_fp);
    fclose(fp);
    fp=NULL;
}
else {
     information (6-keyb_gr,file_1,"Προτείνεται ο έλεγχος του δίσκου !!");
}

// Κλείνει προσωπικές επετείους

sprintf (file_1,"%s%s",user_path,".EORT_SETTINGS/UserToDo.dat");

fp=fopen(file_1,"r+b");
if (fp!=NULL) {
    fide_fp = fileno (fp) ;
    fwrite(&ar_per,2,1,fp);
    fdatasync (fide_fp);
        if (ar_per) {
        f=sizeof (struct myepet) ;
        fwrite (pers,f,ar_per,fp);
        fdatasync (fide_fp);
        }
    i=fsync (fide_fp);
    if (ferror(fp) || (i) ) { information (6-keyb_gr,file_1,"Προτείνεται o έλεγχος του δίσκου!");clearerr(fp) ; }
    fclose(fp);
}
else {
     information (6-keyb_gr,file_1,"Προτείνεται ο έλεγχος του δίσκου !!");
}

// Σώνει και τις επαναλαμβανόμενες υπομνήσεις

sprintf (str1kb,"%s%s",user_path,".EORT_SETTINGS/Recursing.dat");
fp=fopen(str1kb,"r+b");
if (fp!=NULL) {
    fide_fp = fileno (fp) ;
    fwrite(&ar_clue,2,1,fp);
    fdatasync (fide_fp);
        if (ar_clue) {
        f=sizeof (struct RECURRENT) ;
        fwrite (rcr,f,ar_clue,fp);
        fdatasync (fide_fp);
        }
    i=fsync (fide_fp);
    if (ferror(fp) || (i) ) { information (6-keyb_gr,str1kb,"Προτείνεται o έλεγχος του δίσκου!");clearerr(fp) ; }
    fclose(fp);
}
else {
     information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
}

// Ενημερώνει για τα fonts που προτιμάει ο χρήστης

sprintf (str1kb,"%s%s",user_path,".EORT_SETTINGS/UserFonts.dat");

        fp=fopen(str1kb,"r+b");
        if (fp!=NULL) {
            fide_fp=fileno(fp);
            fwrite(&notes_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&eortes_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&names_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&ponom_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&eortologio_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&pagkosm_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&personal_font,4,1,fp);
            fdatasync (fide_fp);
            fwrite(&mobeort_font,4,1,fp);
            fdatasync (fide_fp);
            i = fsync (fide_fp);
            if (ferror(fp) || (i) ) { information (6-keyb_gr,str1kb,"Προτείνεται o έλεγχος του δίσκου!");clearerr(fp) ; }
            fclose (fp);
        }
        else {
            information (6-keyb_gr,str1kb,"Προτείνεται ο έλεγχος του δίσκου!");
        }

/*
dbbut[0].butt_elem = button_show ( dbbut[0].mem_butt , dbbut[0].butt_data , dbbut[0].butt_ar , dbbut[0].butt_orio , dbbut[0].butt_name , &dbbut[0].butt_sorton , 0 );
dx=dbbut[0].butt_elem;
if (dx>=0) {
    if (dx<648) {
        i=ssee[dx].dm[0];
        f=ssee[dx].dm[1];
    }
    else {
        i=ksee[dx-648].dm[0];
        f=ksee[dx-648].dm[1];
    }
}

printf("uday : %d , umonth : %d \n" , i, f);

*/

gamidia:
if (sfalma) free (sfalma);
//if (dbfds.mem_fd) free(dbfds.mem_fd) ;
if (dbfnt.mem_fn) free(dbfnt.mem_fn);
//if(dbfdata.mem_fd) free(dbfdata.mem_fd);
for (f=0 ; f<ttf ; f++) {
    if (mem_Font[f]!=NULL) {free (mem_Font[f]);}
}

for (f=0;f<10;f++) { if (dbbut[f].mem_butt) free( dbbut[f].mem_butt ); }
if (mem_g!=NULL) free (mem_g) ;
if (mem_a!=NULL) free (mem_a) ;
if (mem_atono!=NULL) free(mem_atono);

telos:
SDL_Quit();

restorecrtmode();
exit(0);
}

long int inp_numb()
{
int i , len=0, asf=-1, ar ;
char str[80];
long int timh=0 , pol ;
while (!len) {
    for(i=0;i<80;i++) str[i]=0;
    scanf("%s",str);
    len=(int) strlen(str);
    if (!len) {printf("\r");continue;}
    if(str[0]=='-')
        if(len>1) asf=0;
        else len=0;
}
len--;
for(i=len,pol=1; i>asf; i-- , pol=pol*10) {
    ar=(int) str[i]-48;
    if (ar==-21) { my_esc=1;return 0; }
    if (ar<0 || ar>9) return 0;
    timh=timh+(ar*pol);
}
if(asf) return timh ;
return -timh;
}

void gotoxy(int x, int y) { printf("\x1B[%d;%df", y, x); }
 
void clrscr() { printf("\x1B[2J\x1B[0;0f"); }




void cls()
{
    register int i , f ;
    setcolor (COLOR(dbbkxr[0],dbbkxr[1],dbbkxr[2]));  
    for (i=info.left;i<=info.right;i++) {for (f=info.top ; f<=info.bottom; f++) _putpixel (i,f);}
    refresh();
    return;
}

void efecls (int x,int y,int w,int h,int kok,int pra,int mpl)
{
    int i , f ;
    int dx,dy,bx,by;
    int del ;
    
    setcolor (COLOR(kok,pra,mpl));  
    
    for (i=x,f=y ; ((i<w+x) && (f<h+y)) ; i++ , f++) {
        bx=1; by=1;
        dx=w+x-i; dy=h+y-f;
        _putpixel(i,f); 
        dx--;dy--;
        if (random(200) <8) refresh();
        
        while ((dx) && (dy)) {  
            _putpixel ((i+bx),f) ; bx++ ; dx-- ;
            _putpixel (i,(f+by));by++,dy-- ; }
            
        while (dx) {_putpixel ((i+bx),f) ; bx++ ; dx-- ;}
        while (dy) {_putpixel (i,(f+by)); by++ ; dy-- ;}
    }
    while(i<w+x) _putpixel(i++,f-1); 
    while(f<h+y) _putpixel(i-1,f++);
    refresh();
    return;
}

void qcls (int kok,int pra,int mpl)
{
    register int i , f ;
    setcolor (COLOR(kok,pra,mpl));  
    for (i=0;i<=info.right;i++) {for (f=0 ; f<=info.bottom; f++) _putpixel (i,f);}
    refresh();
    return;
}

void areacls (int x,int y,int r,int d,int kok,int pra,int mpl)
{
    register int i , f ;
    setcolor (COLOR(kok,pra,mpl));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    refresh();
    return;
}

void bareacls (int x,int y,int r,int d,int *cbkxr)
{
    register int i , f ;
    setcolor (COLOR(cbkxr[0],cbkxr[1],cbkxr[2]));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    refresh();
    return;
}

void * prosouv()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/MySouv.dat");

fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
souv[i].who=elem[i].who;
souv[i].wid=elem[i].wid;
souv[i].hei=elem[i].hei;
souv[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font souv load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}

//************************************************************************************************************

int outsouv(int x, int y, char *str, int lang)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;} 
        }
}
refresh();    
return y;
}

void fidicls(int x, int y, int x1, int y1 , int red , int green, int blue)
{

int dx, dy, syn, ax, ay, ax1, ay1, metr ;

    ax=x ; ay=y ; ax1=x1 ; ay1=y1;
    syn=(x1-x+1) * (y1-y+1);
    metr = 0;
    setcolor ( COLOR (red,green,blue) );
     
    do {
        while (x<x1) {_putpixel(x,y); x++;metr++;}
     
        while (y<y1) {_putpixel (x,y);y++;metr++;}        
     
        while (x>ax) {_putpixel (x,y);metr++;x--;}
        ax++;
        if (random(200) <8) refresh();
        while (y>ay) {_putpixel (x,y);metr++;y--;}
        ay++; y++;
        x1-- ; y1-- ;
      
        } while (metr<syn) ;
    refresh();
    return ;
}


void proinput ()
{
register int i ,f ;
char ch , ch1 ;

/* Προυποθέτει αρχικές τιμές - καθολική μεταβλητή etm[22][3] 
extern unsigned char etm[22][3] =
{53 , '`' , '~' , 30 , '1' , '!' , 31 , '2', '@' , 32 , '3' , '#' , 33 , '4' , '$' , 34 , '5', '%' , 35 , '6' , '^' , 36 , '7' , '&' , 37 , '8' , '*' , 38 , '9' , '(' ,
39 , '0' , ')' , 45 , '-' , '_' , 46 , '=' , '+' , 47 , '[' , '{' , 48 , ']' , '}' , 49 , '\\' , '|' , 51 , ';' , ':' , 52 , '\'' , '\"' , 54 , ',' , '<', 55 , '.' , '>' ,
56 , '/' , '?' , 44, ' ' , ' ' }; 

Επίσης ...
extern struct fachars {
unsigned int scacod [57];
unsigned char faprint [57][2];
unsigned int sort [57][2]
} engl ;

ΚΑΙ να έχει γίνει η προετοιμασία της καθολικής struct fansouv
*/

for (f=0 ; f<57 ; f++) 
{
engl.scacod[f]=0 ;    
engl.faprint[f][0]= 0 ; 
engl.faprint[f][1]= 0 ; 
grek.scacod[f]= 0 ;    
grek.faprint[f][0]=0 ; 
grek.faprint[f][1]= 0; 
}

for (f=4 , ch='a' , ch1='A' ; f<30 ; f++,ch++,ch1++) 
{
engl.scacod[f]=f ;    
engl.faprint[f][0]=ch ; 
engl.faprint[f][1]=ch1; 
grek.scacod[f]=f ;    
grek.faprint[f][0]=ch ; 
grek.faprint[f][1]=ch1; 
}

grek.faprint[20][0] = ';' ;
grek.faprint[20][1] = ':' ;
grek.faprint[26][1] = 'S' ;

for (f=0 ; f<22 ; f++) 
{
i=etm[f][0];
engl.scacod[i]=i; 
engl.faprint[i][0]=etm[f][1] ; 
engl.faprint[i][1]=etm[f][2] ;
grek.scacod[i]=i; 
grek.faprint[i][0]=etm[f][1] ; 
grek.faprint[i][1]=etm[f][2] ;
}

grek.scacod[51]=0;
grek.faprint[51][0]= 0 ; 
grek.faprint[51][1]= 0 ;

for (f=0;f<95;f++) //gr_start=95 !!//
{
    for (i=0 ; i<57 ; i++)
    {
        if (engl.faprint[i][0]==souv[f].who) engl.sort[i][0]= f ;
        if (engl.faprint[i][1]==souv[f].who) engl.sort [i][1]=f ;
    }
}

for (f=0;f<43;f++) 
{
    for (i=0 ; i<57 ; i++)
    {
        if (grek.faprint[i][0]==souv[f].who) grek.sort[i][0]= f ;
        if (grek.faprint[i][1]==souv[f].who) grek.sort [i][1]=f ;
    }
}

for (f=95;f<164;f++) 
{
    if (souv[f].who == '*') continue ; 
    for (i=0 ; i<57 ; i++)
    {
        
        if (grek.faprint[i][0]==souv[f].who) grek.sort[i][0]= f ;
        if (grek.faprint[i][1]==souv[f].who) grek.sort [i][1]=f ;
    }
}
return ;
}


int bmptodisk (char *bmpname, unsigned int size_bytes,int width, int height)
{
union picols{
unsigned int ltimi;
unsigned char xro[4];
}col;
void *mem_start ;
int *mem_int, *mem_int0;
FILE *arxeio_fp;
long int good=width * height * 4 ;
int f ,i ,bad , transp_1;
char newname[150];
bad=size_bytes-good ;
mem_start = malloc (good+8);
if (mem_start==NULL) return 0;
arxeio_fp = fopen(bmpname,"rb");
if (!arxeio_fp) {free(mem_start); return 0;}
if ((fseek(arxeio_fp,bad,SEEK_SET))) {free(mem_start); fclose(arxeio_fp); return 0;}
//good=fread(mem_start,sizeof(short int),35,arxeio_fp);
//if(good != 35) {free(mem_start); fclose(arxeio_fp); return NULL;}
mem_int0=mem_start;
*mem_int0++ = width ; 
*mem_int0++ = height; 

for(f=height;f>0;f--) {
mem_int=mem_int0;
mem_int = mem_int + ((f-1)*width);
    for (i=0;i<width;i++) { 
        fread(&col.ltimi , sizeof(int) , 1, arxeio_fp);
         transp_1=col.xro[0]; 
         col.ltimi = col.ltimi >> 8;
        col.xro[3]= transp_1; 
        *mem_int++ = col.ltimi;
    }}

fclose(arxeio_fp);
bad=strlen(bmpname);
strcpy(newname,bmpname);
newname[(bad-3)]='\0';
strcat(newname,"ico");
arxeio_fp = fopen(newname,"wb");
if (!arxeio_fp) {free(mem_start); return 0;}
i= (width*height*4) + 8 ;
fwrite (mem_start,1,i,arxeio_fp);
if(ferror(arxeio_fp)) {clearerr(arxeio_fp); printf("fwrite Problem !"); free(mem_start); fclose(arxeio_fp); return 0;}
fclose(arxeio_fp);
return 1;
}

void *icontomem (char *filename,int transp)
{
void *mem_start ;
char *mem1;
int *mem_int;
FILE *fp;
int width , height ;
unsigned int size ;
register int f ;

fp = fopen(filename,"rb");
if (fp==NULL) {information(6-keyb_gr,filename,NULL); return NULL;}
fread(&width,4,1,fp);
fread(&height,4,1,fp);
size=( (width*height*4) + 8 );
mem_start = malloc (size);
if (mem_start==NULL) return NULL ;
mem_int=mem_start;
mem1=mem_start;
*mem_int++ = width ; 
*mem_int++ = height; 
size -= 8 ; size /= 4 ;
fread(mem_int,4,size,fp);
if(ferror(fp)) {clearerr(fp); information(6-keyb_gr,filename,NULL); free(mem_start); fclose(fp); return NULL;}
fclose(fp);
//mem1 += 7;
//for(f=0 ; f<size ; f++) {
//    mem1+=4;
//    if ((*mem1))  *mem1=(unsigned char) transp ;
//    }
return mem_start;
}


//************************************************************************************************************

int outnoto(int x, int y, char *str, int lang)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;} 
        }
}
refresh();    
return y;
}

int outnoto_big(int x, int y, char *str, int lang, int syntx , int synty)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w , w1, h1 ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid*syntx) > info.right ) { x = info.left ; y+=26*synty ; }
  if ( (y+26*synty) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
  
     for(h=0; h<nouv[i].hei ; h++) {
        for(w=0;w<nouv[i].wid;w++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
             
                for (h1=0 ; h1<synty ; h1++) {
                    for (w1=0 ; w1<syntx; w1++) {
                        _putpixel( (x+w*syntx+w1) , (y+h*synty+h1) ); }}}}
    x+=nouv[i].wid*syntx;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid*syntx) > info.right ) { x = info.left ; y+=26*synty ; }
  if ( (y+26*synty) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
    for(h=0; h<nouv[i].hei ; h++) {
        for(w=0;w<nouv[i].wid;w++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
             
                for (h1=0 ; h1<synty ; h1++) {
                    for (w1=0 ; w1<syntx; w1++) {
                        _putpixel( (x+w*syntx+w1) , (y+h*synty+h1) ); }}}}
    x+=nouv[i].wid*syntx;}}}
refresh();    
return 1;
}

int outnoto_sma(int x, int y, char *str, int lang)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ,w1 , h1 ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid/2) > info.right ) { x = info.left ; y+=13 ; }
  if ( (y+13) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
  
   for(h=0; h<nouv[i].hei ; h++) {
     
       if (h%2) {mem_int+=nouv[i].wid ; continue; }
     for(w=0;w<nouv[i].wid;w++) {
      
     if (w%2) {mem_int++ ; continue; }
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w/2 , y+h/2);}}
     x+=nouv[i].wid/2;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid/2) > info.right ) { x = info.left ; y+=13 ; }
  if ( (y+13) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
    for(h=0; h<nouv[i].hei ; h++) {
       //h1=h/2;
       if (h%2) {mem_int+=nouv[i].wid ; continue; }
     for(w=0;w<nouv[i].wid;w++) {
      
     if (w%2) {mem_int++ ; continue; }
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w/2 , y+h/2);}}
     x+=nouv[i].wid/2;}}}
        
refresh();    
return 1;
}

int Wbmptodisk (char *bmpname, unsigned int size_bytes,short int width, short int height)
{
unsigned int wtimi;
void *mem_start ;
short int *mem_word , *mem_word0 ;
FILE *arxeio_fp;
unsigned int good; 
int f ,i ,bad ;
char newname[150];
good = width * height * 2 ;
bad=size_bytes-good ;
mem_start = malloc (good+4);
if (mem_start==NULL) return 0;
arxeio_fp = fopen(bmpname,"rb");
if (!arxeio_fp) {free(mem_start); return 0;}
if ((fseek(arxeio_fp,bad,SEEK_SET))) {free(mem_start); fclose(arxeio_fp); return 0;}

mem_word0=mem_start;
*mem_word0++ = width ; 
*mem_word0++ = height; 

for(f=height;f>0;f--) {
mem_word=mem_word0;
mem_word += ( (f-1)*width );
    for (i=0;i<width;i++) { 
        fread(mem_word++ , 2 , 1, arxeio_fp);
     }}

fclose(arxeio_fp);
bad=strlen(bmpname);
strcpy(newname,bmpname);
newname[(bad-3)]='\0';
strcat(newname,"icw");
arxeio_fp = fopen(newname,"wb");
if (!arxeio_fp) {free(mem_start); return 0;}
size_bytes= (width*height*2) + 4 ;
fwrite (mem_start,1,size_bytes,arxeio_fp);
if(ferror(arxeio_fp)) {clearerr(arxeio_fp); printf("fwrite Problem !"); free(mem_start); fclose(arxeio_fp); return 0;}
fclose(arxeio_fp);
return 1;
}

void *icWtomem (char *filename)
{
void *mem_start ;
char *mem1;
short int *mem_int;
FILE *fp;
unsigned short int width , height ;
unsigned int size ;
register int f ;

fp = fopen(filename,"rb");
if (fp==NULL) {return NULL;}
fread(&width,2,1,fp);
fread(&height,2,1,fp);
size=( (width*height*2) + 4 );
mem_start = malloc (size);
if (mem_start==NULL) return NULL ;
mem_int=mem_start;
mem1=mem_start;
*mem_int++ = width ; 
*mem_int++ = height; 
size -= 4 ; size /= 2 ;
fread(mem_int,2,size,fp);
if(ferror(fp)) {clearerr(fp); printf("File Read Problem !"); free(mem_start); fclose(fp); return NULL;}
fclose(fp);
//mem1 += 7;
//for(f=0 ; f<size ; f++) {
//    mem1+=4;
//    if ((*mem1))  *mem1=(unsigned char) transp ;
//    }
return mem_start;
}

int puticW(int x, int y, void *mem_w)
{
unsigned short int w , h ,rval,gval,bval,wtimi;
short int *mem_w1;
register int f,i ;
mem_w1=mem_w;
w=*mem_w1++ ; h=*mem_w1++;

for (f=0 ; f<h ; f++) {
    for (i=0 ; i<w ; i++) {
        wtimi=*mem_w1++;
        if (!(wtimi / 32768)) continue ;
        wtimi=wtimi ^ 32768;
        rval=wtimi >> 7;
        gval = wtimi << 6 ;
        gval = gval >> 9 ;
        bval = wtimi << 11;
        bval = bval >>9;
        
        setcolor ( COLOR ( (int)rval,(int) gval, (int) bval) ) ; 
        _putpixel (x+i,y+f); }}
refresh();
return 1;
}

void fontoicW (int x , int y, int red, int green, int blue, void *mem1)
{
    
register int i,f;
unsigned short int w , h ,wtimi;
short int *memw;

setcolor (COLOR (red,green,blue) );  
memw=mem1;
w = *memw++; h=*memw++;
for (f=0 ; f<h ; f++) {
    for (i=0 ; i<w; i++) {
        wtimi=*memw++;
         if ((wtimi / 32768) ) continue ;
         _putpixel (x+i,y+f); }}
         refresh();
         return;
}


int change_dim(int xl, int yt ,int *mxright , int *mybottom)
{
SDL_Cursor* cursor;
int mxr , myb , prxr , pryb ;
unsigned int size ;
void *mem1=NULL ;
register int i,f ;
int pev ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);

prxr=*mxright; pryb=*mybottom;
size=imagesize (xl,yt,info.right,info.bottom);
mem1=malloc(size);
if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);return -1;}
getimage (xl,yt,prxr,pryb,mem1);
setcolor (COLOR(255,0,0)) ;  
rectangle (xl,yt,prxr,pryb);
setcolor (COLOR(255,255,0)) ;  
for (i=yt+1;i<pryb;i+=3) {for (f=xl+1 ; f<prxr; f+=3) _putpixel (f,i);}
refresh();

//do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);
SDL_FlushEvent(SDL_MOUSEBUTTONUP);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);

  do {
       pev = SDL_PollEvent(&sdlev) ;
       
       //while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       
       //SDL_GetRelativeMouseState (&mxr , &myb);
        mxr = sdlev.motion.x ; myb = sdlev.motion.y ;
        SDL_FlushEvent(SDL_MOUSEMOTION);
       if (mxr<=xl || myb<=yt) continue;
       if (mxr>info.right) mxr=info.right ;
       if (myb>info.bottom) myb=info.bottom;
       if (mxr==prxr && myb==pryb) continue;
        putimage (xl,yt,mem1,0); 
        prxr=mxr ; pryb=myb;
        getimage (xl,yt,mxr,myb,mem1);
        setcolor (COLOR(255,0,0)) ;  
        //rectangle (xl,yt,mxr,myb);
        for(f=xl;f<=mxr;f++) {_putpixel(f,yt); _putpixel(f,myb);}
        for(i=yt+1;i<=myb;i++) {_putpixel(xl,i); _putpixel(mxr,i);}
        setcolor (COLOR(255,255,0)) ;  
        for (i=yt+1;i<myb;i+=4) {for (f=xl+1 ; f<mxr; f+=4) _putpixel (f,i);} refresh(); 
        } while (!pev || sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
     putimage (xl,yt,mem1,0); free(mem1);
    *mxright=prxr ; *mybottom=pryb ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return 1;
}

int change_pos(int *xl, int *yt ,int *xr , int *yb)
{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt ;
unsigned int size ;
void *mem1=NULL ;
register int i,f ;
unsigned int dx , dy , sx ,sy ;
int pev ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
prxl=*xl; pryt=*yt;
dx=mxr-prxl; dy=myb-pryt;
size=imagesize (prxl,pryt,mxr,myb);
mem1=malloc(size);
if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);return -1;}
getimage (prxl,pryt,mxr,myb,mem1);
setrgbpalette (2,255,0,0) ;  setrgbpalette (3,255,255,0) ;
setrgbcolor(2);
rectangle (prxl,pryt,mxr,myb);
setrgbcolor(3);
for (i=pryt+1;i<myb;i+=3) {for (f=prxl+1 ; f<mxr; f+=3) _putpixel (f,i);}
refresh();

//do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

SDL_FlushEvent(SDL_MOUSEBUTTONUP);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent (SDL_MOUSEMOTION) ;

  do {
       pev = SDL_PollEvent(&sdlev);
       //while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       if (!pev) continue ;
       if (sdlev.type == SDL_MOUSEMOTION) {
       mxl = sdlev.motion.x ; myt = sdlev.motion.y ;
       SDL_FlushEvent(SDL_MOUSEMOTION);
       }
       else if (sdlev.type == SDL_MOUSEBUTTONDOWN) { break ; }
       else continue ;

       if (mxl<info.left ) mxl=info.left;
       if (mxl+dx>info.right) mxl=info.right-dx;
       if (myt<info.top) myt=info.top;
       if (myt+dy>info.bottom) myt=info.bottom-dy ;
       if (mxl==prxl && myt==pryt) continue;
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dx ; sy=myt+dy;
        getimage (mxl,myt,sx,sy,mem1);
         setrgbcolor(2);
       
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       setrgbcolor(3);
       //setcolor (COLOR(255,255,0)) ;  
        for (i=myt+1;i<sy;i+=4) {for (f=mxl+1 ; f<sx; f+=4) _putpixel (f,i);} refresh(); 
        } while (!pev || sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
    
    putimage (prxl,pryt,mem1,0); free(mem1);
    *xl=prxl ; *yt=pryt ;*xr=prxl+dx ; *yb=pryt+dy;
    SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return 1;
}

int puticon (int x1,int y1,void *mem1,int transp)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    for (f=0;f<height;f++) {
    
    for(i=0 ; i < width; i++) {
    co.lor= *(mem_int++);
    if (co.rgb[3]>128) {
        setcolor (COLOR ( co.rgb[2],co.rgb[1],co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    refresh(); 
    return 1;
}

int outnoto_col(int x, int y, char *str, int lang, int *chxr, int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float alfa,neg ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
   
   // Gia MENA 
    alfa =  ((float)co.rgb[0] / 255) ;
    neg = ((float)1 - alfa);
    red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
    green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
    blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
     setcolor(COLOR (red,green,blue));
   
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
    
    // Gia MENA 
    alfa =  ((float)co.rgb[0] / 255) ;
    neg = ((float)1 - alfa);
    red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
    green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
    blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );

    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;} 
        }
}
refresh();    
return y;
}

int outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float neg, alfa ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     
   
    // Gia MENA 
    alfa =  ((float)co.rgb[0] / 255) ;
    neg = ((float)1 - alfa);
    red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
    green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
    blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
      
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
    
    // Gia MENA 
    alfa =  ((float)co.rgb[0] / 255) ;
    neg = ((float)1 - alfa);
    red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
    green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
    blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;} 
        }
}
refresh();    
return y;
}


void *sfalmata()
{
unsigned short int file_flag,ar,f;
FILE *fp;
int pedb[4] , pedc;
void *mem;

pedb[0]=358910; pedb[1]=762343; pedb[2]=4443; pedb[3]=2330;

// ΔΙΑΒΑΣΜΑ ΑΠΟ ΔΙΣΚO ΟΛΩΝ ΤΩΝ ΜΗΝΥΜΑΤΩΝ ΛΑΘΟΥΣ κλπ κλπ
file_flag=0;
strcpy (file_1,path_name);
strcat (file_1,"Errors.inp");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf ("Missing File ( %s ) \n",file_1);return NULL;}
for (f=0 ; f<4 ; f++) {
fread(&pedc,4,1,fp);
if (feof(fp)) { file_flag=1; break; }
if (pedc!=pedb[f]) {file_flag=1;break;}}
if (file_flag) {printf ("Bad File ( %s ) \n",file_1); return NULL;}
fread(&ar,2,1,fp);
mem=malloc(ar);
if (!mem) {printf ("Error Alerts Reading - Out of memory !! \n"); fclose (fp); return 0;}
fread(mem,1,ar,fp);
if (ferror(fp)) { clearerr(fp); fclose (fp); printf ("Probably Disk Error ( %s ) \n",file_1); return NULL;}
fclose (fp);
return mem;
}

void information (int id,char *seleo,char *seleo1)
{
SDL_Cursor* cursor;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, start , x4,y4,ymy,xc,yc,xr,a,hei_box;
unsigned int size ,wid ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1 , *mem_int ;
short int kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;
char file_10[1024];
float neg, alfa ;
int pev ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
size=imagesize(0,0,399,299);
mem0=malloc(size);
if (!mem0) {printf ("Information Function - Out of memory !! \n"); return ;}
x=(info.right-info.left-399) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+399,y+299,mem0);
xp=x;
y1=y+219;
x+=162;
strcpy (file_10,path_name);
strcat (file_10,"ICD/info.ico");
mem_alert=icontomem (file_10,255);
strcpy (file_10,path_name);
strcat (file_10,"ICD/Sym_OK.ico");
mem_menu= icontomem (file_10,255);
hei_box=75;
setcolor(14);
rectangle(xp,y,xp+399,y+299);
rectangle(xp+5,y+5,xp+394,y+294);
_areacls (xp+1,y+1,xp+398,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+395,y+5,xp+398,y+298,255,165,0);
_areacls (xp+5,y+295,xp+394,y+298,255,165,0);
//cbkxr[0]=55; cbkxr[1]=70; cbkxr[2]=220;
//_areacls (xp+6,y+6,xp+393,y+293,55,70,220);

cbkxr[0]=21; cbkxr[1]=30; cbkxr[2]=41;
_areacls (xp+6,y+6,xp+393,y+293,cbkxr[0],cbkxr[1],cbkxr[2]);

_puticon(xp+7,y+7,mem_alert,255);
_puticon(x,y1,mem_menu,255);
refresh();
chrxr[0]=0;chrxr[1]=0;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+165,y+10,"I N F O",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+166,y+10,"I N F O",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+265,y+33);
line (xp+150,y+35,xp+260,y+35);
refresh();
}
else {
outnoto_col(xp+145,y+10,"P R O S O X H",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+146,y+10,"P R O S O X H",1,chrxr,cbkxr);
setcolor (4);
line (xp+135,y+33,xp+320,y+33);
line (xp+140,y+35,xp+315,y+35);
refresh();    
}
xr=xp+392;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! Μπορώ μέχρι και y4+80 (seleo1) (2 γραμμές) .

i=0;f=0;

do {
    what=sfalma[i];
    if (what==255) break ;
    if (what==10) {
        i++; what=sfalma[i]; 
        if (what==10) {
            i++; f++;
            if (f==id) {i+=2;break;}
        }}
       i++;
    } while (what !=255);
    
    
    if (f==id) {
        chrxr[0]=162;chrxr[1]=255;chrxr[2]=105;
        xc=x2;yc=y2;
        a=i;
        what=sfalma[a];
        
        do {
            if (what==200) { 
                 yc+=16;
                 if (yc>=ymy) break;
                 xc=(yc>=y4) ? x4 : x2 ;
                 a++; what=sfalma[a]; continue;}
                 
        if ((xc+souv[what].wid) > xr) {
            yc+=16;
            if (yc>=ymy) break;
            xc=(yc>=y4) ? x4 : x2 ;}
            
        mem_int1=souv[what].where ;
        for(f=0; f<souv[what].hei ; f++) {
        for(i=0;i<souv[what].wid;i++) {
        co.lor = *mem_int1++;
        if (!co.lor) continue;
        
        // Gia MENA 
        alfa =  ((float)co.rgb[0] / 255) ;
        neg = ((float)1 - alfa);
        red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
        green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
        blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
        
        setcolor(COLOR (red,green,blue));
        _putpixel(xc+i , yc+f);}}
        xc+=souv[what].wid;
        a++; what=sfalma[a];
        } while (what!=40);  // 41 αντιστοιχεί στον χαρακτήρα : '|'  
    }
    
    chrxr[0]=255;chrxr[1]=153;chrxr[2]=105;
    
    if (!id) ymy=y4 ;
    xc=x4; yc=ymy;
    
    if (seleo!=NULL) {
        size=strlen(seleo);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Information Function - Out of memory !! \n"); free(mem0); return ;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==nouv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo[f];}}
            
            str[a]=255;
            
           
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                
                // Gia MENA 
                alfa =  ((float)co.rgb[0] / 255) ;
                neg = ((float)1 - alfa);
                red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
                green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
                blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
                
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
                yc+=16;xc=x4;
    }
    
    if (yc<=y4+80) {
        if (seleo1!=NULL)  {
        size=strlen(seleo1);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Information Function - Out of memory !! \n"); free(mem0); return ;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo1[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo1[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo1[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo1[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo1[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==nouv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo1[f];}}
            
            str[a]=255;
                        
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                
                
                // Gia MENA 
                alfa =  ((float)co.rgb[0] / 255) ;
                neg = ((float)1 - alfa);
                red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
                green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
                blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
                
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
    }}
    
    refresh();

mem_int=mem_menu;
wid=*mem_int;

kyk=-2; outmen=2;start=0;
chrxr[0]=255;chrxr[1]=0;chrxr[2]=255;      
              
        do {
        pev = SDL_PollEvent(&sdlev);
        if (!pev) continue ;
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if (sdlev.type==SDL_MOUSEMOTION) {
            if ( (secwin) && (sdlev.motion.windowID != pran) ) { continue ; }
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);}
        else if ( (sdlev.type==SDL_KEYDOWN) && ( (sdlev.key.keysym.scancode==SDL_SCANCODE_RETURN) || (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) ) ) {mx=x+60;my=y1+30;enter_go=1;}

        if (mx>x && mx<x+75 && my>y1 && my < y1+75 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά

        
        if (!start) {
        mem_efedr1 = mem_menu+8;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid-1;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  (chrxr[0] * co.rgb[2]) / 255;
        green =  (chrxr[1] * co.rgb[1]) / 255;
        blue =  (chrxr[2] * co.rgb[0]) / 255 ;
        setcolor(COLOR (red,green,blue));
        _putpixel (x+i,y1+f);}}
        refresh();
        start=1;
       }
       kyk=0;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        }
         continue ;    
        }
        else {
        if (start) {
        puticon(x,y1,mem_menu,255);
        start=0; kyk=-1;} 
        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
fidicls(xp, y,xp+399,y+299, 65,80,225);  
putimage(xp,y,mem0,0);
refresh();
free(mem0);
free(mem_menu);
free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return;
}


int outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float neg, alfa ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     
    // Gia MENA 
    alfa =  ((float)co.rgb[0] / 255) ;
    neg = ((float)1 - alfa);
    red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
    green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
    blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     

    // Gia MENA 
    alfa =  ((float)co.rgb[0] / 255) ;
    neg = ((float)1 - alfa);
    red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
    green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
    blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=nouv[i].wid;} 
        }
}
refresh();    
return y;
}

double convert_str(short int len , char *str)
{
double f_num=0;
long int num_long=0;
short int f , a, ypo;
unsigned char i;
char num_str[len+1];

if (!len) return 0;
ypo=0;
f=0;a=0;
i=str[f];

    do {
        
        if ( (i==13) && (!a) ) { num_str[a]=45; a++ ; }
        else if ( (i==12) && (a) && (!ypo) ) {num_str[a]=46; ypo=1; a++;}
        else if ( (i>15) && (i<26) ) { num_str[a] = i+32; a++ ; }
        len--;f++;
        i=str[f];
        
    } while ( (i!=255) && (len) );

num_str[a]='\0';
if (ypo) f_num=atof(num_str); else {
num_long=atol(num_str); f_num=(double) num_long ;}
return f_num;
}

int outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float neg, alfa ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     

    // Gia MENA 
    alfa =  ((float)co.rgb[0] / 255) ;
    neg = ((float)1 - alfa);
    red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
    green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
    blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }

    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=souv[i].wid;} 
        }
}
refresh();    
return y;
} 



int putNOTicon (int x1,int y1,void *mem1)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;
    for (f=0;f<height;f++) {
      for(i=0 ; i < width; i++) {
      co.lor= *(mem_int++);
      if (co.rgb[3]>128) {
        setcolor (COLOR ( 255-co.rgb[2], 255-co.rgb[1], 255-co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    refresh(); 
    return 1;
}

void pro_sort_int (int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_int(item,point,0,count-1);
}


void qui_sort_int (int *item , unsigned short int *point , int left , int right)
{
    register int i,j ;
    int x,y;
    unsigned int y1;
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_int(item,point,left,j);
    if (i<right) qui_sort_int(item,point,i,right);
}
    

int _putNOTicon (int x1,int y1,void *mem1)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;
    for (f=0;f<height;f++) {
      for(i=0 ; i < width; i++) {
      co.lor= *(mem_int++);
      if (co.rgb[3]>128) {
        setcolor (COLOR ( 255-co.rgb[2], 255-co.rgb[1], 255-co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    return 1;
}

int _outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float neg, alfa ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     

   // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     
    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=souv[i].wid;} 
        }
}  
return y;
} 

int _outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float neg, alfa ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }  

   // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     
    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=nouv[i].wid;} 
        }
}    
return y;
}

void _areacls (int x,int y,int r,int d,int kok,int pra,int mpl)
{
    register int i , f ;
    setcolor (COLOR(kok,pra,mpl));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    return;
}

void _bareacls (int x,int y,int r,int d,int *cbkxr)
{
    register int i , f ;
    setcolor (COLOR(cbkxr[0],cbkxr[1],cbkxr[2]));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    return;
}

int _outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float neg, alfa ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     
    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     

    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;} 
        }
}    
return y;
}

int _outnoto_col(int x, int y, char *str, int lang, int *chxr, int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
float neg, alfa ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     

   // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );  
   setcolor(COLOR (red,green,blue));
   
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     
    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;} 
        }
}    
return y;
}

int _puticon (int x1,int y1,void *mem1,int transp)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    for (f=0;f<height;f++) {
    
    for(i=0 ; i < width; i++) {
    co.lor= *(mem_int++);
    if (co.rgb[3]>127) {
        setcolor (COLOR ( co.rgb[2],co.rgb[1],co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    return 1;
}


int input_alert (int id,char *seleo, char *inp_str, short int orio)
// Επιστρέφει 1 εάν συμφωνήσει ο χρήστης !
{
SDL_Cursor* cursor;
struct fansouv *whouv;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
short int *mem_int;
unsigned short int trik ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;
float neg, alfa ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

int chxra[3] , bkxra[3] , slxra[3] ;
int pev ;

whouv=gouv;
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
for (f=0;f<3;f++) {
    bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
}

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chxr[0]=chrxr[0]=255;chxr[1]=chrxr[1]=10;chxr[2]=chrxr[2]=20;
slxr[0]=slxr[2]=0; slxr[1]=120;
size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ; 
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
    return 0;
}
x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/keyboard2.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0); goto FYGE;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu) {information (2-keyb_gr,0,0); goto FYGE;}

setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
_areacls (xp+6,y+6,xp+493,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+200,y+10,"T y p e ..",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+201,y+10,"T y p e ..",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+360,y+33);
line (xp+150,y+35,xp+355,y+35);
refresh();
}
else {
outnoto_col(xp+165,y+10,"Plhktrologei'ste..",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+166,y+10,"Plhktrologei'ste..",1,chrxr,cbkxr);
setcolor (4);
line (xp+155,y+33,xp+370,y+33);
line (xp+160,y+35,xp+365,y+35);
refresh();    
}
xr=xp+492;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! 
i=0;f=0;

do {
    what=sfalma[i];
    if (what==255) break ;
    if (what==10) {
        i++; what=sfalma[i]; 
        if (what==10) {
            i++; f++;
            if (f==id) {i+=2;break;}
        }}
       i++;
    } while (what !=255);
    
    
    if (f==id) {
        chrxr[0]=120;chrxr[1]=181;chrxr[2]=117;
        xc=x2;yc=y2;
        a=i;
        what=sfalma[a];
        
        do {
            if (what==200) { 
                 yc+=16;
                 if (yc>=ymy) break;
                 xc=(yc>=y4) ? x4 : x2 ;
                 a++; what=sfalma[a]; continue;}
                 
        if ((xc+souv[what].wid) > xr) {
            yc+=16;
            if (yc>=ymy) break;
            xc=(yc>=y4) ? x4 : x2 ;}
            
        mem_int1=souv[what].where ;
        for(f=0; f<souv[what].hei ; f++) {
        for(i=0;i<souv[what].wid;i++) {
        co.lor = *mem_int1++;
        if (!co.lor) continue;
        
        // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
        setcolor(COLOR (red,green,blue));
        _putpixel(xc+i , yc+f);}}
        xc+=souv[what].wid;
        a++; what=sfalma[a];
        } while (what!=40);  // 41 αντιστοιχεί στον χαρακτήρα : '|'  
    }
    
    chrxr[0]=255;chrxr[1]=142;chrxr[2]=63;


    if (!id) ymy=y4 ;
    xc=x4; yc=ymy;
    
    if (seleo!=NULL) {
        size=strlen(seleo);
        mem_efedr1=malloc(size+10);
         if (!mem_efedr1) {printf ("Input Alert Function - Out of memory !! \n"); free(mem0); return 0;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==souv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo[f];}}
            
            str[a]=255;
            
           
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+80) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+80) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;

                // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
    }
refresh();
yc=y4+80; xc=x4;
setcolor(5);
rectangle (xc+1,yc+3,xr-2,yc+24);
gouv=myfont[0];
text_input(inp_str, xc+2, yc+4, xr-3, yc+23, (int) orio);

    while (1) {
        SDL_PollEvent(&sdlev); 
        switch (sdlev.type) {
            case SDL_WINDOWEVENT : {refresh();  continue;}
            case SDL_KEYDOWN : SDL_FlushEvent(SDL_KEYDOWN); continue;
            case SDL_MOUSEMOTION : break;
            case SDL_MOUSEBUTTONDOWN : break;
            default : continue;}
        break ;
    }
            

mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;trik=0;
      
              
        do {
        pev = SDL_PollEvent(&sdlev);
        if (!pev) continue ;
        if (sdlev.type==SDL_MOUSEMOTION) {
            if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ; }
            mx=sdlev.motion.x ; my=sdlev.motion.y; 
            SDL_FlushEvent(SDL_MOUSEMOTION);
        }
        else if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
            
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;}
   
        else { continue ;}
        
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
        trik=0;
        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
           wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();}
        
        if (trik) {
        if  (mx>=xc && mx<xr-2 && my>=yc && my < yc+22 ) {
            qtext_input(inp_str, xc+2, yc+4, xr-3, yc+23, (int) orio);
            while (1) {
                SDL_PollEvent(&sdlev); 
                switch (sdlev.type) {
                case SDL_WINDOWEVENT : {refresh();  continue;}
                case SDL_KEYDOWN : SDL_FlushEvent(SDL_KEYDOWN); continue;
                case SDL_MOUSEMOTION : break;
                case SDL_MOUSEBUTTONDOWN : break ;
                default : continue;} 
                trik=0;
                break ;
            }
            }}

        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

fidicls(xp, y,xp+399,y+299, 65,80,225);  
FYGE :
putimage(xp,y,mem0,0);
refresh();
if(mem0) free(mem0);
if(mem_menu) free(mem_menu);
if(mem_alert) free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return((int)kyk);
}

int mytext_tonorm(unsigned char *mystr , char *normstr, int orio)
// Προσοχή το όριο σχετίζεται με τη χωρητικότητα του normstr !! 
{
unsigned char what ;
char cha,chb;
register int f=0, a=0 ;

  while (orio) {
    what=mystr[f];
    if (what<95) {
        normstr[a]=gouv[what].who; orio--;a++;}
    else if ( (what>94) && (what<164) ) {
        //if (!keyb_gr) {normstr[a]=32;a++;orio--;f++;continue;}
            if (orio<2) break;
        cha=((unico[what-95][0]/256)-255);
        chb = (unico[what-95][0] % 256);
        normstr[a]=cha; normstr[a+1]=chb; a+=2;orio-=2;}
    else if (what==200) {normstr[a]='\n' ; a++;orio--;}
    else if (what==255) break;
    f++;
  }
    normstr[a]='\0';
    return f; // Πόσοι δικοί μου χαρακτήρες μετατράπηκαν σε κανονικούς  
}

void what_time (char *str)
{
char month [12][12];
char day [7][10];
char *str1;
unsigned short int f;
char ch;

loctime=time(NULL);
diary=localtime(&loctime);

if (keyb_gr) {
strcpy (month[0],"Ιαν."); strcpy (month[1],"Φεβ."); strcpy (month[2],"Μαρ."); strcpy (month[3],"Απρ.");
strcpy (month[4],"Μάι."); strcpy (month[5],"Ιούν."); strcpy (month[6],"Ιούλ."); strcpy (month[7],"Αύγ.");
strcpy (month[8],"Σεπ."); strcpy (month[9],"Οκτ."); strcpy (month[10],"Νοε."); strcpy (month[11],"Δεκ.");

strcpy (day[1],"Δευ.");  strcpy (day[2],"Τρί."); strcpy (day[3],"Τετ."); strcpy (day[4],"Πέμ.");
strcpy (day[5],"Παρ."); strcpy (day[6],"Σαβ."); strcpy (day[0],"Κυρ.");


sprintf (str,"%s - %d %s %d - %02d:%02d" , day[diary->tm_wday] , diary->tm_mday , month[diary->tm_mon] , (diary->tm_year+1900) , diary->tm_hour , diary->tm_min);}
else
    {
    str1=asctime(diary);
    f=0;
    ch=str1[f];
    while (ch!='\0') {

        if (ch=='\n') break;
        str[f]=ch;
        f++;
        ch=str1[f];
            
        }
        str[f]='\0';
    }
}


int normtext_tomy(char *normstr , char *mystr) 
// Αν δεν υπάρχει ο δεύτερος δείκτης (*mystr) τότε, η μετατροπή θα αντικαταστήσει το κανονικό κείμενο !!
{
void *mem1 = 0;
unsigned short int ch1 ;
int a ;
register int f , i ;
char ch ;
char *str;

if (!mystr) {
mem1=malloc( strlen(normstr) +1 );
if (!mem1) {information(2-keyb_gr,0,0); return 0; }
str=mem1;}
else str = mystr ;

f=0 ; a=0 ;
ch=normstr[f];
while ( ch!='\0') {
    if (ch<0) {
        
        f++ ; ch1= ( (256*ch) + normstr[f] ) ;
            for (i=0 ; i<69 ; i++) {
                if (ch1==unico[i][0]) {
                    str[a]=unico[i][1];  a++; break;}}
        if (i==69) {str[a]=0 ; a++ ; f--; }
        f++; ch=normstr[f];continue;
         }
    else {
    if (ch=='\n') {str[a]=200; a++; f++; ch=normstr[f]; continue;}
    for(i=0;i<95;i++) {
        if (ch==souv[i].who) {
        str[a]=i ; a++ ; break;}}
    if (i==95) {str[a]=0 ; a++ ; }
    f++;ch=normstr[f];}
    
}
    
    str[a]=255;
    if (mem1) {
        for (f=0;f<=a;f++) normstr[f]=str[f];
        free(mem1);}
return a;
}

void _outfanis_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr)
{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
float neg, alfa ;

    what=str[a];
    while (what!=255 && what!=200) {
    if ( x> (xr-gouv[what].wid) ) break;
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    
    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
}    

void _outfanis_center_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr)
{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a , c ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;
float neg, alfa ;

a=xr-x+1;
if (a<myfont_wid[font]) return ;
f=0;
neg=0;
what=str[f];
if (what==255) return ;

trampa=gouv;
gouv=myfont[font];

while (what<164) {
    neg+=gouv[what].wid;
    what=str[++f];
}

if (neg>a) neg=a;
c=(a-neg)/2;
x+=c;

    a=0;
    what=str[a];
    while (what<164) {
    if ( x> (xr-gouv[what].wid) ) break;
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;

    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
    gouv=trampa;
}    

void _outfanis_colsel(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr)
{
register int f,i ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;
float neg, alfa ;

    trampa=gouv;
    gouv=myfont[font];
    what=str[a];
    while (what<164) {
    if ( x> (xr-gouv[what].wid) ) break;
    
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) {setcolor (COLOR(slxr[0],slxr[1],slxr[2])) ;  _putpixel(x+i , y+f); continue ; }

        // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)chxr[0]) + (neg * (float) bkxr[0]) );
green = (int) ( (alfa * (float)chxr[1]) + (neg * (float) bkxr[1]) );
blue = (int) ( (alfa * (float)chxr[2]) + (neg * (float) bkxr[2]) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x+i , y+f);}}
     while (f<myfont_hei[font]) {
        setcolor (COLOR(slxr[0],slxr[1],slxr[2])) ;
        for(i=0;i<gouv[what].wid;i++) { _putpixel(x+i , y+f);} f++ ;}
    x+=gouv[what].wid;
    what=str[++a];
    } 
   for (f=y; f<y+myfont_hei[font]; f++)  for (i=x; i<xr; i++)  _putpixel( i , f);
   gouv=trampa;
}    


void pro_sort_ulong (unsigned long int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_ulong(item,point,0,count-1);
}


void qui_sort_ulong (unsigned long int *item , unsigned short int *point , int left , int right)
{
    register int i,j ;
    unsigned long int x,y;
    unsigned short int y1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_ulong(item,point,left,j);
    if (i<right) qui_sort_ulong(item,point,i,right);
}

void pro_sort_24b (void *vitem,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_24b(vitem,point,0,count-1);
}


void qui_sort_24b(void *vitem , unsigned short int *point , int left , int right)
{
    struct XX4_byte {
    unsigned long int fg;
    unsigned long int sg;
    unsigned long int tg;
    };
    
    struct XX4_byte *item;
    
    register int i,j ;
    unsigned long int x[3] , y[3] ;
    unsigned short int y1;
    short int res_i , res_j ;

    item=vitem;
    i=left ; j=right ;
    x[0]=item[(left+right)/2].fg;
    x[1]=item[(left+right)/2].sg;
    x[2]=item[(left+right)/2].tg;
    
    do {
        //1st strcmp
        do {
        if (item[i].fg < x[0]) res_i=-1;
        else if (item[i].fg > x[0]) res_i=1;
        else if (item[i].sg < x[1]) res_i=-1;
        else if(item[i].sg > x[1]) res_i=1;
        else if(item[i].tg < x[2]) res_i=-1;
        else if(item[i].tg > x[2]) res_i=1;
        else res_i=0;
        } while (res_i<0 && i++ < right) ;
        
        //2nd strcmp
        do{
            if(x[0] < item[j].fg) res_j=-1;
            else if(x[0] > item[j].fg) res_j=1;
            else if(x[1] < item[j].sg) res_j=-1;
            else if(x[1] > item[j].sg) res_j=1;
            else if(x[2] < item[j].tg) res_j=-1;
            else if(x[2] > item[j].tg) res_j=1;
            else res_j=0;
            
        }while (res_j<0 && j-- > left) ;
        
        if (i<=j) {
            y[0]=item[i].fg; y[1]=item[i].sg; y[2]=item[i].tg;
            y1=point[i];
            item[i].fg = item[j].fg ; item[i].sg = item[j].sg;  item[i].tg = item[j].tg;
            point[i]=point[j];
            item[j].fg = y[0];  item[j].sg = y[1];  item[j].tg = y[2]; 
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_24b(vitem,point,left,j);
    if (i<right) qui_sort_24b(vitem,point,i,right);
}


int mytext_toclipboard (char *data)
{
unsigned long int size;
register int i,f;
unsigned char what;
char cha,chb;
void *mem;
char *clipbo;
int a;


size=0;
i=0;
what=data[i];
while (what!=255) {
    if (what<95) size++;
    else if ( (what>94) && (what<164) ) size+=2;
    else size++;
    what=data[++i];    
    }
f=i;
size+=2;
mem=malloc(size);
if (!mem) {information(2-keyb_gr,NULL,NULL); return 0;}
clipbo=mem;
a=0;
for (i=0 ;i<f ;i++) {
    what=data[i];
    if (what<95) {
        clipbo[a]=gouv[what].who; a++;}
    else if ( (what>94) && (what<164) ) {
        cha=((unico[what-95][0]/256)-255);
        chb = (unico[what-95][0] % 256);
        clipbo[a]=cha; clipbo[a+1]=chb; a+=2;}
    else if (what==200) {clipbo[a]='\n' ; a++;}
        }
clipbo[a]='\0';i=a;
a=SDL_SetClipboardText(clipbo);
if(a) { 
    i=0;
    if (keyb_gr) information (0,"Η αντιγραφή στον clipboard απέτυχε!",0);
    else information (0,"COPY to clipboard failed !" , 0);
    }
free(mem);
return i;
}


void * named_button_load(unsigned short int *ptr_orio, unsigned short int *ptr_ar, char *full_name) 
// BUTTON LOAD XVRIS ZENITY (Δίνουμε έτοιμο το πλήρες όνομα αρχείου (/home/fanisatt/Pedaba/.... και το όριο είναι μέχρι 50 .
//Μετά την επιστροφή όμως πρέπει να περαστεί το καθαρό όνομα (χωρίς path και σε μορφή δικού μου κειμένου) στην αντίστοιχη δομή των buttons).
// Επιστρέφει την αρχή της μνήμης του δημιουργημένου string , τροποποιεί το orio προς τα κάτω , υπολογίζει το ar και ενημερώνει τα στοιχεία της δομής.
{
FILE *fp ;
void *mem ;
char *memc;
unsigned short int orio, orio1 , m ;
unsigned char what;
register int f ,i ;
int pedaba[4] , pedaca , c ;
unsigned short int a ;
unsigned int size;

pedaba[0]=22111963; pedaba[1]=404976; pedaba[2]=99; pedaba[3]=167330;
c=0;
fp=fopen(full_name,"rb");
if (fp==NULL) {information (6-keyb_gr,full_name,0); return 0;}

    for (f=0 ; f<4 ; f++) {
    fread(&pedaca,4,1,fp);
    if (feof(fp)) { c=1; break; }
    if (pedaca!=pedaba[f]) {c=1;break;}}

if (c) { fclose (fp) ; return 0 ; } // PROSOXH ΨΕΥΤΙΚΟ ΑΡΧΕΙΟ .inp !!!!!!
fread(&c,2,1,fp); // Πετάω το (ar της input...)

size=1024;
mem=malloc(size);
if (!mem) {information(2-keyb_gr,0,0); fclose(fp); return 0;}
memc=mem;
orio=*ptr_orio;
i=0; orio1=0;m=0;

fread (&what,1,1,fp);
if (what==255) {fclose (fp); free(mem); return 0;}
    
do{
        
        if (what==200) { 
            if (m){ 
            if (orio1<m) orio1=m;
            m=0;
            memc[i++]=255;} 
            }
            
        else if (what<0 || what>163) break;
        
        else if (m==orio) {
                orio1=orio;m=0;
                memc[i++]=255;
                
                do{
                fread (&what,1,1,fp);
                if (feof(fp)) {rewind(fp); what=255; break;}
                } while (what!=200 && what!=255);
                if (what==255) break;
            }
        else {
            memc[i++]=what ;
            m++;
        }
        
        if (i>size-4) {
            size+=512;
            remem=realloc(mem,size);
            if (!remem) {if(mem) free(mem);}
            mem=remem;
            memc=mem;
            if (!mem) {information (2-keyb_gr,0,0); fclose(fp); return 0; }
        }
        
        fread (&what,1,1,fp);
        if (feof(fp)) {rewind(fp); break;}
    } while (what!=255) ;

    what=memc[i-1];    
    if (what!=255) {memc[i]=255;i++;if (orio1<m) orio1=m;}
    
    if (ferror(fp)) {information (6-keyb_gr,0,0);clearerr(fp) ; fclose(fp);free(mem); return 0; } else fclose (fp); 
    
*ptr_ar = (unsigned short int) i ;
*ptr_orio=orio1;
return (mem);
}


int mystrcpy (unsigned char *str1 , unsigned char * str2)
// Αποκλειστικά για δικά μου αλφαριθμητικά που τελειώνουν σε 255 - αντιγραφή από str2 sto str1  !!
{
    register int i;
    
    i=0;
    while (str2[i]!=255) {str1[i]=str2[i]; i++;}
    str1[i]=255;
    return i;
}




void _outmystr_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr, int *bbk)
{
register int f,i ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;
float neg, alfa ;

    trampa=gouv;
    gouv=myfont[font];
    what=str[a];
    while (what<164) {
    if ( x> (xri-gouv[what].wid+1) ) break;
    
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue ; 
        

// Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)xxr[0]) + (neg * (float) bbk[0]) );
green = (int) ( (alfa * (float)xxr[1]) + (neg * (float) bbk[1]) );
blue = (int) ( (alfa * (float)xxr[2]) + (neg * (float) bbk[2]) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    } 
   gouv=trampa;
}    


int _outmystr_center_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr)

// Επιστρέφει 0 αν δεν χωράει ΚΑΘΟΛΟΥ το κείμενο μέσα στο rectangle
// Επιστρέφει 1 αν το κείμενο δεν χώρεσε κατά μήκος αλλά γράφτηκε μέρος αυτού !
// Επιστρέφει 2 αν όλα πήγαν καλά !

{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a , c, dy ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;
float neg, alfa ;

a=xr-x+1;
if (a<myfont_wid[font]) return 0;
dy=yb-y+1;
if (dy<myfont_hei[font]) return 0;
dy=(dy-myfont_hei[font])/2 ;
f=0;
neg=0;
what=str[f];
if (what==255) return 0;

trampa=gouv;
gouv=myfont[font];

while (what<164) {
    neg+=gouv[what].wid;
    what=str[++f];
}

if (neg>a) neg=a;
c=(a-neg)/2;
x+=c;
y+=dy;
dy=2;

    a=0;
    what=str[a];
    while (what<164 ) {
    if ( x> (xr-gouv[what].wid) +1 ) {dy=1;break;}
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    
    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)colchxr[0]) + (neg * (float) colbkxr[0]) );
green = (int) ( (alfa * (float)colchxr[1]) + (neg * (float) colbkxr[1]) );
blue = (int) ( (alfa * (float)colchxr[2]) + (neg * (float) colbkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
    gouv=trampa;
    return (int) dy;
}    

void _field_txt_show (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr)
{
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,a,ar,elax,bh,ektos,maxline;
int diaf1,diaf2 ;
short int wrap ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , red, green, blue ;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;

float neg, alfa ;


elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

xl++ ; yt++ ; xr-- ; yb--;
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,colbkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; return; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
/*            
        if (wherp) {
        f=0;
        while (pos[wherp-f][0] != xl) f++;
        wherp-=f;
        diaf1=(pos[wherp][1]-yt);
        for (i=0;i<=ar;i++) pos[i][1]-=diaf1;}
        while (pos[cur][1]>=ektos) {
            f=wherp;
            while (pos[f][1]==yt) f++;
            wherp=f;
                for (i=0;i<=ar;i++) pos[i][1]-=bh;}
*/            
        x1=xl; y1=yt;
       
        for (a=wherp; a<ar; a++) {
        what=str[a];
            
        if (what==200) continue ;
        x1=pos[a][0]; y1=pos[a][1];
        if (y1>=ektos) break ;
        mem_int=gouv[what].where ;
        for(f=0; f<gouv[what].hei ; f++) {
        for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue;
        
        // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)colchxr[0]) + (neg * (float) colbkxr[0]) );
green = (int) ( (alfa * (float)colchxr[1]) + (neg * (float) colbkxr[1]) );
blue = (int) ( (alfa * (float)colchxr[2]) + (neg * (float) colbkxr[2]) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x1+i , y1+f);}}
        }
}


int mypolystr (unsigned char *mega , unsigned char *mikro)
// To πρώτο στρινγκ (mega) πρέπει να τελειώνει σε 255 , 254 !!
// Το δεύτερο στρινγκ πρέπει να τελειώνει σε 255.
// Επιστρέφει -1 αν το μεγάλο στρινγκ είναι κενό !
// Επιστρέφει -2 αν το μικρό στριγκ είναι κενό !
// Επιστρέφει -3 αν το μικρό στριγκ δεν βρέθηκε μέσα στο μεγάλο.
// Επιστρέφει 0 ή θετικό αριθμό ανάλογα με τη θέση του μικρού στριγκ μέσα στο μεγάλο !!
{

register int f,i ;
int b;
unsigned short int a , m , s ;

if ( mega[0]==255 ) return -1;
f=0;
while (mikro[f]!=255) f++;
if (!f) return -2;
m=f; // Μήκος μικρού στρινκγ (m)
f=i=s=0; b=-1;
    while (mega[f]!=254) {
        a=0;
        if (mega[f]!=mikro[i]) {
            while (mega[f]!=255) f++;
            b++;f++;continue;
        }
        a=1;i++;f++;
        while ( (mega[f]!=255) && (mikro[i]!=255) ) {
            if (mega[f]==mikro[i]) {
                f++;i++;a++;continue;
            }
            else{
                a=0;break;
            }
        }
        if ( (a==m) && (mega[f]==255) ) {b++;s=1;break;}
        else i=0;
    }
if (s) return b ; else return -3 ;
}


/*
int info_dbfds()
// Ενημερώνει τη δομή για το button με όλα τα ονόματα πεδίων.
{
register int i,f ;
void *mem;
unsigned short int s;
unsigned int m;
unsigned char what ;

mem=synolo_fds;
if (!mem) { mem=malloc(size_fds) ; synolo_fds=mem; }
if (!mem) {dbfds.mem_fd=0; return 0;}

m=0;s=0;
dbfds.fd_orio=0;

if (dbfinum>=0) {
    for (f=0;f<=dbfinum;f++) {
        
        if ( (m+31) > (size_fds-40) ) {
            size_fds+=256;
            mem=realloc(mem,size_fds);
            if (!mem) return 0;
            synolo_fds=mem;
        }
        
            for (i=0;i<31;i++) {
                what=ptr_pedio[f]->finame[i];
                synolo_fds[s] = what ;
                m++; s++;
                if (what==255) break;
            }
            if (dbfds.fd_orio<i) dbfds.fd_orio=i;
    }
}

if (s) {
    dbfds.fd_ar = s ;
    synolo_fds[s]=254;
}
else {
synolo_fds[0]=255;
synolo_fds[1]=254;
dbfds.fd_ar=0;
}
dbfds.mem_fd = (void*) synolo_fds;
dbfds.fd_data[0]=255;
//dbfds.fd_sorton=0;
return 1;
}
*/

void pro_sort_signedlong (long int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_signedlong(item,point,0,count-1);
}

void qui_sort_signedlong (long int *item , unsigned short int *point , int left , int right)
{
    register int i , j ;
    long int x,y;
    unsigned short int y1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_signedlong(item,point,left,j);
    if (i<right) qui_sort_signedlong(item,point,i,right);
}

void pro_sort_double (double *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_double(item,point,0,count-1);
}

void qui_sort_double (double *item , unsigned short int *point , int left , int right)
{
    register int i , j ;
    double x,y;
    unsigned short int y1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_double(item,point,left,j);
    if (i<right) qui_sort_double(item,point,i,right);
}

void pro_sort_uint (unsigned int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_uint(item,point,0,count-1);
}


void qui_sort_uint (unsigned int *item , unsigned short int *point , int left , int right)
{
    register int i,j ;
    unsigned int x,y;
    unsigned int y1;
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_uint(item,point,left,j);
    if (i<right) qui_sort_uint(item,point,i,right);
}

void pro_sort_usint (unsigned short int *item,int count)
{
    if (count<2) return;
    qui_sort_usint(item,0,count-1);
}


void qui_sort_usint (unsigned short int *item , int left , int right)
{
    register int i,j ;
    unsigned short int x,y;
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            item[i]=item[j];
            item[j]=y;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_usint(item,left,j);
    if (i<right) qui_sort_usint(item,i,right);
}


unsigned short int field_txt_scroll (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *cochxr , int *cobkxr , short int *area )
{
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,ar,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_mod , ch_scan; 
short int wrap , enbar ;
int diaf1, diaf2 ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue ;
void *mem_bar=0;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;
float neg, alfa ;


elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
//rectangle (xl,yt,xr,yb);
xl++ ; yt++ ; xr-- ; yb--;
if (xr+13>info.right)  bar=2;
if (!bar) {mem_bar=malloc((imagesize (xr+2,yt-1,xr+13,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; return (0); }
getimage (xr+2,yt-1,xr+13,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,cobkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; goto stokalo ; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
/*            
        if (wherp) {
        f=0;
        while (pos[wherp-f][0] != xl) f++;
        wherp-=f;
        diaf1=(pos[wherp][1]-yt);
        for (i=0;i<=ar;i++) pos[i][1]-=diaf1;}
        while (pos[cur][1]>=ektos) {
            f=wherp;
            while (pos[f][1]==yt) f++;
            wherp=f;
                for (i=0;i<=ar;i++) pos[i][1]-=bh;}
*/            
        x1=xl; y1=yt;
       
        for (a=wherp; a<ar; a++) {
        what=str[a];
            
        if (what==200) continue ;
        x1=pos[a][0]; y1=pos[a][1];
        if (y1>=ektos) break ;
        mem_int=gouv[what].where ;
        for(f=0; f<gouv[what].hei ; f++) {
        for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue;
        
        // Gia MENA 
        alfa =  ((float)co.rgb[0] / 255) ;
        neg = ((float)1 - alfa);
        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x1+i , y1+f);}}
        }
        x=pos[cur][0] ; y=pos[cur][1];
        
         // ELEGXOS GIA PLEYRIKH MPARA
        proyt=abs(pos[0][1]-yt) ;
        metektos = pos[ar][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (100,100,100) );  
        line (xr+2,yt,xr+2,yb);
        setcolor (COLOR (cobkxr[0],cobkxr[1],cobkxr[2]) );  
        for (f=xr+4 ; f<xr+14 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+4 ; f<xr+14 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        
enbar= (bar) ? 17 : 0;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);       
Enarjh :
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        // while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
         if (mx<info.left || my<info.top) continue ;
               
        if (mx>area[2] || mx<area[0] || my<area[1] || my>area[3]) goto stokalo ;

        continue ;
        
        case SDL_MOUSEWHEEL :
            //while (SDL_PollEvent(&sdlev)) continue ;
            if(sdlev.wheel.y > 0) { // scroll up
                    SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();

                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
                    SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (cur==ar) continue;

                    if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();
                                    
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;
            
            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) {

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }

                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();
                                    

                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (cobkxr[0],cobkxr[1],cobkxr[2]) );   
                        for (f=xr+4 ; f<xr+14 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+4 ; f<xr+14 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
            }                                       // END bar !!
            continue ;                      // END Case buttondown
        }                                     // END Button Left
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
            ch_mod=SDL_GetModState();
            
                    switch (ch_scan) { 
                        
        case SDL_SCANCODE_ESCAPE :  
                    fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) continue;
            
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            
            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
            refresh();

            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
    
            if (cur==ar) continue;

            if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;

            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }
            refresh();
                            
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                
                    if (cur==ar) continue;

                    if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();

                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :

                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        metektos = pos[ar][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (100,100,100) );   
                        line (xr+2,yt,xr+2,yb);
                        setcolor (COLOR (cobkxr[0],cobkxr[1],cobkxr[2]) );   
                        for (f=xr+4 ; f<xr+14 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+4 ; f<xr+14 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (cobkxr[0],cobkxr[1],cobkxr[2]) );  
                        for (f=xr+4 ; f<xr+14 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+4 ; f<xr+14 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;     
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_WINDOWEVENT :
        refresh(); continue;
            
        }                                    // END sdlev type 

        
    } while (!fyge);

stokalo :
if (bar==1) putimage (xr+2,yt-1,mem_bar,0);
if (mem_bar) free (mem_bar);
refresh();
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
return cur ;
}



int input_dbsearch_text(unsigned char *inp_str , short int arped)
// Επιστρέφει 1 εάν συμφωνήσει ο χρήστης !
// Αν ο arped είναι αρνητικός αριθμός πάλι θα κάνει τη δουλειά της η συνάρτηση....
{
SDL_Cursor* cursor;
struct fansouv *whouv;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start , wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int wid , hei , S ;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
int *mem_int;
unsigned short int trik ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char string[100];
char *str;
char ch;
int pev ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union {
    unsigned int ltimi ;
    unsigned char rgb[4];
} fa ;

int chxra[3] , bkxra[3] , slxra[3] ;
float neg, alfa ;

whouv=gouv;
    for (f=0;f<3;f++) {
        bkxra[f]=bkxr[f] ; chxra[f]=chxr[f] ; slxra[f]=slxr[f];
    }
    
 //do {
 //       SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
wid_box=60; 
hei_box=60;

chxr[0]=chrxr[0]=0; chxr[1]=chrxr[1]=236; chxr[2]=chrxr[2]=211;

size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ; 
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
    return 0;
}
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/File_cab_90.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0); goto FYGE;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.ico");
mem_menu= icontomem (file_1,255);
if (!mem_menu) {information (2-keyb_gr,0,0); goto FYGE;}


if (arped==-1) {
    if (keyb_gr) strcpy (string , "[Αλφαριθμητικού]");
    else strcpy (string,"Alphanumeric");
    normtext_tomy(string,0);
}
else if (arped==-2) {
    if (keyb_gr) strcpy (string , "[Ονόματος]");
    else strcpy (string,"Alphanumeric");
    normtext_tomy(string,0);
}
else if(arped==-3) {
    if (keyb_gr) strcpy (string , "[Εορτής]");
    else strcpy (string,"Alphanumeric");
    normtext_tomy(string,0);
}
else if(arped==-4) {
    if (keyb_gr) strcpy (string , "[Παγκόσμιας Ημέρας]");
    else strcpy (string,"Alphanumeric");
    normtext_tomy(string,0);
}
else if(arped==-5) {
    if (keyb_gr) strcpy (string , "[Προσωπικής Υπόμνησης]");
    else strcpy (string,"Alphanumeric");
    normtext_tomy(string,0);
}
else if (arped==-6) {
    strcpy (string , "[Εγγραφής Ημερολογίου]");
    normtext_tomy(string,0);
}
setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
//bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
//_areacls (xp+6,y+6,xp+493,y+293,20,20,60);
bkxr[0] = cbkxr[0] = 68 ;
bkxr[1] = cbkxr[1] = 70 ;
bkxr[2] = cbkxr[2] = 71 ;
_areacls (xp+6,y+6,xp+493,y+293,bkxr[0],bkxr[1],bkxr[2]);

//_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
_realputicon(x,y1,mem_menu);
//x+=18;y1+=7;
xr=xp+492;
//chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;

if (!keyb_gr) {
    strcpy (str1024,"SEARCH..");
    normtext_tomy(str1024,0);
_outmystr_center_col(bookman_18n, str1024 , xp+145, y+10, xp+360,y+32, chrxr,cbkxr);
//outnoto_col(xp+220,y+10,"Search ..",0,chrxr,cbkxr);
//chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
//outnoto_col(xp+221,y+10,"Search ..",0,chrxr,cbkxr);
setcolor (3);
line (xp+145,y+33,xp+360,y+33);
line (xp+150,y+35,xp+355,y+35);
_outmystr_center_col(notosans_16n, string ,  xp+125, y+45, xp+380,y+70, chrxr, cbkxr);
refresh();
}
else {
    strcpy (str1024,"ΑΝΑΖΗΤΗΣΗ..");
    normtext_tomy(str1024,0);
_outmystr_center_col(bookman_18n, str1024 , xp+155, y+10, xp+370, y+32, chrxr,cbkxr);
//outnoto_col(xp+200 ,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
//chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
//outnoto_col(xp+201,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
setcolor (3);
line (xp+155,y+33,xp+370,y+33);
line (xp+160,y+35,xp+365,y+35);
 _outmystr_center_col(notosans_16n, string ,  xp+135, y+45, xp+390,y+70, chrxr, cbkxr);
refresh();    
}

x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! 
i=0;f=0;

if (keyb_gr) sprintf (str1024," Εισάγετε λίγους χαρακτήρες..ότι θυμάστε..");
else sprintf (str1024," Enter Text ..");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, y4, xr,chrxr,cbkxr);

if (keyb_gr) sprintf (str1024,"..από 2 μέχρι 20 χαρακτήρες.");
else sprintf (str1024,"..up to twenty chars.");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ymy, xr,chrxr,cbkxr);

yc=y4+80; xc=x4;
setcolor(5);
rectangle (xc+1,yc+3,xr-2,yc+30);
//_areacls(xc+2,yc+4,xr-3,yc+23, 231,227,181);
bkxr[0]=231 ; bkxr[1]= 227; bkxr[2]=181;
chxr[0] = chxr[1] = chxr[2] = 0;
slxr[0]=220;slxr[1]=220;slxr[2]=0;
gouv=myfont[neohell_22n];
refresh();
text_input(inp_str, xc+2, yc+4, xr-3, yc+29, 20);

/*
    while (1) {
        SDL_PollEvent(&sdlev); 
        switch (sdlev.type) {
            case SDL_WINDOWEVENT : {refresh();  continue;}
            case SDL_KEYDOWN : SDL_FlushEvent(SDL_KEYDOWN); continue;
            case SDL_MOUSEMOTION :  break;
            case SDL_MOUSEBUTTONDOWN : break;
            default : continue;}
        break ;
    }
            
*/

mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;
fa.rgb[3]=255; fa.rgb[0]=fa.rgb[1]=fa.rgb[2]=204;      
S = fa.ltimi ;      
              
        do {
        trik=0;
        pev = SDL_PollEvent(&sdlev);
        if (!pev) continue ;
        if (sdlev.type==SDL_MOUSEMOTION) {
            if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) {continue ;}
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);}
        else if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : SDL_FlushEvent(SDL_KEYDOWN); continue;
            }}
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {
            trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;
            SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
        }
   
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
        //trik=0;
        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (180,180,0) ); // ΚΙΤΡΙΝΟ
        mem_efedr1 = mem_menu+8 + (x0*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
           fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi!=S) continue ;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (204,204,204) ) ; 
        mem_efedr1 = mem_menu+8+ (x3*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
            fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (180,180,0) );
        mem_efedr1 = mem_menu+8+ (x0*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
            fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (204,204,204) ) ; 
        mem_efedr1 = mem_menu+8+(x3*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
          fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();}
        
        if  (!trik && mx>=xc && mx<xr-2 && my>=yc && my < yc+22 ) {
            if (outmen) {
            outmen=0;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);}
            continue ;
        }
        
        if (trik) {
        if  (mx>=xc && mx<xr-2 && my>=yc && my < yc+22 ) {
            
            qtext_input(inp_str, xc+2, yc+4, xr-3, yc+29, 20);
            
            while (1) {
                SDL_PollEvent(&sdlev); 
                switch (sdlev.type) {
                case SDL_WINDOWEVENT : {refresh();  continue;}
                case SDL_KEYDOWN : SDL_FlushEvent(SDL_KEYDOWN); continue;
                case SDL_MOUSEMOTION : SDL_FlushEvent(SDL_MOUSEMOTION); break;
                case SDL_MOUSEBUTTONDOWN : break ;
                default : continue;} 
                trik=0;
                break ;
            }
            }}

        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
        SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
        if (kyk==1){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,255,255) ) ; 
        mem_efedr1 = mem_menu+8+ (x3*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
            fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); 
        SDL_Delay(200);    
        }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

if(mem0) fidicls(xp, y,xp+399,y+299, 65,80,225);  
FYGE :
if(mem0) putimage(xp,y,mem0,0);
refresh();
if(mem0) free(mem0);
if (mem_menu) free(mem_menu);
if (mem_alert) free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return((int)kyk);
}


int mystrcmp (unsigned char *str1 , unsigned char *str2)
// Επιστρέφει 0 αν είναι ίσα !!
{
register int f =0 , i =0 ;

while (str1[f] != 255) f++;
while (str2[i] != 255) i++;

if (f != i) return 1;

for (f=0 ; f<i ; f++) {
    
    if (str1[f] != str2[f]) return 1;
}

return 0;
}

void what_mytime (time_t mytime, char *str)
{
char month [12][12];
char day [7][10];
char *str1;
unsigned short int f;
char ch;

diary=localtime(&mytime);

if (keyb_gr) {
strcpy (month[0],"Ιαν."); strcpy (month[1],"Φεβ."); strcpy (month[2],"Μαρ."); strcpy (month[3],"Απρ.");
strcpy (month[4],"Μάι."); strcpy (month[5],"Ιούν."); strcpy (month[6],"Ιούλ."); strcpy (month[7],"Αύγ.");
strcpy (month[8],"Σεπ."); strcpy (month[9],"Οκτ."); strcpy (month[10],"Νοε."); strcpy (month[11],"Δεκ.");

strcpy (day[1],"Δευ.");  strcpy (day[2],"Τρί."); strcpy (day[3],"Τετ."); strcpy (day[4],"Πέμ.");
strcpy (day[5],"Παρ."); strcpy (day[6],"Σαβ."); strcpy (day[0],"Κυρ.");


sprintf (str,"%s - %d %s %d - %02d:%02d" , day[diary->tm_wday] , diary->tm_mday , month[diary->tm_mon] , (diary->tm_year+1900) , diary->tm_hour , diary->tm_min);}
else
    {
    str1=asctime(diary);
    f=0;
    ch=str1[f];
    while (ch!='\0') {

        if (ch=='\n') break;
        str[f]=ch;
        f++;
        ch=str1[f];
            
        }
        str[f]='\0';
    }
}


void show_help(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1)
// To text_help δείχνει ένα κανονικό στριγκ το οποίο η συνάρτηση  μετατρέπει σε δικό μου , στο str1024.
//Δείχνει με μικρά γράμματα κάποιο βοηθητικό κείμενο.
// Δίνουμε συντεταγμένες  xt , yt αλλά σβήνουμε το βοηθητικό κείμενο και αποκαθιστούμε οθόνη με τις συντεταγμένες xt1, yt1 !!! (Μπορεί να αλλάξουν οι αρχικές συν/νες!)
{
register int i=0,f=0 ;
unsigned char what ;
unsigned short int wid ;
int colxr[3] , colbk[3] ;
unsigned char str1025[1026];

if (mem_small) {free(mem_small) ; mem_small=0;}
normtext_tomy (text_help , str1025);
what = str1025[f];
while (what != 255) {
    i += sarial[what].wid;
    what = str1025[++f];
    }
wid=i+4;
if ( xt+wid >= info.right ) {
    if (xt>wid) xt-=wid;
    else xt=info.left+1;
} 
if (yt+15>info.bottom) return;
*xt1=xt ; *yt1=yt ;
setrgbcolor(dbred);
mem_small=malloc(imagesize(xt,yt,xt+wid-1,yt+15));
if (!mem_small) return;
colxr[0]=colxr[1]=colxr[2]=0;
colbk[0]=colbk[1]=255 ; colbk[2]=0;
getimage (xt,yt,xt+wid-1,yt+15,mem_small);
rectangle (xt,yt,xt+wid-1,yt+15);
setrgbcolor(dbhelpcol); 
for (f=yt+1 ; f<=yt+14 ; f++) {
    for (i=xt+1; i<=xt+wid-2 ; i++) {
        _putpixel (i,f);
    }
}

//setalpha (getcolor (), 255); 
//_bareacls(xt+1,yt+1,xt+wid-2,yt+14,colbk);
_outmystr_center_col(notosans_11b,str1025,xt+1,yt+1,xt+wid-2,yt+15,colxr,colbk);
refresh();
}

void hide_help(unsigned short int xt1, unsigned short int yt1)
{
    if (!mem_small) return;
    putimage (xt1,yt1,mem_small,0);
    refresh();
    free(mem_small);mem_small=0;
    return;
}


int info_dbfnt()
// Ενημερώνει τη δομή για το button (dbfnt) με όλα τα ονόματα των fonts !
{
register int i,f ;
void *mem;
unsigned short int s;
unsigned int m;
unsigned char what ;
unsigned char name[30];

mem=malloc(size_fnts) ; 
synolo_fnts=mem;
if (!mem) return 0;

m=0;s=0;
dbfnt.fn_orio=0;


    for (f=0;f<ttf;f++) {
        
        if ( (m+21) > (size_fnts-40) ) {
            size_fnts+=128;
            remem=realloc(mem,size_fnts);
            if (!remem) {if (mem) free(mem);}
            mem=remem;
            if (!mem) return 0;
            synolo_fnts=mem;
        }
            normtext_tomy (myfont_name[f] , name);
            for (i=0;i<20;i++) {
                what=name[i];
                synolo_fnts[s] = what ;
                m++; s++;
                if (what==255) break;
            }
            if (dbfnt.fn_orio<i) dbfnt.fn_orio=i;
    }


if (s) {
    dbfnt.fn_ar = s ;
    synolo_fnts[s]=254;
}
else {
synolo_fnts[0]=255;
synolo_fnts[1]=254;
dbfnt.fn_ar=0;
}
dbfnt.mem_fn = (void*) synolo_fnts;
dbfnt.fn_data[0]=255;
dbfnt.fn_sorton=1;
return 1;
}


int bmptodisk_new (char *bmpname, unsigned int size_bytes,int width, int height)
{
union picols{
unsigned int ltimi;
unsigned char xro[4];
}col;
void *mem_start ;
int *mem_int, *mem_int0;
FILE *arxeio_fp;
long int good=width * height * 4 ;
int f ,i ,bad , transp_1;
char newname[150];
bad=size_bytes-good ;
mem_start = malloc (good+8);
if (mem_start==NULL) return 0;
arxeio_fp = fopen(bmpname,"rb");
if (!arxeio_fp) {free(mem_start); return 0;}
if ((fseek(arxeio_fp,bad,SEEK_SET))) {free(mem_start); fclose(arxeio_fp); return 0;}
//good=fread(mem_start,sizeof(short int),35,arxeio_fp);
//if(good != 35) {free(mem_start); fclose(arxeio_fp); return NULL;}
mem_int0=mem_start;
*mem_int0++ = width ; 
*mem_int0++ = height; 

for(f=height;f>0;f--) {
mem_int=mem_int0;
mem_int = mem_int + ((f-1)*width);
    for (i=0;i<width;i++) { 
        fread(&col.ltimi , sizeof(int) , 1, arxeio_fp);
         //transp_1=col.xro[0]; 
         //col.ltimi = col.ltimi >> 8;
        //col.xro[3]= transp_1; 
        *mem_int++ = col.ltimi;
    }}

fclose(arxeio_fp);
bad=strlen(bmpname);
strcpy(newname,bmpname);
newname[(bad-3)]='\0';
strcat(newname,"ico");
arxeio_fp = fopen(newname,"wb");
if (!arxeio_fp) {free(mem_start); return 0;}
i= (width*height*4) + 8 ;
fwrite (mem_start,1,i,arxeio_fp);
if(ferror(arxeio_fp)) {clearerr(arxeio_fp); printf("fwrite Problem !"); free(mem_start); fclose(arxeio_fp); return 0;}
fclose(arxeio_fp);
return 1;
}


unsigned short int hlp_txt_scroll (short int font, unsigned short int cur, unsigned char *str, unsigned short int ar, short int xl , short int yt , short int xr , short int yb , int *cochxr , int *cobkxr)
{
    
SDL_Cursor* cursor;
struct fansouv *whouv;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_scan; 
int diaf1,diaf2 ;
short int wrap ,enbar ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue ;
void *mem_bar=0;
int *mem_int ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;

float neg, alfa ;

int pos[ar+1][2] ;

whouv=gouv;
gouv=myfont[font];

elax=myfont_wid[font] ;
bh=myfont_hei[font] ;

setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
rectangle (xl,yt,xr,yb);
xl++ ; yt++ ; xr-- ; yb--;

if (!bar) {mem_bar=malloc((imagesize (xr+2,yt-1,xr+13,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; gouv=whouv; return (0); }
getimage (xr+2,yt-1,xr+13,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,cobkxr);
wherp=0;
refresh();

elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            
            pos[ar][0]=x1 ; pos[ar][1]=y1;

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
        
        x1=xl; y1=yt;
     
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;

            if (!co.lor) continue;
            
            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
   

        x=pos[cur][0] ; y=pos[cur][1];
                
         // ELEGXOS GIA PLEYRIKH MPARA
        proyt=abs(pos[0][1]-yt) ;
        metektos = pos[ar][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (0,255,0) );  
        rectangle (xr+2,yt-1,xr+13,yb);
        setcolor (COLOR (0,0,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        
enbar= (bar) ? 17 : 0;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);       
Enarjh :
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        //while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
        if (mx<info.left || my<info.top) continue;
               
        if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;

        continue ;
        
        case SDL_MOUSEWHEEL :
            //while (SDL_PollEvent(&sdlev)) continue ;
            if(sdlev.wheel.y > 0) { // scroll up
                    SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    
                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
                    SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (cur==ar) continue;

                    if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    
                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                 
                    refresh();        
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) {

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }

                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    
                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    
                    refresh();
                              

                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                refresh();
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
        }   // END bar !!
        

            continue ;                      // END Case buttondown
        }
                                     // END Button Left
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
        
            
        } // Τελος Button Right
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
                        
                    switch (ch_scan) { 
                        
        case SDL_SCANCODE_ESCAPE :  
                    fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) continue;
            
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
           
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            
            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }

            refresh();
            
            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
    
            if (cur==ar) continue;

            if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;

            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }
            
            refresh();
                          
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                
                    if (cur==ar) continue;

                    if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                                        
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    
                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :

                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    
                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        metektos = pos[ar][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (0,255,0) );  
                        rectangle (xr+2,yt-1,xr+13,yb);
                        setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;     
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_WINDOWEVENT :
        refresh(); continue;
            
        }                                    // END sdlev type 

        
    } while (!fyge);

stokalo :
if (bar==1) putimage (xr+2,yt-1,mem_bar,0);
if (mem_bar) free (mem_bar);
refresh();
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
setcolor(COLOR(cobkxr[0], cobkxr[1], cobkxr[2]));
rectangle (xl,yt,xr,yb);
refresh();
gouv=whouv;
return cur ;
}



int filehelp_show(short int font, char *filename, char *helpname, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr )
// Καλείται για να εμφανίσει βοήθεια. Διαβάζει αρχείο από το δίσκο...
// Καλεί την hlp_txt_scroll

{

SDL_Cursor* cursor;
struct fansouv *whouv;
FILE *fp;
void *mem0 =0 , *mem_arrs =0, *mem_ok=0 , *mem_drag=0;
void *mem_zer=0 ;
int *mem_int ;

int cbrown[3] , chrprnt[3];
short int width , height ;
int xt1,yt1, xb1,yb1 ;
unsigned short int xt, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int ar , proenter , xok , yok , drax, dray, cur=0 ;
unsigned short int fyge , marrs , drag, yicob ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue ;
unsigned char what ;
unsigned int size;
unsigned short int orio;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned char ektos=1 , entos=0 ;
unsigned char str[60000];

sprintf(file_1,"%sHelp/%s",path_name,filename);
fp=fopen(file_1,"rb");
if (fp!=NULL) {
    i=0;
    fread (&what,1,1,fp);
    do {
        if (what<164 || what==200) {str[i++]=what ;}
        fread(&what,1,1,fp);
    }while (what!=255 && i<59999);
    str[i]=255;
    fclose(fp);
    fp=NULL;
}
else {
     information(6-keyb_gr,file_1,0);
     return 0;
}

whouv=gouv ;
ar=i;

cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
width=500 ; height=300;
size=imagesize(0,0,width-1,height-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
xt=moux ; yt1=mouy ;
while (yt1+height > info.bottom) yt1--;
yt=yt1+19;  yb=yt1+height-1;
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
_areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
xok=xt+(width-35)/2 ; yok=yb-46;
yicob = yb-9;
drax=xb-40 ; dray=yok+8;

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/All_directions.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 


_puticon(xt+1,yt1+1,mem_arrs,255);

normtext_tomy(helpname,str1024);
_outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);

_bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

refresh();
proenter=fyge=marrs=drag=0;
cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev) ) continue;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //PONTIKI MESA STO HELP_SHOW
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

        ektos=1 ;
        if (entos) continue ;
        entos=1;
        cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
        if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
        continue;
    }
    
    entos=0;
    // PONTIKI EKTOS ΒΟΗΘΕΙΑΣ
                                 
    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
            
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
        ektos=0;
    
        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
    marrs=0;
    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}


        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
    ektos=0;
    
    if (!drag) {
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);
    drag=1;
    putNOTicon(drax,dray,mem_drag);
    if (keyb_gr) show_help("Αλλαγή Διαστάσεων Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    else show_help("Change Window Dimensions", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    continue ;}
    else continue ;

    }

    if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; 
        //klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
              
       
        if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            continue ;
                              
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}


            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+height-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            refresh();
            continue ;
        }
        
        else if (drag) {
            xt1=xt;
            xb1=xb; 
            yb1=yb ;
            change_dim(xt1, yt1 , &xb1 , &yb1);
            if (xb1-xt1<200) xb1= xt1+199 ;
            if( yb1-yt1<200) yb1=yt1+199 ;
            width=xb1-xt1+1 ; height=yb1-yt1+1;

            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            refresh();
            free(mem0); mem0=0;
            
            size=imagesize(0,0,width-1,height-1);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); goto FYGE ;}

            while (yt1+height > info.bottom) yt1--;
            yt=yt1+19;  yb=yt1+height-1;
            while (xt+width>info.right) xt--;
            xb=xt+width-1 ;

            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            _areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            _puticon(xt+1,yt1+1,mem_arrs,255);

             normtext_tomy(helpname,str1024);
            _outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);


            _bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

            _puticon (xok,yok,mem_ok,255);
            
            _puticon(drax,dray,mem_drag,255);
            
            refresh();
            cur=0;
            cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
            if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
            continue ;
        }
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            
          switch (sdlev.key.keysym.scancode) {
           
            
            case SDL_SCANCODE_RETURN :     
                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                            
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 if (mem_small) hide_help(hdhlpxt , hdhlpyt);
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ

if (mem_ok) free (mem_ok);

if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return 1 ;
}



int change_hei(int xl, int yt ,int mxright , int *mybottom)
{
SDL_Cursor* cursor;
int myb , pryb ;
unsigned int size ;
void *mem1=NULL ;
register int i,f ;
int pev ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);

pryb=*mybottom;
size=imagesize (xl,yt,mxright,info.bottom);
mem1=malloc(size);
if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);return -1;}
getimage (xl,yt,mxright,pryb,mem1);
setcolor (COLOR(255,0,0)) ;  
rectangle (xl,yt,mxright,pryb);
setcolor (COLOR(255,255,0)) ;  
for (i=yt+1;i<pryb;i+=3) {for (f=xl+1 ; f<mxright; f+=3) _putpixel (f,i);}
refresh();

//do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

SDL_FlushEvent(SDL_MOUSEBUTTONUP);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);

  do {
       pev = SDL_PollEvent(&sdlev);
       //while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       //SDL_GetRelativeMouseState (&mxr , &myb);
       if (!pev) continue ;
       if (sdlev.type == SDL_MOUSEMOTION) {
       myb = sdlev.motion.y ;
       SDL_FlushEvent(SDL_MOUSEMOTION);
        }
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN ) {break;}
        else continue ;
       if (myb<=yt) continue;
       if (myb>info.bottom) myb=info.bottom;
       if (myb==pryb) continue;
        putimage (xl,yt,mem1,0); 
        pryb=myb;
        getimage (xl,yt,mxright,myb,mem1);
        setcolor (COLOR(255,0,0)) ;  
        //rectangle (xl,yt,mxr,myb);
        for(f=xl;f<=mxright;f++) {_putpixel(f,yt); _putpixel(f,myb);}
        for(i=yt+1;i<=myb;i++) {_putpixel(xl,i); _putpixel(mxright,i);}
        setcolor (COLOR(255,255,0)) ;  
        for (i=yt+1;i<myb;i+=4) {for (f=xl+1 ; f<mxright; f+=4) _putpixel (f,i);} refresh(); 
        } while (!pev || sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
       
     //do {SDL_PollEvent(&sdlev);} while (SDL_PollEvent(&sdlev));
       SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
     putimage (xl,yt,mem1,0); free(mem1);
    *mybottom=pryb ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return 1;
}

void _outfanis_colxr(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr, int *cchxr, int *cbkxr)
{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

float neg, alfa ;

    what=str[a];
    while (what!=255 && what!=200) {
    if ( x> (xr-gouv[what].wid) ) break;
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    
    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cchxr[0]) + (neg * (float) cbkxr[0]) );
green = (int) ( (alfa * (float)cchxr[1]) + (neg * (float) cbkxr[1]) );
blue = (int) ( (alfa * (float)cchxr[2]) + (neg * (float) cbkxr[2]) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
}



int button_show(void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_ghost =0 , *mem_fonter=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , c ;
unsigned char what ;
unsigned int size;
unsigned char *str , *ghost_str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
//Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
static short int fo ;
static short int fnt ;

if (!fo && !fnt) fnt=4;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
str=mem_str;
plbut=0;    
key_1=sort_1=65000;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;
unsigned char *gbut[plbut];
unsigned char krit[plbut];

mem_ghost=malloc(ar+1);
if (!mem_ghost)  {information (2-keyb_gr,0,0); goto FYGE; }
ghost_str=mem_ghost;
for (f=0; f<ar; f++) ghost_str[f]=str[f] ;

i=0; a=0; 

for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       gbut[i]=ghost_str+a;
       but[i]=mem_str+a;
       i++;
       a=f+1; 
        }
}

for (f=0;f<plbut;f++) {krit[f]=0;}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
i=orio*myfont_wid[fnt];
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-35) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 35 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);
refresh();

chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
slxr[0]=190; slxr[1]=228; slxr[2]=0;
xrep[0]=xrep[1]=xrep[2] = 0;
xrkl[0]=216 ; xrkl[1] = xrkl[2] = 0;
slkl[1]=162 ; slkl[0] = slkl[2] = 0;

_bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(5);
line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);     
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ή , εμφάνιση στοιχείων με την αρχική τους σειρά", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting or , show data by their initial order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        if (keyb_gr) show_help("Δεξί κλικ : Εισαγωγή κειμένου αναζήτησης / Αριστερό κλικ : Αναζήτηση", searx, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Right Click : Input Search Text / Left Click : Search", searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (32-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) {
                if (keyb_gr) information (0,"Διαγραφή Λίστας από τη Μνήμη !",0); else information (0,"Unload a List from the Memory!",0);
            }
            else if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -2);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; // klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            refresh();
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            if (keyb_gr) user_ans=alert(0,"Θέλετε να διαγραφεί η λίστα από τη μνήμη ;" ,"Η λίστα δεν διαγράφεται από το δίσκο !! \nΜπορείτε να τη φορτώσετε ξανά όποτε θέλετε."); else user_ans=alert(0,"Do you want the this list to be unloaded?" , "The list remains in the disk !! \n You can reload it any time you want.");
            if (user_ans != 1) continue;
            kati=ar_dom[elem];
            data[0]=255;
            fyge=1;
            // Διαγραφή κάποιου button - Μάλλον return με συγκεκριμένη τιμή
        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    refresh();
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                refresh();
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            /*
            if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
            else elem=-1;
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              } 
                              */
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }
            protyx=lines;
            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            refresh();

            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show((int) fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, xrep, xrkl, slkl );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            fo=1;
            gouv=myfont[user_ans];
            fnt = (unsigned short int) user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*myfont_wid[fnt];
            fhe=myfont_hei[fnt]+2;
            if (i <320) width =320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            
            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
        if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(5);
    line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :

                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(5);
            line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
                else elem=-1;
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                    data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }

        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if(mem_ghost) free(mem_ghost );
if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}


int mystr_show(short int font, unsigned char *mystr, char *headername, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr )
// Καλείται για να εμφανίσει όμορφα ένα κείμενο δικό μου (char *mystr). 
// Καλεί την hlp_txt_scroll

{

SDL_Cursor* cursor;
struct fansouv *whouv;
FILE *fp;
void *mem0 =0 , *mem_arrs =0, *mem_ok=0 , *mem_drag=0;
void *mem_zer=0 ;
int *mem_int ;

int cbrown[3] , chrprnt[3];
short int width , height ;
int xt1,yt1, xb1,yb1 ;
unsigned short int xt, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int ar , proenter , xok , yok , drax, dray, cur=0 ;
unsigned short int fyge , marrs , drag, yicob ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue ;
unsigned char what ;
unsigned int size;
unsigned short int orio;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned char ektos=1 , entos=0 ;
unsigned char *str ;
str=mystr;
f=0;
while (str[f]!=255) f++;
whouv=gouv ;
ar=f;

cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
width=800 ; height=600;
size=imagesize(0,0,width-1,height-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
xt=moux ; yt1=mouy ;
while (yt1+height > info.bottom) yt1--;
yt=yt1+19;  yb=yt1+height-1;
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
_areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
xok=xt+(width-35)/2 ; yok=yb-46;
yicob = yb-9;
drax=xb-40 ; dray=yok+8;

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/All_directions.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 


_puticon(xt+1,yt1+1,mem_arrs,255);

normtext_tomy(headername,str1024);
_outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);

_bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

refresh();
proenter=fyge=marrs=drag=0;
cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //PONTIKI MESA STO HELP_SHOW
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
        ektos=1;
        if (entos) continue ;
        entos=1;
        cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
        if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
        continue;
    }
    
     entos=0;
    // PONTIKI EKTOS ΒΟΗΘΕΙΑΣ
                                 
    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
            
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
        ektos=0;
    
        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
    marrs=0;
    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}


        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
    ektos=0;
    
    if (!drag) {
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);
    drag=1;
    putNOTicon(drax,dray,mem_drag);
    if (keyb_gr) show_help("Αλλαγή Διαστάσεων Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    else show_help("Change Window Dimensions", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    continue ;}
    else continue ;

    }

    if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; 
        //klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
              
       
        if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            continue ;
                              
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}


            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+height-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            refresh();
            continue ;
        }
        
        else if (drag) {
            xt1=xt;
            xb1=xb; 
            yb1=yb ;
            change_dim(xt1, yt1 , &xb1 , &yb1);
            if (xb1-xt1<200) xb1= xt1+199 ;
            if( yb1-yt1<200) yb1=yt1+199 ;
            width=xb1-xt1+1 ; height=yb1-yt1+1;

            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            refresh();
            free(mem0); mem0=0;
            
            size=imagesize(0,0,width-1,height-1);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); goto FYGE ;}

            while (yt1+height > info.bottom) yt1--;
            yt=yt1+19;  yb=yt1+height-1;
            while (xt+width>info.right) xt--;
            xb=xt+width-1 ;

            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            _areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            _puticon(xt+1,yt1+1,mem_arrs,255);

             normtext_tomy(headername,str1024);
            _outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);


            _bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

            _puticon (xok,yok,mem_ok,255);
            
            _puticon(drax,dray,mem_drag,255);
            
            refresh();
            cur=0;
            cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
            if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
            continue ;
        }
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            
          switch (sdlev.key.keysym.scancode) {
           
            
            case SDL_SCANCODE_RETURN :     
                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                            
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 if (mem_small) hide_help(hdhlpxt , hdhlpyt);
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_KEYDOWN);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ

if (mem_ok) free (mem_ok);

if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return 1 ;
}



void * mulbutton_show(void *mem_str, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_ghost =0 , *mem_fonter=0 ,*mem_epl=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , c ;
unsigned char what ;
unsigned int size;
unsigned char *str , *ghost_str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;
unsigned char *epl;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
static short int fo ;
static short int fnt ;

if (!fo && !fnt) fnt=4;
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
kati=0; // Όλα καλά ....
whouv=gouv;
gouv = myfont[fnt];
str=mem_str;
plbut=0;    
key_1=sort_1=65000;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;
unsigned char *gbut[plbut];
unsigned char krit[plbut];
mem_epl=malloc(plbut);
if (!mem_epl)  {information (2-keyb_gr,0,0); goto FYGE; }
epl=mem_epl;

mem_ghost=malloc(ar+1);
if (!mem_ghost)  {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
ghost_str=mem_ghost;
for (f=0; f<ar; f++) ghost_str[f]=str[f] ;

i=0; a=0; 

for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       gbut[i]=ghost_str+a;
       but[i]=mem_str+a;
       i++;
       a=f+1; 
        }
}

for (f=0;f<plbut;f++) {krit[f]=0; epl[f]=0;}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ;  
i=orio*myfont_wid[fnt];
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-35) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 35 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);
refresh();

chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
slxr[0]=190; slxr[1]=228; slxr[2]=0;
xrep[0]=xrep[1]=xrep[2] = 0;
xrkl[0]=216 ; xrkl[1] = xrkl[2] = 0;
slkl[1]=162 ; slkl[0] = slkl[2] = 0;

_bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(5);
line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; 
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
               
                el = (sort) ? pano-protyx : pano+protyx;
                if (!epl[ar_dom[el]]) {
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
                    refresh();}
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
            else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);refresh();}
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);refresh();}
        el = (sort) ? pano-tyx : pano+tyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
            if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
            else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);     
            refresh();}
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        el = (sort) ? pano-protyx : pano+protyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            el = (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
            refresh();}
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ή , εμφάνιση στοιχείων με την αρχική τους σειρά", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting or , show data by their initial order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        if (keyb_gr) show_help("Δεξί κλικ : Εισαγωγή κειμένου αναζήτησης / Αριστερό κλικ : Αναζήτηση", searx, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Right Click : Input Search Text / Left Click : Search", searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
           if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Πολλαπλή Επιλογή
                
                f=protyx; k=f+1 ; el=pano+bima*f;
                a=(sort) ? plbut-el : el ; a++;
                pa = ar_dom[el];
                if (!epl[pa]) { // Δεξί κλικ σε μη επιλεγμένο
                    protyx=lines;
                    do {
                        epl[pa]=1;
                        if (k) { // Χρωματίζει επιλογή (το πολύ μέχρι το pano φαίνεται , μετά συμβαίνει εσωτερικά )
                                k--;
                                _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
                                if (but[pa][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
                                else  {_outfanis_colxr(fnt, but[pa] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
                                    if (krit[pa]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                        }
                        el-=bima; pa = ar_dom[el]; a-- ;
                        if (epl[pa]) break ;
                    }while (a) ;
                }
                else {  // Δεξί κλικ σε επιλεγμένο
                    do {
                        epl[pa]=0;
                        if (k) { // Αποχρωματίζει επιλογή (το πολύ μέχρι το pano φαίνεται , μετά συμβαίνει εσωτερικά)
                                k--;
                                _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
                                if (but[pa][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                                else {_outfanis_col(fnt, but[pa] , xtepl+10 , ytepl+k*fhe , xtepr);
                                    if (krit[pa]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                            }
                        el-=bima; pa = ar_dom[el]; a-- ;
                        if (!epl[pa]) break ;
                    }while (a) ;
                }
                refresh();
                
            }
            else if (profrba) information (32-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) {
               
            }
            else if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -1);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Αριστερό Κλικ πάνω σε επιλογή - απλά αντιστρέφει !!
        
            
        //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        //SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        if (epl[ar_dom[el]])  { // Ακυρώνεται η επιλογή !
          epl[ar_dom[el]]=0;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else {_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         if (krit[ar_dom[el]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
            protyx=lines;
            refresh();
            continue ;
        }
        else {
        epl[ar_dom[el]]=1;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        continue ;}
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
          
        protyx=lines;
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
  
        }
        
        else if (profrba) {
        
        protyx=lines;
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            protyx=lines;
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!
                _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                
                k=0;
                do {
                    if (!epl[ar_dom[pa]]) {
                        _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
                        if (but[ar_dom[pa]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                        else _outfanis_col(fnt, but[ar_dom[pa]] , xtepl+10 , ytepl+k*fhe , xtepr);
                    }
                    else {
                        _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
                        if (but[ar_dom[pa]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
                        else  _outfanis_colxr(fnt, but[ar_dom[pa]] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
                        }
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            i=0;
            for (f=0;f<plbut;f++) {
                if(epl[f]) {i=1;break;}
            }
            if (!i) {free(mem_epl); mem_epl=0;}
         }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            refresh();

            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show((int) fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, xrep, xrkl, slkl );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            fo=1;
            gouv=myfont[user_ans];
            fnt = (unsigned short int) user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*myfont_wid[fnt];
            fhe=myfont_hei[fnt]+2;
            if (i <320) width =320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            xfrba = (delon) ? xdel+55 : xdel +2 ; 
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            _areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            
            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            protyx=lines;

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
         if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (!epl[ar_dom[c]]) {
            _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
            if (but[ar_dom[c]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
        }
        else {
            _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
            if (but[ar_dom[c]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
            else  _outfanis_colxr(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
            }
        if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(5);
    line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
             
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                protyx=lines;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;
                protyx=lines;
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
              
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
                protyx=lines ;
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                protyx=lines ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;
                protyx=lines ;
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                protyx=lines ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (!epl[ar_dom[c]]) {
                    _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[c]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                }
                else {
                    _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
                    if (but[ar_dom[c]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
                    else  _outfanis_colxr(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
                    }
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(5);
            line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
                protyx=lines ;
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                i=0;
                for (f=0;f<plbut;f++) {
                    if(epl[f]) {i=1;break;}
                }
                if (!i) {free(mem_epl); mem_epl=0;}
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               free(mem_epl); mem_epl=0;
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
if(kati) {
    if (mem_epl) {free(mem_epl);} 
    mem_epl=0;
}
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if(mem_ghost) free(mem_ghost );
if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return mem_epl ;
}

int choise_alert (char *str1,char *str2, short int akyro)
// akyro=0 : χωρίς δυνατότητα να μην επιλέξω κάτι από τα δυο
// Επιστρέφει -1 αν προέκυψε πρόβλημα !
// Τα str1 και str2 είναι κανονικά strings που τελειώνουν σε 0 ! Να μην υπερβαίνουν τους 1000 χαρακτήρες ! Να μην χρησιμοποιήσω τη γενική μεταβλητή char file_1 !!!!!!
// Επιστρέφτει 1 για 1η περίπτωση , 2 για 2η και 0 για άκυρο !
{

register int f,i ;
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0=0 , *mem_ni=0 , *mem_go=0 , *mem_yes=0, *mem_alert=0;
short int xt,yt,xb,yb,r1xt,r1yt,r1xb,r1yb,r2xt,r2yt,r2xb,r2yb,bo1xt,bo1yt,bo1xb,bo1yb,bo2xt,bo2yt,bo2xb,bo2yb ;
short int yesxt,yesyt,yesxb,yesyb,goxt,goyt,goxb,goyb,alext,aleyt ;
int mx,my,mx1, my1, fyge=-1;
unsigned int size ;
unsigned short int ch_scan ;
int choxr_r[3] , choxr_b[3], chobkxr[3] , boxbkxr[3] ;
unsigned char mystr[1024];
short int loop=1 , ejo=1 , yes=0, cancel=0 , bo1 , bo2 , re1, re2 , nep;

SDL_EventState(SDL_DROPFILE, SDL_DISABLE);

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
size=imagesize(0,0,599,499);
mem0=malloc(size);
if (!mem0) {information (2-keyb_gr,0,0); goto FYGE;}
xt=(info.right-info.left-599) / 2 ; yt=(info.bottom-info.top-499) / 2 ;
xb=xt+599;
yb=yt+499;
getimage(xt,yt,xb,yb,mem0);

// Yes : 54 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/Yel_ok_39.ico");
mem_yes= icontomem (file_1,255);
if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

// Cancel : 94 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/go_40.ico");
mem_go = icontomem (file_1,255);
if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }


// Ένδειξη "νι-οκ" μέσα σε κουτί 35 Χ 35
strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ni= icontomem (file_1,255);
if (mem_ni==NULL) {information(2-keyb_gr,file_1,NULL); goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/notif_1.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
choxr_r[0]=0; choxr_r[1]=0;  choxr_r[2]=0;
choxr_b[0]=255; choxr_b[1]=255;  choxr_b[2]=255;
boxbkxr[0]=253 ; boxbkxr[1]=106 ; boxbkxr[2]=2 ; 
whouv=gouv;
gouv=myfont[7];

alext=xt+(600-90)/2;
aleyt=yt+10;
r1xt=xt+12; r1yt=aleyt+100; r1xb=r1xt+500; r1yb=r1yt+160;
r2xt=r1xt; r2yt=r1yb+20; r2xb=r1xb; r2yb=r2yt+160;
bo1xt=r1xb+25; bo1yt=r1yt; bo1xb=bo1xt+40; bo1yb=bo1yt+40;
bo2xt=bo1xt; bo2yt=r2yt; bo2xb=bo2xt+40; bo2yb=bo2yt+40;
yesxt=xb-65; yesyt=yb-45; yesxb=yesxt+54; yesyb=yesyt+36;
goxt=r1xt+50; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;


_bareacls(xt,yt,xb,yb,chobkxr);
setrgbcolor (dbred) ;
rectangle (xt,yt,xb,yb);
rectangle (xt+1,yt+1,xb-1,yb-1);
setrgbcolor (dbaspro) ;
rectangle (xt+2,yt+2,xb-2,yb-2);
rectangle (xt+3,yt+3,xb-3,yb-3);
setrgbcolor (dbblack) ;
rectangle (xt+4,yt+4,xb-4,yb-4);
rectangle (xt+5,yt+5,xb-5,yb-5);
setrgbcolor (dbyel) ;
rectangle (xt+6,yt+6,xb-6,yb-6);
refresh();

normtext_tomy (str1 , mystr);
_field_txt_show (mystr , 0, r1xt+2 , r1yt+1 , r1xb-1 , r1yb-1 , 1000 , choxr_r, chobkxr);
refresh();
normtext_tomy (str2 , mystr);
_field_txt_show (mystr , 0, r2xt+2 , r2yt+1 , r2xb-1 , r2yb-1 , 1000 , choxr_b, chobkxr);
refresh();

setrgbcolor (dbblack) ;
rectangle (bo1xt,bo1yt,bo1xb,bo1yb);
rectangle (bo2xt,bo2yt,bo2xb,bo2yb);
rectangle (bo1xt+1,bo1yt+1,bo1xb-1,bo1yb-1);
rectangle (bo2xt+1,bo2yt+1,bo2xb-1,bo2yb-1);
_bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);

setrgbcolor (dbmag) ;
rectangle (r1xt , r1yt, r1xb , r1yb) ;

_puticon(alext,aleyt,mem_alert,255);
_puticon(yesxt,yesyt,mem_yes,255);
if (akyro) _puticon(goxt,goyt,mem_go,255);
_puticon(bo1xt+3,bo1yt+3,mem_ni,255);

refresh();
fyge=1 ;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
bo1=re1=nep=1; bo2=re2=0 ;

do {

if (!SDL_PollEvent(&sdlev)) continue;
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        //while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
        if (mx<xt || mx>xb || my<yt || my>yb) {
            if (ejo) continue ;
            ejo=1;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor); 
            if (!bo1 && re1) {re1=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r1xt , r1yt, r1xb , r1yb) ;
                refresh();}
            if (!bo2 && re2) {re2=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r2xt , r2yt, r2xb , r2yb) ;
                refresh();}
            continue ;
        }
        
        if (ejo) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ejo=0;
        }
        
        if (mx>bo1xt && mx<bo1xb && my>bo1yt && my<bo1yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo1) {
                if (!re2) continue ;
                re2=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r2xt , r2yt, r2xb , r2yb) ;
                refresh();
                continue ;
            }
            if (re1) continue ;
            re1=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r1xt , r1yt, r1xb , r1yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        if (mx>r1xt && mx<r1xb && my>r1yt && my<r1yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo1) {
                if (!re2) continue ;
                re2=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r2xt , r2yt, r2xb , r2yb) ;
                refresh();
                continue ;
            }
            if (re1) continue ;
            re1=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r1xt , r1yt, r1xb , r1yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        
        if (mx>bo2xt && mx<bo2xb && my>bo2yt && my<bo2yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo2) {
                if (!re1) continue ;
                re1=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r1xt , r1yt, r1xb , r1yb) ;
                refresh();
                continue ;
            }
            if (re2) continue ;
            re2=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r2xt , r2yt, r2xb , r2yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        if (mx>r2xt && mx<r2xb && my>r2yt && my<r2yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo2) {
                if (!re1) continue ;
                re1=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r1xt , r1yt, r1xb , r1yb) ;
                refresh();
                continue ;
            }
            
            if (re2) continue ;
            re2=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r2xt , r2yt, r2xb , r2yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        if (!bo1 && re1) {re1=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
            rectangle (r1xt , r1yt, r1xb , r1yb) ;
            refresh();}
        if (!bo2 && re2) {re2=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
            rectangle (r2xt , r2yt, r2xb , r2yb) ;
            refresh();}
        
        if (mx>yesxt && mx<yesxb && my>yesyt && my<yesyb) {
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (yes) continue ;
            yes=1;
            putNOTicon(yesxt,yesyt,mem_yes);
            continue ;
        }
        
        if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
        
        if (akyro) {
        
            if (mx>goxt && mx<goxb && my>goyt && my<goyb) {
                
                if (cancel) continue ;
                cancel=1;
                putNOTicon(goxt,goyt,mem_go);
                continue ;
            }
        }
        
        if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
        
        break ; // break of SDL_MOUSEMOTION
        
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx1 = sdlev.button.x ; my1= sdlev.button.y ;
            if ( (abs (mx1-mx) > 40) || (abs (my1-my) > 40) ) {
                SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
                continue ;
            }
        
            if (mx1>bo1xt && mx1<bo1xb && my1>bo1yt && my1<bo1yb) nep=1 ;
            else if (mx1>r1xt && mx1<r1xb && my1>r1yt && my1<r1yb) nep=1 ;
            else if (mx1>bo2xt && mx1<bo2xb && my1>bo2yt && my1<bo2yb) nep=2 ;
            else if (mx1>r2xt && mx1<r2xb && my1>r2yt && my1<r2yb) nep=2 ;
            else nep=0;
            
            
            switch (nep) {
                
                case 1 :
                    if (bo1) {
                        if (!re2) continue ;
                        re2=0;
                        setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                        rectangle (r2xt , r2yt, r2xb , r2yb) ;
                        refresh();
                        continue ;
                    }
                    bo2=0; bo1=1; re2=0;re1=1;
                    _bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
                    _puticon(bo1xt+3,bo1yt+3,mem_ni,255);
                    setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                    rectangle (r2xt , r2yt, r2xb , r2yb) ;
                    setrgbcolor (dbmag);
                    rectangle (r1xt , r1yt, r1xb , r1yb) ;
                    normtext_tomy (str1 , mystr);
                    _field_txt_show (mystr , 0, r1xt+2 , r1yt+1 , r1xb-1 , r1yb-1 , 1000 , choxr_r, chobkxr);
                    normtext_tomy (str2 , mystr);
                    _field_txt_show (mystr , 0, r2xt+2 , r2yt+1 , r2xb-1 , r2yb-1 , 1000 , choxr_b, chobkxr); 
                    refresh();
                    continue ;
                    
                case 2 :
                    
                    if (bo2) {
                        if (!re1) continue ;
                        re1=0;
                        setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                        rectangle (r1xt , r1yt, r1xb , r1yb) ;
                        refresh();
                        continue ;
                    }
                    bo1=0; bo2=1;re2=1;re1=0;
                    _bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
                    _puticon(bo2xt+3,bo2yt+3,mem_ni,255);
                    setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                    rectangle (r1xt , r1yt, r1xb , r1yb) ;
                    setrgbcolor (dbmag);
                    rectangle (r2xt , r2yt, r2xb , r2yb) ;
                    normtext_tomy (str1 , mystr);
                    _field_txt_show (mystr , 0, r1xt+2 , r1yt+1 , r1xb-1 , r1yb-1 , 1000 , choxr_b, chobkxr);
                    normtext_tomy (str2 , mystr);
                    _field_txt_show (mystr , 0, r2xt+2 , r2yt+1 , r2xb-1 , r2yb-1 , 1000 , choxr_r, chobkxr); 
                    refresh();
                    continue ;
                    
                case 0:
                    
                    nep = (bo1) ? 1 : 2 ;
                    break ;
                    
            }
            
            if (yes) {
                fyge = (bo1) ? 1 : 2 ;
                loop=0;
                break ;
            }
            
            if (akyro && cancel) {
                fyge=0;
                loop=0;
                break ;
            }
            
        }
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            continue ;
        }
        break ;
        
        case SDL_KEYDOWN:
            
            ch_scan=sdlev.key.keysym.scancode;
                        
            switch (ch_scan) { 
                        
                case SDL_SCANCODE_ESCAPE :  
                    if (!akyro) break;
                    fyge=0;
                    loop=0;
                    break ;
                    
                case SDL_SCANCODE_RETURN :
                
                    fyge = (bo1) ? 1 : 2 ;
                    loop=0;
                    break ;
                
            }
            
        break ;

        case SDL_WINDOWEVENT :
        refresh(); 
        continue;
    }
        
} while (loop);

FYGE:
if (mem0) {
    fidicls(xt,yt,xb,yb,55,84,112); 
    putimage (xt,yt,mem0,0);
    refresh();
    free (mem0) ;
}
if (mem_ni) free (mem_ni);
if (mem_go) free (mem_go);
if (mem_yes) free(mem_yes);
if (mem_alert) free(mem_alert);

gouv=whouv;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
SDL_FlushEvent(SDL_KEYDOWN);
return fyge;
}



void *convertinp_strstr  (short int left_right, char  *str, short int arped, unsigned short int *how_many, unsigned short int *cur)

// left_right =0 για αριστερό κλικ αλλιώς 1 για δεξιό κλικ
// Λέγοντας αριστερό κλικ εννοούμε ότι θέλουμε να ψάξει με κριτήρια που προυπάρχουν.
// Λεγοντας δεξιό κλικ εννοούμε ότι θέλουμε οπωσδήποτε να δούμε παράθυρο εισαγωγής στοιχείων...
// Ως  *str είναι το κείμενο που θέλουμε να γίνει ... ghost....
// Αριθμός πεδίου μπορεί και να μην υπάρχει (-1). Αν υπάρχει όμως τότε λαμβάνει τιμές ή εξετάζει τέλος πάντων τα κριτήρια.
// how_many ... περνάει το πόσα ταύτισε/
// cur..η πρώτη ταύτιση - θέση δρομέα.
// ΕΠΙΣΤΡΕΦΕΙ void * για τo ghost string (αυτό με 0 και 1) ή 0 !! Βασικά ενημερώνεται η καθολική μεταβλητή inp_mem_ghost !! 
//Πριν κληθεί εκ νέου η συνάρτηση πρέπει να γίνει free στην inp_mem_ghost αν έχει τιμή !!!!
{

register int i,f ,w ;
int start_point , a ;
unsigned short int sefl , dem_len , sample_len , big_len ;

unsigned char *big_text , *mybigstr ;
unsigned char what ;
void *mem=0 ;
int user_ans;

unsigned char deigma[22];

inp_mem_ghost=0;
*cur=0; *how_many=0;


mybigstr=str;
if (mybigstr[0]==255) return 0;


if (left_right) // δεξιό κλικ - θέλω να ορίσω νέο στοιχείο για εύρεση
{
    user_ans=input_dbsearch_text(normdeigma , -1);
    if (user_ans!=1) return 0;
}
else
{
    if (normdeigma[0]==255) return 0;
}
// Αριστερό κλικ ή προχωράμε με ότι υπήρχε στα κριτήρια ή εισάχθηκε πριν - άρα εντολή εύρεσης με ότι στοιχεία υπάρχουν...αν υπάρχουν...
    
if (normdeigma[0]==255) return 0;

mystrcpy(deigma,normdeigma);

//Όλα μικρά και χωρίς τόνους !! 
// To deigma είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
    
i=0;
while (deigma[i]!=255) i++;
sample_len=i; //strlen (deigma1) (χωρίς το 255)

for (f=0;f<i;f++) {
    if (keyb_gr) {
        switch (deigma[f]) {

            case 96:
            case 131:
            case 132:
            deigma[f]=95;
            break;
            
            case 133:
            case 134:
            case 135:
            case 138:
            case 141:
            deigma[f]-=36;
            break;
            
            case 101:
            case 136:
            case 137:
            deigma[f]=100;
            break;
            
            case 104:
            case 139:
            case 140:
            deigma[f]=103;
            break;
            
            case 107:
            case 108:
            case 109:
            case 142:
            case 143:
            case 144:
            deigma[f]=106;
            break;
            
            case 145 :
            case 146 :
            case 147 :
            case 148 :
            case 149 :
            case 152 :
            case 153 :
            case 154 :
            case 155 :
            deigma[f]-=35;
            break ;
            
            case 116 :
            case 150 :
            case 151 :
            deigma[f]=115;
            break;
            
            case 122 :
            case 123 :
            case 124 :
            case 156 :
            case 157 :
            case 158 :
            deigma[f]=121;
            break;
            
            case 159 :
            case 160 :
            case 161 :
            deigma[f]-=34;
            break;
            
            case 129 :
            case 162 :
            case 163 :
            deigma[f]=128;
            break;

            case 130:
            deigma[f]=119;
        }
    }
    if ( (deigma[f]>68) && (deigma[f]<95) ) deigma[f]-=26;
}


i=0;
while (mybigstr[i]!=255) i++;
big_len=i;
mem=malloc(i+1);
if (!mem) {information (2-keyb_gr,0,0); return 0;}
big_text=mem;
for (f=0;f<=i;f++) big_text[f]=mybigstr[f] ;
    
   
    //Όλα μικρά και χωρίς τόνους !
    // To big_text είναι το μεγάλο κείμενο 

    
    for (f=0;f<big_len;f++) {
        if (keyb_gr) {
            switch (big_text[f]) {

                case 96:
                case 131:
                case 132:
                big_text[f]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                big_text[f]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                big_text[f]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                big_text[f]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                big_text[f]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                big_text[f]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                big_text[f]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                big_text[f]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                big_text[f]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                big_text[f]=128;
                break;

                case 130:
                big_text[f]=119;
            }
        }
        if ( (big_text[f]>68) && (big_text[f]<95) ) big_text[f]-=26;
    }


    sefl=0; // Πόσα βρέθηκαν .... 
    i=0;
    do {
        what=big_text[i];
        f=0; w=sample_len; dem_len=0; start_point=-1; a=i ; // sample_len : μήκος δείγματος , dem_len : demanded len
        while( (what!=255) && (w) ) {
            if (what==deigma[f++]) {
                if (start_point==-1) start_point=i; 
                dem_len++; 
                w--; 
                what=big_text[++i];
                continue;
            }
            else break;
        }
            
        if (dem_len==sample_len) { 
            sefl++;  
            if (sefl==1) {*cur = (unsigned short int) start_point ;}
            for(f=start_point;f<i;f++) big_text[f]=1;
            continue ;
        }
        else { big_text[a]=0; i=a+1; }
        
    }while (what!=255);
    
   
    *how_many=sefl;
    if (sefl) {
        inp_mem_ghost=mem;
        return mem;}
    else {
        *cur=0; free(mem); inp_mem_ghost=0; 
        return 0; 
    }
}



int mystrcpy_lim (unsigned char *str1 , unsigned char * str2 , int orio)
// Αποκλειστικά για δικά μου αλφαριθμητικά που τελειώνουν σε 255 - αντιγραφή από str2 sto str1 με όριο χαρακτήρων για το str 1 (Να έχω προβλέψει ένα byte παραπάνω χωρητικότητα στο str1 !!
{
    register int i;
    
    i=0;
    while ( (str2[i]!=255) && (orio) ) {str1[i]=str2[i]; i++; orio--;}
    str1[i]=255;
    return i;
}



int smmenu_show(short int plbut, char menu[][120], char *but_name, unsigned short int moux, unsigned short int mouy )
// Βλέπε array submenu...

{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *mem_arrs =0, *mem_ok=0 ;
void *mem_zer=0 ;
int *mem_int ;
int bkxrepi[3] , chxrepi[3] , bkxrsel[3], chxrsel[3] , bkxrkef[3] , chxrkef[3] , bkxrm[3] , chxrm[3] ;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k  ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int pano, kato , telos ,sort , proenter , xok , yok , protyx ;
unsigned short int tyx ,fyge , marrs , yicob ,el ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , el_pl, proelem ,c ;
unsigned char what ;
unsigned int size;
unsigned short int orio;
Uint8 klik;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned short int xt;
int yt1;
unsigned char ektos=1;
unsigned char but[plbut][100];

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[0];
orio=0;

for (f=0 ; f<plbut ; f++) {
    normtext_tomy(menu[f],but[f]);
    i=0;
    while (but[f][i]!=255) i++;
    if (orio<i) orio=i;
}

// Sorting Procedure !!

sort=0;

bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
chxrkef[0]=255 ; chxrkef[1]=0 ; chxrkef[2]=135 ; 

chxrm[0]=chxrm[1]=chxrm[2]=0;
bkxrm[0]=bkxrm[1]=bkxrm[2]=100;

chxrepi[0]=0; chxrepi[1]=0; chxrepi[2]=255;
bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;

chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;

i=orio*myfont_wid[0];
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,(plbut*20+69));
mem0=malloc(size); //250 x ... ( όσο βγει το ύψος...προσοχή λίγο όμως...)
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
xt=moux ; yt1=mouy ;
while ( (yt1+(plbut*20+69)>info.bottom-30) && (yt1>info.top) ) yt1--;
yt=yt1+19;  yb=yt1+(plbut*20+69);
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,bkxrkef); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*20+1;
xok=xb-46 ; yok=yb-42;
yicob = yb-9;

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);


//_outfanis_center_col(0, but_name , xtepl, yt1+2, xtepr);
_outmystr_center_col(0, but_name , xtepl, yt1+2, xtepr, yt1+20, chxrkef , bkxrkef);
refresh();

_bareacls (xtepl,ytepl,xtepr,ytepl+(plbut*20),bkxrm);
_areacls(xtepl,ytepl+(plbut*20)+2,xtepr,ytepr,30,30,30);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN


a=0;k=0; a1=plbut; telos=0 ; 

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
        //_outfanis_col(0, but[a] , xtepl+10 , ytepl+k*20 , xtepr);
        _outmystr_center_col(0, but[a] , xtepl+1, ytepl+k*20, xtepr-1, ytepl+k*20+20, chxrm , bkxrm);
        a++; a1--;k++;
    
}while (a1 && k<plbut);

setcolor(5);
line(xtepl,ytepl+k*20+1,xtepr,ytepl+k*20+1);
_puticon (xok,yok,mem_ok,255);
refresh();
c=a;
kato=--a;
telos=a1;
 
proenter=fyge=marrs=0;
protyx=tyx=15; elem=proelem=el_pl=-1 ;
bima= 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 15 (το πολύ) επιλογών !!
        ektos=0;
        el_pl=-1;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
       
     tyx=(my-ytepl)/20;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 15 koytia !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                el = (sort) ? pano-protyx : pano+protyx;
                //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                refresh();
                protyx=15;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>plbut-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 15 EPILOGVN
    
    if (protyx!=15 && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        el = (sort) ? pano-protyx : pano+protyx;
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);  
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        refresh();
        protyx=15;
                }
                                 

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;

        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help(" Μετακίνηση παραθύρου ", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help(" Move the window ", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=15)  && (!proenter) && (!marrs)  ) { // Επιλογή κάποιου από τα 15 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
            _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
            _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
            protyx=15;
            refresh();
            continue ;
        }
        //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel);
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel , bkxrsel);
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
        //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
        continue ; 
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
        
       
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=elem;
                    continue ;
                              }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}


            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+(plbut*20+69);
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*20+1;
            xok=xb-46 ; yok=yb-42;
            yicob = yb-9;
            refresh();
            continue ;
        }
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            /*
          if (protyx!=15) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
            _outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
            protyx=15;
            refresh();}
            */
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                if (marrs) {
                    marrs=0;
                    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

                else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
                    
                if (tyx>=plbut-1) tyx=0; else tyx=tyx+1;
                    
                    
                    
        if (tyx==protyx) {      
            if (elem!=-1) { // Ακυρώνεται η επιλογή !
                elem=proelem=-1 ; 
            //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
            //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                protyx=15;
                refresh();
          }
          else continue ;
        }
        
       
                    
                if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl= (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_UP :
                
                if (marrs) {
                    marrs=0;
                    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

                else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
                    
                if (!tyx) tyx=plbut-1; else tyx-=1;
                    
                if (tyx==protyx) {      
                    if (elem!=-1) { // Ακυρώνεται η επιλογή !
                        elem=proelem=-1 ; 
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                        protyx=15;
                        refresh();
                }
                else continue ;
                }
                        
                if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr); 
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :              
                if (elem!=-1 || ( protyx==15 && el_pl==-1) ) {
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                kati = elem ;
                }
                else {
                    if (protyx!=15) el_pl=protyx;
                    if (el_pl!=-1) {    
                    //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
                    elem= el= el_pl; protyx=el_pl;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel , bkxrsel);
                    proelem=elem;
                    refresh(); 
                    //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
                }}
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ

if (mem_ok) free (mem_ok);

if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}


short int find_dayname (unsigned short int uyear,unsigned short int umonth,unsigned short int uday)
{
    register int i,f ;
    unsigned short int staday , stayear , mon11 ;
    unsigned int metr=0 , tel_all , arx_all , arx_1582, uolo ;
    short int mo[13];
    int fimoday ;
    short int greg ;
    
    union {
        unsigned int olo;
        unsigned char meros[4];
        unsigned short int mewo[2];
    } story ;
    
    // 4 Okt 1582 τελευταία ημέρα Ιουλιανού - Πέμπτη !
    // 15 Okt 1582 πρώτη ημέρα Γρηγοριανού - Παρασκευή !
    
    if (!uyear || uyear>2500 || !uday || !umonth) return 0;
    
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;

       
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=10;
    story.mewo[1]=1582;
    arx_all=story.olo ;
    
    
    
    story.olo=0;
    story.meros[0]=31;
    story.meros[1]=10;
    story.mewo[1]=1582;
    tel_all=story.olo ;
    
    // Και ο χρήστης έδωσε ... : 
    
    story.olo=0;
    story.meros[0]= uday;
    story.meros[1]= umonth;
    story.mewo[1]=uyear;
    uolo=story.olo ;
    
    // (Επιστρέφει με κωδικό τρόπο για τον περίεργο μήνα Οκτ 1582 - αντί για επιστροφή 2 = Δευτέρα)
    if (uolo>=arx_all && uolo<=tel_all) return 20;
    //printf ("uyear=%u, uolo=%u , arx_all=%u , tel_all=%u \n" , uyear, uolo, arx_all, tel_all);
    
    // 1-11-1582 : Δευτέρα
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=11;
    story.mewo[1]=1582;
    arx_1582=story.olo ;
       
    if (uyear>=2400) {stayear=2400; staday=7; greg=1 ; }
    else if (uyear>=2200) {stayear=2200; staday=4; greg=1 ; }
    else if (uyear>=2000) {stayear=2000; staday=7; greg=1 ;  }
    else if (uyear>=1800) {stayear=1800; staday=4; greg=1 ; }
    else if (uyear>=1600) {stayear=1600; staday=7; greg=1 ;  }
    else if (uolo>=arx_1582) {greg=1 ;stayear=1599; staday=7;}
    else if (uyear>=1200) {stayear=1200; staday=7; greg=0 ; }
    else if (uyear>=800) {stayear=800; staday=4; greg=0 ; }
    else if (uyear>=400) {stayear=400; staday=1; greg=0 ; }
    else if (uyear>=1) {stayear=1; staday=7; greg=0 ; }
   
        
    if (greg) {
        
        if (uyear%4) mo[2]=28;
        else {
            if (uyear%100) mo[2]=29;
            else {mo[2]=(uyear%400) ? 28 : 29 ;}
            }
        
        if (uday>mo[umonth]) uday=mo[umonth] ;
        
        metr=staday-1;
        mon11 = mo[1]+mo[3]+mo[4]+mo[5]+mo[6]+mo[7]+mo[8]+mo[9]+mo[10]+mo[11]+mo[12] ;
        if (stayear!=1599) {
            
            while(uyear>stayear) {
                if (stayear%4) mo[2]=28;
                else {
                    if (stayear%100) mo[2]=29;
                    else {mo[2]=(stayear%400) ? 28 : 29 ;}
                    }
                    
                metr=metr+mon11+mo[2];
                
                stayear++;
            }
            
            if (uyear%4) mo[2]=28;
            else {
                if (uyear%100) mo[2]=29;
                else {mo[2]=(uyear%400) ? 28 : 29 ;}
                }
                
            for (f=1 ; f<umonth ; f++) {
                metr += mo[f] ;
            }
            
            metr++; 
            fimoday = metr%7;
            if (!fimoday) fimoday=7; // Πρώτη ημέρα του μήνα / έτους ενδιαφέροντος μας. Κυρ=1...Σαβ=7.
    
        }
        else {  // stayear = 1599
            
            while (uyear < stayear) {
                
                if (stayear%4) mo[2]=28;
                else {
                    if (stayear%100) mo[2]=29;
                    else {mo[2]=(stayear%400) ? 28 : 29 ;}
                    }
                
                for (f=12 ; f>0 ; f--) {
                    for (i=mo[f] ; i>0 ; i--) {
                        staday = (staday-1) ? staday-1 : 7 ;
                    }
                }
                                
                stayear--;
            }
            
            if (uyear%4) mo[2]=28;
            else {
                if (uyear%100) mo[2]=29;
                else {mo[2]=(uyear%400) ? 28 : 29 ;}
                }
                
            f=12;
            while (umonth<f) {
                for (i=mo[f] ; i>0 ; i--) {
                    staday = (staday-1) ? staday-1 : 7 ;
                }
                f--;
            }
            
            for (i=mo[f] ; i>0 ; i--){
                staday = (staday-1) ? staday-1 : 7 ;
            }
            
            fimoday=staday;
        }
    }
    
    else { // IOYLIANO
        
        mo[2] = (uyear%4) ? 28 : 29 ;
       
        if (uday>mo[umonth]) uday=mo[umonth] ;
        
        metr=staday-1;
        mon11 = mo[1]+mo[3]+mo[4]+mo[5]+mo[6]+mo[7]+mo[8]+mo[9]+mo[10]+mo[11]+mo[12] ;
        
        while(uyear>stayear) {
            
            mo[2] = (stayear%4) ? 28 : 29 ;
            
            metr=metr+mon11+mo[2];
            stayear++;
        }
        
        mo[2] = (uyear%4) ? 28 : 29 ;
            
        for (f=1 ; f<umonth ; f++) {
                metr += mo[f] ;
            }
        
        metr++; 
        
    fimoday = metr%7;
    if (!fimoday) fimoday=7; // Πρώτη ημέρα του μήνα / έτους ενδιαφέροντος μας. Κυρ=1...Σαβ=7.
    
    }
    
    return (short int) fimoday ;
}



short int _show_month (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth,unsigned short int uday,unsigned short int stamonth)
{
    register int i,f ;
    unsigned short int xb,yb ;
    unsigned short int a , b ;
    int bluedy,reddy ;
    unsigned int metr=0 , tel_all , arx_all , arx_1582, uolo ;
    short int mo[13];
    short int greg , metab=0 , specmonth=0;
    unsigned short int cx[8] , cy[6] ;
    
    union {
        unsigned int olo;
        unsigned char meros[4];
        unsigned short int mewo[2];
    } story ;
    
    char mera [8][8] , monda [32][3] ;
    
    int bluechxr[3] , redchxr[3] , genchxr[3] ;
    int *piobkxr ;
    int genbkxr[3] , bkxrepi[3] ; 
    
    // 4 Okt 1582 τελευταία ημέρα Ιουλιανού - Πέμπτη !
    // 15 Okt 1582 πρώτη ημέρα Γρηγοριανού - Παρασκευή !
    
    if (!uyear || uyear>2800) return -1;
    
    bluechxr[0] = 67; bluechxr[1] = 67; bluechxr[2] = 229 ;
    bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
    redchxr[0]=160;redchxr[1]=67; redchxr[2]=67;
    genchxr[0]=genchxr[1]=genchxr[2]=67;
    genbkxr[0]=231 ; genbkxr[1]= 227; genbkxr[2]=181;
    
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=10;
    story.mewo[1]=1582;
    arx_all=story.olo ;
    
    
    
    story.olo=0;
    story.meros[0]=31;
    story.meros[1]=10;
    story.mewo[1]=1582;
    tel_all=story.olo ;
    
    // Και ο χρήστης έδωσε ... : 
    
    story.olo=0;
    story.meros[0]= uday;
    story.meros[1]= umonth;
    story.mewo[1]=uyear;
    uolo=story.olo ;
    
    // (Για  τον περίεργο μήνα Οκτ 1582 ...)
    if (uolo>=arx_all && uolo<=tel_all) { metab=1 ; specmonth=1;}
    
    // 1-11-1582 : Δευτέρα
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=11;
    story.mewo[1]=1582;
    arx_1582=story.olo ;
       
    greg = (uolo>=arx_1582) ? 1 : 0 ; 
        
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;
    
        
    if (greg) {
        
        if (uyear%4) mo[2]=28;
        else {
            if (uyear%100) mo[2]=29;
            else {mo[2]=(uyear%400) ? 28 : 29 ;}
            }
    }
    
    else { mo[2] = (uyear%4) ? 28 : 29 ; }
    
    if (keyb_gr) {

        strcpy (mera[1],"Κυρ");  strcpy (mera[2],"Δευ"); strcpy (mera[3],"Τρι"); strcpy (mera[4],"Τετ");
        strcpy (mera[5],"Πεμ"); strcpy (mera[6],"Παρ"); strcpy (mera[7],"Σαβ"); }
    else {

        strcpy (mera[1],"Sun");  strcpy (mera[2],"Mon"); strcpy (mera[3],"Tue"); strcpy (mera[4],"Wed");
        strcpy (mera[5],"Thu"); strcpy (mera[6],"Fri"); strcpy (mera[7],"Sat"); }
        
       // Στήλες Σαββατοκύριακου έγχρωμες 
    a=stamonth;
    for (f=1; f<8; f++) {
        if (a==1) reddy=f;
        else if (a==7) bluedy=f;
        a++;
        if (a==8) a=1;
        normtext_tomy (mera[f],0);
    }
    
    for (f=1; f<32; f++) {
        sprintf(monda[f],"%d",f);
        normtext_tomy (monda[f],0);
    }
    
    
    // Υπολογισμός cx - cy
    for (i=1 ; i<8 ; i++ ) { cx[i]=xt+(i-1)*60; }
    xb=xt+(i-1)*60;
    for (f=0 ; f<6;f++) { cy[f]=yt+f*25; }
    yb=yt+f*25;
    
    bareacls (xt,yt,xb,yb,genbkxr);
    
    // ΒΑΣΙΚΗ ΣΧΕΔΙΑΣΗ 
    setrgbcolor(dbaspro);
    rectangle (xt,yt,xb,yb) ;
    
    if (!metab) {
        a=0;b=stamonth;
        
        
        for (f=0 ; f<6;f++) {
            setrgbcolor(dbaspro);
            line (cx[1],cy[f],xb,cy[f]);
            for (i=1 ; i<8 ; i++ ) {
                if (!f) {
                    setrgbcolor(dbaspro);
                    line (cx[i],cy[0],cx[i],yb);
                    
                    if (bluedy==i) _outmystr_center_col (neohell_20b,mera[b],cx[i],cy[0],cx[i]+59,cy[1],bluechxr,genbkxr);
                    else if (reddy==i) _outmystr_center_col (neohell_20b,mera[b],cx[i],cy[0],cx[i]+59,cy[1],redchxr,genbkxr);
                    else _outmystr_center_col (neohell_20n,mera[b],cx[i],cy[0],cx[i]+59,cy[1],genchxr,genbkxr);
            
                    b++; if (b==8) b=1 ;
                    continue ;
                    
                }
                
                a++;
                if (a>mo[umonth]) break ;
                if (a==uday) {
                    piobkxr = bkxrepi ;
                    _bareacls (cx[i]+1, cy[f]+1, cx[i]+59, cy[f]+24, piobkxr) ; 
                }
                else {piobkxr=genbkxr;}
                
                if (i==bluedy) _outmystr_center_col (neohell_20n,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,bluechxr,piobkxr);
                else if (i==reddy) _outmystr_center_col (neohell_20n,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,redchxr,piobkxr);
                else _outmystr_center_col (neohell_20n,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,genchxr,piobkxr);
                
            }
        }
    }
    else { // KOYFH EBDOMADA
        a=0;b=2;metab=0;
        
        for (f=0 ; f<6;f++) {
            setrgbcolor(dbaspro);
            line (cx[1],cy[f],xb,cy[f]);
            for (i=1 ; i<8 ; i++ ) {
                if (!f) {
                    setrgbcolor(dbaspro);
                    line (cx[i],cy[0],cx[i],yb);
                    
                    if(i==bluedy) _outmystr_center_col (neohell_20b,mera[b],cx[i],cy[0],cx[i]+59,cy[1],bluechxr,genbkxr);
                    else if (i==reddy) _outmystr_center_col (neohell_20b,mera[b],cx[i],cy[0],cx[i]+59,cy[1], redchxr, genbkxr);
                    else _outmystr_center_col (neohell_20n,mera[b],cx[i],cy[0],cx[i]+59,cy[1],genchxr,genbkxr);
                    
                    b++; if (b==8) b=1 ;
                    continue ;
                    
                }
                
                a++;
                if ( (!metab) && (a>4 && a<19) ) continue ;
                if ( (!metab) && (a==19) ) {metab=1; a=15;}
                if (a>mo[umonth]) break ;
                if (a==uday) {
                    piobkxr = bkxrepi ;
                    _bareacls (cx[i]+1, cy[f]+1, cx[i]+59, cy[f]+24, piobkxr) ; 
                }
                else {piobkxr=genbkxr;}
                
                if (i==bluedy) _outmystr_center_col (neohell_20n,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,bluechxr,piobkxr);
                else if (i==reddy) _outmystr_center_col (neohell_20n,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,redchxr,piobkxr);
                else _outmystr_center_col (neohell_20n,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,genchxr,piobkxr);
                
            }
        }

    }
    setrgbcolor(dbaspro);
    line (cx[1], yb, xb,yb);
    return (specmonth) ;
}

void _txt_show (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr, int *colbkxr2)
{
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x1,y1,a,ar,elax,bh,ektos,maxline;
int diaf1,diaf2 ;
short int wrap ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , red, green, blue ;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;

float neg, alfa ;

elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

xl++ ; yt++ ; xr-- ; yb--;
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,colbkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=xl ; y1=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; return; }
        

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
            
        
       
        for (a=wherp; a<ar; a++) {
        what=str[a];
            
        if (what==200) continue ;
        x1=pos[a][0]; y1=pos[a][1];
        if (y1>=ektos) break ;
        mem_int=gouv[what].where ;
        for(f=0; f<gouv[what].hei ; f++) {
        for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue;

        // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)colchxr[0]) + (neg * (float) colbkxr[0]) );
green = (int) ( (alfa * (float)colchxr[1]) + (neg * (float) colbkxr[1]) );
blue = (int) ( (alfa * (float)colchxr[2]) + (neg * (float) colbkxr[2]) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x1+i , y1+f);}}
        }
        
        xr+=5;
        
        if (pos[0][1]<yt) {
            
        setrgbcolor(dbblack);
        line(xr+6,yt-1,xr+6,yt+10);
        line(xr+7,yt-1,xr+7,yt+10);
        line(xr+2,yt+3,xr+6,yt-1);
        line(xr+2,yt+4,xr+6,yt);
        line(xr+2,yt+5,xr+6,yt+1);
        line(xr+11,yt+5,xr+7,yt+1);
        line(xr+11,yt+4,xr+7,yt);
        line(xr+11,yt+3,xr+7,yt-1);
        
        }
        else {_bareacls (xr+2,yt-1,xr+10,yt+12,colbkxr2);}

                
        if (pos[ar-1][1]>=ektos) {
        setrgbcolor(dbblack);
        line(xr+6,yb-10,xr+6,yb);
        line(xr+7,yb-10,xr+7,yb);
        line(xr+2,yb-6,xr+6,yb-2);
        line(xr+2,yb-5,xr+6,yb-1);
        line(xr+2,yb-4,xr+6,yb);
        line(xr+11,yb-6,xr+7,yb-2);
        line(xr+11,yb-5,xr+7,yb-1);
        line(xr+11,yb-4,xr+7,yb);
        }
        else {_bareacls (xr+2,yb-10,xr+11,yb,colbkxr2);}
}


void pro_sort_shoint (short int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_shoint(item,point,0,count-1);
}


void qui_sort_shoint (short int *item , unsigned short int *point , int left , int right)
{
    register int i,j ;
    short int x,y;
    unsigned short int y1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_shoint(item,point,left,j);
    if (i<right) qui_sort_shoint(item,point,i,right);
}


void pedaba_calendar(short int arped)
//Με απλά λόγια, μετά τις 15 Φεβρουαρίου 1923 (για την Ελλάδα...) «εξαφανίστηκαν» 13 ημέρες και ακολούθησε η 1η Μαρτίου 1923.
{
FILE *fp;
struct tm *diar;
time_t loctim;
SDL_Cursor* cursor;
struct fansouv *trampa;
register int i,f ;
void *mem_arrs=0 , *mem_ri=0 , *mem_le=0, *mem_ok=0 , *mem_akyro=0 , *mem_flgr=0, *mem_eye=0 ,*mem_etk=0 ,*mem_et800=0 , *mem_stik=0 ;
void *mem_diakoff=0 , *mem_diak1on=0 , *mem_diak2on=0 ;
char month [13][12] , mera [8][20]  , monda [32][4] ;
unsigned short int caxt , cayt , caxb, cayb , mhnxt, mhnxb , etcaxt , etcayt , etcaxb , etcayb ;
short int mhnyt[13] , mhnyb[13] ;
int xb, yb , xt1, yt1 ,mx, my, dx, dy , mx1, my1 , y , v1, v2 , v ;
unsigned short int unameday , uday, umonth , uyear , qyear, a , b, d, startmonth, nowday, nowyear, etnowyear, nownameday, nowmonth, alyear ;
unsigned short int qday , qmonth , week , aaday ;
int bluedy , reddy ;
short int k,aa,dd,dd_1, s,pasxa,pasxa_month,pasxa_day,fidaye ;
unsigned short int cx[8] , cy[6] ;
short int mo[13];
int bluechxr[3] , redchxr[3] , genchxr[3] , bkxrkef[3] , chxrkef[3] , olobkxr[3] ,olochxr [3] ,chxrsel[3], bkxrsel[3] , gkrichxr[3], black[3] , white[3] ;
int *piobkxr , *pioxr ;
int genbkxr[3] , bkxrepi[3] ; 
unsigned short int movext , moveyt , leyearxt, leyearyt, riyearxt, riyearyt, ledayxt, ledayyt, ridayxt, ridayyt ;
unsigned short int recyearxt, recyearyt , recyearxb, recyearyb ;
unsigned short int recshmxt,recshmyt,recshmxb, recshmyb , recfullxt, recfullyt, recfullxb, recfullyb ;
unsigned short int inpyearxt, inpyearyt , inpyearxb, inpyearyb , inpmonthxt, inpmonthyt, inpmonthxb, inpmonthyb ;
unsigned short int inpdayxt, inpdayyt, inpdayxb, inpdayyb , adddaysxt, adddaysyt, adddaysxb, adddaysyb ;
unsigned short int akyroxt, akyroyt , addokxt, addokyt, putokxt, putokyt , flaggrxt, flaggryt;
unsigned short int marrs=0 , putok=0 , addok=0, akyro=0, inpyear=0, inpmonth=0, inpday=0 ;
unsigned short int panel=0 , leyear=0, leday=0, riyear=0, riday=0 ,adddays=0 , flaggr=0 ,kext, keyt ;
unsigned int size , arx_grh, uolo , first_xam, last_xam, arx_diary, tel_diary ;
short int ektos=1 , etektos=1, fyge=0 , profyge=0 , box=-1, probox=-1 , monbox=-1, promonbox=-1 , flaggryes=1;
short int nowon=1 , pronow=0 , specmonth=0 , greg=1 , c  , sbou=0 ;

unsigned char year_t[10] , month_t[6], day_t[6] , addday_t[12];
unsigned short int prosyear=0, prosmonth=0, prosday=0 ,greday=40, grenameday, gremonth,greyear;
int prosadd=0;
unsigned char *flddate=0;
void *memfld=0;
unsigned int gre_xam_1 , gre_xam_t;

union {
    unsigned int olo;
    unsigned char meros[4];
    unsigned short int mewo[2];
} story ;

int xt,yt,yyt , fide_fp ;
short int klear=0;
short int eort_recxt , eort_recyt, eort_recxb, eort_recyb ;  
short int onom_recxt , onom_recyt, onom_recxb, onom_recyb ; 
short int vel_xt,vel_yt,vel_xb,vel_yb ;

unsigned short int onom_cur=0 ,eort_cur=0, inp_cur=0;
int ix, iy, ix1, iy1 ;
int ixx =0 , iyy = 0 , ixx1 = 0 , iyy1=0 ;
unsigned char epilogeas [30] ;
short int eort_sorton=0 , name_sorton=0 , pagk_sorton=0 , pers_sorton=0;
unsigned short int eprosyear, eprosmonth, eprosday ;
unsigned char onomax[22] , eortx[22] ;
unsigned char ebutname [100] ;
unsigned char eort_at[70];
short int eyext, eyeyt, rech=0 , mati=0 ;
int md ;
char *etmonth[13];
char normonth[13][12];
union faetk {
    unsigned short int k;
    unsigned char damo[2];
} et , et1 ;
short int etmo[13] , etdmw , etdmh;
int etchxr[3] , etbkxr[3] , etyelxr[3];
unsigned short int etkx , etky ;
unsigned short int etcomo[13][2] ;
float neg , alfa ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} ba ;
short int etnote=0 , etphoto=0 , etgoto=0 , etoption=0, etsvou =0 , etwinsv=0 , etshowhide=0 , etallag=0 , etakir=0 , etdiarnote=0 , diarnote=0;
short int etnx , etny , etnx1 , etny1 ;
short int etfotx , etfoty , etfotx1, etfoty1 ;
short int etdatex , etdatey, etdatex1, etdatey1;
short int etgox , etgoy, etgox1 , etgoy1 , etmemox , etmemoy , etmemox1 , etmemoy1 ;
short int etminx , etminy , etminx1 , etminy1 , etakx , etaky , etakx1 , etaky1 ;
unsigned char sosefoto [80] , etepilegmen [44] , metabst[26] , hidepara[38] , enallagh[120] , akirepil[24] ;
int epbkxr[3];
short int opt[21];
int Rlen ;
int astrchxr[3];
char SUNrise[34] , SUNset[28];
short int sunrise_yt , sunset_yt , sunrise_xt, sunset_xt , moonphase_xt , moonphase_yt , lunarx, lunary , moontm_xt, moonri_yt , moonse_yt ;
int srise_hc , srise_mc , sset_hc , sset_mc ;
int MOON , etmoon ;
char moonstr_1[100];
char MOONrise[100] , MOONset[100];
short int MOON_ord ;
int anatcol[3] , disicol[3] ;
short int etfosx , etfosy , etskoty, etskoty1, etfosx1, etfosy1 ;
short int etskotx , etskotx1 , etselx, etsely , etselrisey , etselsety, etselx1, etsely1 ;
short int etlunarx , etlunary ;
short int et_enter ;
int et_udrgb[3];
int ejobkxr[3] , etosbkxr[3];
int notesbkxr[3] , noteschxr[3] , axnochxr[3] ;
int user_ans , Rclik ;
unsigned char alert_str [50];
unsigned char seposes[7][50] ;
short int memox , memoy , alrm=0 ;
void *mem_memo=NULL;
unsigned char perm_str[100] , perc_str[100];
void *mem_lun[28] ;
unsigned short int check_startmonth , note_werp=0 , et_werp = 0 , readnote_werp = 0;
short int there_is_note = 0 , et_is_note ;
//char diary_entry [128] ;
short int stikx, stiky , etstikx, etstiky ;
unsigned char what ;
short int Diary_u = 0 , Diary_q = 0 ;
short int diak1x , diak1y, diak2x, diak2y , DIAK1, DIAK2 , diak1b =0 , diak2b=0 ;
short int year_notes , dhide = 0 , dmetav = 0 , motn ;
unsigned short int ch_scan ;
int cyan[3];
unsigned char meravdomada[100];

    strcpy (str1024 , "Παρακαλώ Περιμένετε..");
    normtext_tomy (str1024,please_wait);

    for (f=0;f<28;f++) {mem_lun[f]=0;}
    opt[0] =  opt[2] =  opt[3] =  opt[13] =  opt[20] = 1 ;
    //size=imagesize(0,0,539,499);
    //mem0=malloc(size);
    //if (!mem0) {information (2-keyb_gr,0,0);return 0;}
    strcpy (perc_str,"- ΠΡΟΣΩΠΙΚΕΣ ΠΕΡΙΟΔΙΚΕΣ ΥΠΟΜΝΗΣΕΙΣ");
    strcpy (perm_str,"- ΠΡΟΣΩΠΙΚΕΣ ΕΤΗΣΙΕΣ/ΠΑΓΙΕΣ ΥΠΟΜΝΗΣΕΙΣ");
    strcpy (seposes[0] , "Επόμενη ημέρα : ") ;
    strcpy (seposes[1] , "Μεθεπόμενη ημέρα : ") ;
    strcpy (seposes[2] , "Σε 3 ημέρες : ") ;
    strcpy (seposes[3] , "Σε 4 ημέρες : ") ;
    strcpy (seposes[4] , "Σε 5 ημέρες : ") ;
    strcpy (seposes[5] , "Σε 6 ημέρες : ") ;
    strcpy (seposes[6] , "Σε 7 ημέρες : ") ;
    strcpy (alert_str,"- Προειδοποιήσεις");
    strcpy (SUNrise , "Ανατολή Ηλίου : ");
    strcpy (SUNset , "Δύση Ηλίου : ");
    strcpy (sosefoto , "Σώσε το Ετήσιο Ημερολόγιο ως εικόνα");
    strcpy (etepilegmen , "Επιλεγμένη Ημερομηνία");
    strcpy (metabst , "Μετάβαση ->");
    strcpy (hidepara , "Κρύψε Παράθυρο");
    strcpy (enallagh , "Δείξε / Κρύψε Υπομνήσεις και Καταχωρήσεις Ημερολογίου");
    strcpy (akirepil , "Ακύρωσε  ->");
    normtext_tomy (alert_str,0);
    normtext_tomy (sosefoto,0);
    normtext_tomy (etepilegmen,0);
    normtext_tomy (metabst,0);
    normtext_tomy (hidepara,0);
    normtext_tomy (enallagh,0);
    normtext_tomy (akirepil,0) ;
    normtext_tomy (SUNrise,0) ;
    normtext_tomy (SUNset,0) ;
    normtext_tomy (perm_str,0) ;  normtext_tomy (perc_str,0) ;
    for (f=0; f<7 ; f++) {normtext_tomy (seposes[f],0);}
    
    etdmw = 1362 ;
    etdmh = 860 ;
    qyear=0;
    et.k = et1.k = 0 ;
    etbkxr[0] = 200 ; etbkxr[1] = 227 ; etbkxr[2] = 181 ;
    etchxr[0] = etchxr[1] = etchxr[2] = 0 ;  
    etyelxr[0]=210; etyelxr[1]=210; etyelxr[2]=0;
    epbkxr[0]=0; epbkxr[1]=epbkxr[2]=255;
    trampa=gouv;
    for(f=0 ; f<3 ; f++) {
        bkxr1[f]=bkxr[f] ; chxr1[f]=chxr[f] ; slxr1[f]=slxr[f];
    }
    
    strcpy (epilogeas,"Επιλέξατε..");
    normtext_tomy (epilogeas,0);
    onomax[0]=255; eortx[0]=255;
    year_t[0]=255; month_t[0]=255; day_t[0]=255;addday_t[0]=255;
    
    story.olo=0;
    story.meros[0]=15;
    story.meros[1]=10;
    story.mewo[1]=1582;
    arx_grh=story.olo ;
    
    
    story.olo=0;
    story.meros[0]=5;
    story.meros[1]=10;
    story.mewo[1]=1582;
    first_xam=story.olo ;
        
    story.olo=0;
    story.meros[0]=14;
    story.meros[1]=10;
    story.mewo[1]=1582;
    last_xam=story.olo ;
    
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=1;
    story.mewo[1]=1;
    arx_diary=story.olo ;
    
    story.olo=0;
    story.meros[0]=31;
    story.meros[1]=12;
    story.mewo[1]=2500;
    tel_diary=story.olo ;
    
    story.olo=0;
    story.meros[0]=16;
    story.meros[1]=2;
    story.mewo[1]=1923;
    gre_xam_1=story.olo ;
    
    story.olo=0;
    story.meros[0]=28;
    story.meros[1]=2;
    story.mewo[1]=1923;
    gre_xam_t=story.olo ;
    
    //xt=(unsigned short int) info.left+3 ; yt= (unsigned short int) info.top+3 ;
    

    //getimage(xt,yt,xt+539,yt+499,mem0);
    // ΧΡΩΜΑΤΑ
    cyan[0]=0; cyan[1]=197; cyan[2]=202 ; 
    axnochxr[0] = 86 ; axnochxr[1] = 110 ; axnochxr[2] = 136 ;
    noteschxr[0] = 0 ; noteschxr[1] = 236 ; noteschxr[2] = 211 ;
    notesbkxr[0]=68 ; notesbkxr[1] = 70; notesbkxr[2] = 71 ;
    etosbkxr[0] = 156 ; etosbkxr[1] = 157 ; etosbkxr[2] = 159 ;
    ejobkxr[0]=159 ; ejobkxr[1]= 155; ejobkxr[2]=116;
    astrchxr[0]=astrchxr[2]=0 ; astrchxr[1]=221;
    bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
    chxrkef[0]=0 ; chxrkef[1]=0 ; chxrkef[2]=200 ;
    bluechxr[0] = 67; bluechxr[1] = 67; bluechxr[2] = 229 ;
    bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
    //bkxrepi[0]=98 ; bkxrepi[1]=178 ; bkxrepi[2]=98 ;
    redchxr[0]=160;redchxr[1]=67; redchxr[2]=67;
    genchxr[0]=genchxr[1]=genchxr[2]=67;
    genbkxr[0]=231 ; genbkxr[1]= 227; genbkxr[2]=181;
    
    // olobkxr[0]= 139 ; olobkxr[1]=135 ; olobkxr[2]=96 ;
    olobkxr[0]= 86 ; olobkxr[1]=77 ; olobkxr[2]=60 ;
    olochxr[0]=olochxr[1]=olochxr[2]=255;
    
    chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
    bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;
    gkrichxr[0]=25; gkrichxr[1]=90; gkrichxr[2]=15;
    black[0]=black[1]=black[2]=0;
    white[0] = white[1] = white[2] = 255 ; 
    anatcol[0] = anatcol[1] = 195 ; anatcol[2] = 0 ;
    disicol[0] = disicol[1] = disicol[2] = 200 ;
    
    if (keyb_gr) {
        strcpy (month[1],"Ιαν."); strcpy (month[2],"Φεβ."); strcpy (month[3],"Μαρ."); strcpy (month[4],"Απρ.");
        strcpy (month[5],"Μάι."); strcpy (month[6],"Ιούν."); strcpy (month[7],"Ιούλ."); strcpy (month[8],"Αύγ.");
        strcpy (month[9],"Σεπ."); strcpy (month[10],"Οκτ."); strcpy (month[11],"Νοε."); strcpy (month[12],"Δεκ.");

        strcpy (mera[1],"Κυριακή");  strcpy (mera[2],"Δευτέρα"); strcpy (mera[3],"Τρίτη"); strcpy (mera[4],"Τετάρτη");
        strcpy (mera[5],"Πέμπτη"); strcpy (mera[6],"Παρασκευή"); strcpy (mera[7],"Σάββατο"); 
        etmonth[1] = "ΙΑΝΟΥΑΡΙΟΣ" ;
        etmonth[2] = "ΦΕΒΡΟΥΑΡΙΟΣ" ;
        etmonth[3] = "ΜΑΡΤΙΟΣ" ;
        etmonth[4] = "ΑΠΡΙΛΙΟΣ" ;
        etmonth[5] = "ΜΑΙΟΣ" ;
        etmonth[6] = "ΙΟΥΝΙΟΣ" ;
        etmonth[7] = "ΙΟΥΛΙΟΣ" ;
        etmonth[8] = "ΑΥΓΟΥΣΤΟΣ" ;
        etmonth[9] = "ΣΕΠΤΕΜΒΡΙΟΣ" ;
        etmonth[10] = "ΟΚΤΩΒΡΙΟΣ" ;
        etmonth[11] = "ΝΟΕΜΒΡΙΟΣ" ;
        etmonth[12] = "ΔΕΚΕΜΒΡΙΟΣ" ;
    }
    else {
        strcpy (month[1],"Jan."); strcpy (month[2],"Feb."); strcpy (month[3],"Mar."); strcpy (month[4],"Apr.");
        strcpy (month[5],"Mai"); strcpy (month[6],"Jun"); strcpy (month[7],"July"); strcpy (month[8],"Aug.");
        strcpy (month[9],"Sep."); strcpy (month[10],"Oct."); strcpy (month[11],"Nov."); strcpy (month[12],"Dec.");

        strcpy (mera[1],"Sunday");  strcpy (mera[2],"Monday"); strcpy (mera[3],"Tuesday"); strcpy (mera[4],"Wednesday");
        strcpy (mera[5],"Thursday"); strcpy (mera[6],"Friday"); strcpy (mera[7],"Saturday"); 
        
        etmonth[1] = "JANUARY" ;
        etmonth[2] = "FEBRUARY" ;
        etmonth[3] = "MARCH" ;
        etmonth[4] = "APRIL" ;
        etmonth[5] = "MAY" ;
        etmonth[6] = "JUNE" ;
        etmonth[7] = "JULY" ;
        etmonth[8] = "AUGUST" ;
        etmonth[9] = "SEPTEMBER" ;
        etmonth[10] = "OCTOBER" ;
        etmonth[11] = "NOVEMBER" ;
        etmonth[12] = "DECEMBER" ;
    }
        
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;
    
    for (f=1; f<32; f++) {
        sprintf(monda[f],"%d",f);
        normtext_tomy (monda[f],0);
    }
    
    for (f=1; f<13 ; f++) {
        strcpy (normonth[f] , month[f]);
    }
    
    // ΣΥΝΤΕΤΑΓΜΕΝΕΣ
    
    xt=(info.left+3) ; yt=(info.top+2) ;
    if (inpbox) {
        inpx=xt; inpy=yt+23 ; inpx1=info.right-17; inpy1=inpy+200;
        movext=xt+360;
        setcolor(2);
        rectangle (movext,yt+1,inpx1-360,yt+22);
        _bareacls(movext+1,yt+2,inpx1-361,yt+21,ejobkxr);
        
        if (!keyb_gr) strcpy (str1024,"Notes") ;
        else strcpy (str1024,"Σημειώσεις");
        normtext_tomy (str1024,0);
        _outmystr_center_col (notosans_16n,str1024,movext,yt+2,inpx1-360,yt+22,chxrkef, ejobkxr);

        //setrgbcolor(dbblack);
        //line(inpx,inpy-1,inpx1,inpy-1) ;
        refresh();
    }
    else {
        inpy1=yt;
    }
    yyt=inpy1+5;
    xb=xt+539; yb=yyt+499;
    recfullxt = xt+30 ;
    leyearxt=xt+30;
    ledayxt=xt+50;
    movext=caxt=xt+6 ;
    inpyearxt=xt+93;
    //moveyt=yt+4; // Επικεφαλίδα στο yt+4 επίσης!
    recfullyt=yyt+33;
    recfullyb=recfullyt+28;
    leyearyt=riyearyt=recyearyt=mhnyb[0]=recfullyb+8;
    mhnyb[0]-=4;
    recyearxt=leyearxt+30;
    recshmxt=ledayxt+30;
    recfullxb=xb-150;
    recyearyb=recyearyt+25;
    ledayyt=ridayyt=recshmyt=recyearyb+4;
    recshmyb=recshmyt+25;
    cayt=recshmyb+9;
        
    // Υπολογισμός cx - cy
    for (i=1 ; i<8 ; i++ ) { cx[i]=caxt+(i-1)*60; }
    caxb=caxt+(i-1)*60;
    for (f=0 ; f<6;f++) { cy[f]=cayt+f*25; }
    cayb=cayt+f*25;

    ridayxt=caxb-76;
    riyearxt=caxb-56;
    recyearxb=riyearxt-4 ;
    recshmxb=ridayxt-4 ;
    inpyearxb=inpyearxt+80;
    inpmonthxt=inpyearxb+31; inpmonthxb=inpmonthxt+40;
    inpdayxt=inpmonthxb+29; inpdayxb=inpdayxt+40;
    inpyearyt = inpmonthyt = inpdayyt = cayb+66;
    // ENDIAMESA NA GRAFEI KATI....
    inpyearyb=inpmonthyb=inpdayyb=inpdayyt+25;
    putokxt=inpdayxb+7; putokyt = inpdayyt-4;
    // ENDIAMESA NA GRAFEI KATI....
    adddaysxt=xt+155; adddaysyt=inpyearyb+40;
    adddaysxb=adddaysxt+120;
    adddaysyb=adddaysyt+25;
    addokxt=adddaysxb+7; addokyt=adddaysyt-4 ;
    //yesxt = xb-90 ; yesyt = adddaysyb+17;
    
    flaggrxt=xt+244; flaggryt=adddaysyb+25;
    sunrise_yt = adddaysyb + 8 ; sunrise_xt = caxt + 65 ;
    sunset_yt = sunrise_yt + 24 ; sunset_xt = caxt + 185;
    moonphase_xt = caxt+290 ; moonphase_yt = sunrise_yt ;
    moonri_yt = moonphase_yt + 16; moontm_xt = moonphase_xt ;
    moonse_yt = moonri_yt + 16 ;
    lunarx = caxb+45 ; lunary = sunrise_yt ;
    eort_recxt=onom_recxt=xb+5; eort_recyt=yyt ;
    akyroxt = eort_recxt+50; 
    eort_recxb=onom_recxb=info.right-17; eort_recyb=yyt+250;
    onom_recyt=eort_recyb+2; onom_recyb=yb;
    stikx = xb - 40 ; stiky = yyt + 6 ;
    
    setcolor(5);
    rectangle (eort_recxt,eort_recyt,eort_recxb,eort_recyb);
    setcolor(2);
    rectangle (eort_recxt+1,eort_recyt+1,eort_recxb-1,eort_recyb-1);
    setcolor(5);
    rectangle (eort_recxt+2,eort_recyt+2,eort_recxb-2,eort_recyb-2);
    //Διαχωριστική Γραμμή Επικεφαλίδας Εορτών
    line(eort_recxt+3,eort_recyt+28,eort_recxb-3,eort_recyt+28);
    _bareacls (eort_recxt+3,eort_recyt+3,eort_recxb-3,eort_recyt+27,ejobkxr);
    sprintf(str1024,"Εορτές - Επέτειοι - Υπομνήσεις");
    normtext_tomy(str1024,0);
    _outmystr_center_col (neohell_22b,str1024,eort_recxt+4,eort_recyt+3,eort_recxb-4,eort_recyt+27,chxrkef,ejobkxr);
    
    eort_recxt+=3 ; eort_recyt+=29 ; eort_recyb-=3 ; eort_recxb-=3;
    _bareacls (eort_recxt,eort_recyt,eort_recxb,eort_recyb,genbkxr);
    
    setcolor(5);
    rectangle (onom_recxt,onom_recyt,onom_recxb,onom_recyb);
    setcolor(2);
    rectangle (onom_recxt+1,onom_recyt+1,onom_recxb-1,onom_recyb-1);
    setcolor(5);
    rectangle (onom_recxt+2,onom_recyt+2,onom_recxb-2,onom_recyb-2);
    //Διαχωριστική Γραμμή Επικεφαλίδας Ονομάτων
    line(onom_recxt+3,onom_recyt+28,onom_recxb-3,onom_recyt+28);
    _bareacls (onom_recxt+3,onom_recyt+3,onom_recxb-3,onom_recyt+27,ejobkxr);
    sprintf(str1024,"Σχετικά ονόματα");
    normtext_tomy(str1024,0);
    _outmystr_center_col (neohell_22b,str1024,onom_recxt+4,onom_recyt+3,onom_recxb-4,onom_recyt+27,chxrkef,ejobkxr);
    
    onom_recxt+=3 ; onom_recyt+=29 ; onom_recyb-=3 ; onom_recxb-=3;
    vel_xt=eort_recxb+4; vel_yt=eort_recyt; vel_xb=vel_xt+14; vel_yb=onom_recyb;
    _bareacls (onom_recxt,onom_recyt,onom_recxb,onom_recyb,genbkxr);
    _bareacls (vel_xt,vel_yt,vel_xb,vel_yb,ejobkxr);
    
    
    akyroyt = yb+5 ;
    diak2x = xt + 2 ; diak1x =  diak2x+324 ;
    diak2y = diak1y =yb+2 ;  
    // ΣΗΜΕΙΩΜΑΤΑΡΙΟ
    if (inpbox) {
        movext=xt+360;
        setcolor(5);
        line (inpx,yt+10,movext-1,yt+10);
        line (inpx,yt+10,inpx,inpy1);
        line (inpx,inpy1,inpx1,inpy1);
        line (inpx1,inpy1,inpx1,yt+10);
        line (inpx1,yt+10,inpx1-358,yt+10);
        
        setcolor(2);
        line (inpx+1,yt+11,movext-1,yt+11);
        line (inpx+1,yt+11,inpx+1,inpy1-1);
        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
        line (inpx1-1,yt+11,inpx1-358,yt+11);
        
        setcolor(5);
        line (inpx+2,yt+12,movext-1,yt+12);
        line (inpx+2,yt+12,inpx+2,inpy1-2);
        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
        line (inpx1-2,yt+12,inpx1-358,yt+12);
        
        _bareacls (inpx+3,yt+13,movext-1,inpy+3,olobkxr);
        _bareacls (inpx1-358,yt+13,inpx1-3,inpy+3,olobkxr);
        _bareacls (movext,yt+23,inpx1-358,inpy+3,olobkxr);
        _bareacls (inpx+3,inpy,inpx1-3,inpy1-3,olobkxr);

        inpx+=3 ; inpy+=3; inpx1-=3; inpy1-=3;

        gouv=myfont[notes_font];
        _txt_show (notes_str , 0, inpx, inpy ,inpx1 , inpy1 , 60000 , olochxr, notesbkxr, ejobkxr);
    }
    
    // RECTANGLES
    setcolor(5);
    rectangle (xt,yyt,xb,yb);   
    setcolor(2);
    rectangle (xt+1,yyt+1,xb-1,yb-1);
    setcolor(5);
    rectangle (xt+2,yyt+2,xb-2,yb-2);
    setcolor(5);
    line (xt+3,yyt+29,xb-3,yyt+29) ; // Γραμμή Επικεφαλίδας
    _bareacls (xt+4 , yyt+3 , xb-4 , yyt+28, ejobkxr);
    if (keyb_gr) strcpy (str1024,"Η Μ Ε Ρ Ο Λ Ο Γ Ι Ο") ;
    else strcpy (str1024,"C A L E N D A R");
    normtext_tomy (str1024,0);
    _outmystr_center_col (neohell_22b,str1024,xt+4,yyt+4,xb-4,yyt+29,chxrkef, ejobkxr);
    
    // ΓΕΜΙΣΜΑ ΚΑΤΩ ΑΠΟ ΕΠΙΚΕΦΑΛΙΔΑ ΟΛΟ ΤΟ ΧΩΡΟ
    _bareacls(xt+3,yyt+30,xb-3,yb-3,olobkxr);
    // ΠΛΗΡΗΣ ΗΜΕΡΟΜΗΝΙΑ
    setcolor(3);
    rectangle (recfullxt , recfullyt , recfullxb , recfullyb);
    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1 , genbkxr);
    
    kext=recyearxt+((recyearxb-recyearxt)/2);
    keyt=recfullyb+2;
    setcolor(COLOR(etosbkxr[0],etosbkxr[1],etosbkxr[2]));
    while(keyt<recyearyt){
        line(recyearxt,recyearyt,kext,keyt);
        line(kext,keyt,recyearxb,recyearyt);
        keyt++;
    }
    refresh();
    
    // ΗΜΕΡΟΜΗΝΙΑ ΣΥΣΤΗΜΑΤΟΣ
    loctim=time(NULL);
    diar=localtime(&loctim);
    unameday=diar->tm_wday+1;
    uday= diar->tm_mday;
    umonth = diar->tm_mon+1;
    uyear = diar->tm_year+1900;
    etnowyear = uyear ;
    strcpy (mera[0],mera[unameday]);
    
    
   
    if (uyear%4) mo[2]=28;
    else {
        if (uyear%100) mo[2]=29;
        else {mo[2]=(uyear%400) ? 28 : 29 ;}
    }
    
   
    startmonth=unameday+1;
    if (startmonth==8) startmonth=1;
    for (f=uday ; f>0 ; f--){
        startmonth--;
        if (!startmonth) startmonth=7;
    }

    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
    normtext_tomy(str1024,0);
    _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
    
    // ΕΤΟΣ - ΣΗΜΕΡΑ
    setrgbcolor(dbred);
    rectangle (recyearxt-1,recyearyt-1,recyearxb+1,recyearyb+1);
    setrgbcolor(dbaspro);
    rectangle (recyearxt,recyearyt,recyearxb,recyearyb);
    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
    sprintf (str1024,"%04u",uyear);
    normtext_tomy(str1024,0);
    _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
    
    setrgbcolor(dbaspro);
    rectangle (recshmxt,recshmyt,recshmxb,recshmyb);
    _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
    if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
    else strcpy(str1024,"TODAY");
    normtext_tomy(str1024,0);
    _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
    
    refresh() ;
    
    // ΠΑΝΕΛ
    _show_month (caxt, cayt, uyear,umonth,uday,startmonth);
    
        a=startmonth;
    for (f=1; f<8; f++) {
        if (a==1) reddy=f;
        else if (a==7) bluedy=f;
        a++;
        if (a==8) a=1;
    }
    
    eyext = eort_recxt + 4 ; eyeyt = eort_recyt-23 ;
    memox = eyext + 50 ; memoy = eyeyt ;
    
    // ΜΕΤΑΒΑΣΗ
    setrgbcolor(dbaspro);
    rectangle (caxt+20,cayb+5,caxb-20,inpyearyb+5);
    if (keyb_gr) strcpy(str1024,"ΑΝΑΖΗΤΗΣΗ");
    else strcpy(str1024,"GO TO");
    normtext_tomy(str1024,0);
    _outmystr_center_col(bookman_20n,str1024,caxt+20,cayb+7,caxb-20,cayb+32,chxrkef,olobkxr);
    setcolor (COLOR((int) bluechxr[0],(int) bluechxr[1],(int) bluechxr[2]+20 ));
    line (caxt+130,cayb+28,caxb-130,cayb+28);
    if (keyb_gr) strcpy(str1024,"Έτος");
    else strcpy(str1024,"Year");
    normtext_tomy(str1024,0);
    _outmystr_center_col(notosans_16n,str1024,inpyearxt,cayb+40,inpyearxb,cayb+62,olochxr,olobkxr);
    if (keyb_gr) strcpy(str1024,"Μήνας");
    else strcpy(str1024,"Month");
    normtext_tomy(str1024,0);
    _outmystr_center_col(notosans_16n,str1024,inpmonthxt-10 ,cayb+40,inpmonthxb+10 ,cayb+62,olochxr,olobkxr);
    if (keyb_gr) strcpy(str1024,"Ημέρα");
    else strcpy(str1024,"Day");
    normtext_tomy(str1024,0);
    _outmystr_center_col(notosans_16n,str1024,inpdayxt-15,cayb+40,inpdayxb+15,cayb+62,olochxr,olobkxr);
    
    //line (inpyearxt+10,inpyearyt-11,inpdayxb+13,inpyearyt-11);
    setrgbcolor(dbaspro);
    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
    
    
    // ΠΡΟΣΘΑΦΑΙΡΕΣΗ
    
    rectangle (caxt+20,inpyearyb+8,caxb-20,adddaysyb+5);
    if (keyb_gr) strcpy(str1024,"ΠΡΟΣΘΑΦΑΙΡΕΣΗ ΗΜΕΡΩΝ");
    else strcpy(str1024,"ADD-SUBTRACT DAYS");
    normtext_tomy(str1024,0);
    _outmystr_center_col(bookman_20n,str1024,caxt+6,inpyearyb+10,caxb-6,inpyearyb+35,chxrkef,olobkxr);
    setcolor (COLOR((int) bluechxr[0],(int) bluechxr[1],(int) bluechxr[2]+20 ));
    line (caxt+50,inpyearyb+30,caxb-50,inpyearyb+30);
    setrgbcolor(dbaspro);
    rectangle (adddaysxt,adddaysyt,adddaysxb,adddaysyb);
    
    // Γράψε Ανατολή - Δύση Ηλίου
    
    //_outmystr_col(2,SUNrise,caxt,sunrise_yt,caxb-6,astrchxr,olobkxr);
    //_outmystr_col(2,SUNset,caxt,sunset_yt,caxb-6,astrchxr,olobkxr);
    sprintf (file_1,"%sICD/sunrise_6735.ico",path_name);
    My_readimagefile (file_1,caxt,sunrise_yt+2);
    sprintf (file_1,"%sICD/sunset_6735.ico",path_name);
    My_readimagefile (file_1,caxt+110,sunrise_yt+2);
    // ΜΗΝΕΣ
    mhnxt=caxb+10;
    mhnxb=mhnxt+100;
    for (f=1; f<13 ; f++) {
        normtext_tomy (month[f],0);
        mhnyt[f]=mhnyb[f-1]+4;
        mhnyb[f] = mhnyt[f]+26;
        setrgbcolor(dbaspro);
        rectangle (mhnxt,mhnyt[f],mhnxb,mhnyb[f]);
        if (f!=umonth) _outmystr_center_col(neohell_22n,month[f],mhnxt,mhnyt[f]+1,mhnxb,mhnyb[f],olochxr,olobkxr);
        else {
            _bareacls(mhnxt+1,mhnyt[f]+1,mhnxb-1,mhnyb[f]-1,bkxrepi);
            _outmystr_center_col(neohell_22n,month[f],mhnxt,mhnyt[f]+1,mhnxb,mhnyb[f],bluechxr,bkxrepi);
        }
    }
    
    refresh();
    memfld = malloc(80400);
    if(!memfld) { information(2-keyb_gr,NULL,NULL); goto FYGE;}
    flddate=memfld;
    
    mem_etk = malloc (imagesize(0,0,60,25));
    if(!mem_etk) { information(2-keyb_gr,NULL,NULL); goto FYGE;}
    
    mem_et800 = malloc (imagesize(0,0,840,700));
    if(!mem_et800) { information(2-keyb_gr,NULL,NULL); goto FYGE;}
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_right.ico");
    mem_ri = icontomem (file_1,255);
    if (!mem_ri) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_left.ico");
    mem_le = icontomem (file_1,255);
    if (!mem_le) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // Ένα "ν" δίπλα στην δοθείσα ημερομηνία !
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Search_30.ico");
    mem_ok= icontomem (file_1,255);
    if (mem_ok==NULL) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/menu_18.ico");
    mem_akyro = icontomem (file_1,255);
    if (!mem_akyro) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/Info_25.ico");
    mem_flgr=icontomem(file_1,255);
    if (!mem_flgr) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/Memo3219.ico");
    mem_memo=icontomem(file_1,255);
    if (!mem_memo) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    /*
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/seardb.ico");
    mem_eye=icontomem(file_1,255);
    if (!mem_eye) {information (2-keyb_gr,file_1,0); goto FYGE ; }
    */

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/eye3619.ico");
    mem_eye=icontomem(file_1,255);
    if (!mem_eye) {information (2-keyb_gr,file_1,0); goto FYGE ; }
    
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Note_3422.ico");
    mem_stik=icontomem(file_1,255);
    if (!mem_stik) {information (2-keyb_gr,file_1,0); goto FYGE ; }
    
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/DIAK_OFF.ico");
    mem_diakoff=icontomem(file_1,255);
    if (!mem_diakoff) {information (2-keyb_gr,file_1,0); goto FYGE ; }
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/DIAK1_ON.ico");
    mem_diak1on=icontomem(file_1,255);
    if (!mem_diak1on) {information (2-keyb_gr,file_1,0); goto FYGE ; }
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/DIAK2_ON.ico");
    mem_diak2on=icontomem(file_1,255);
    if (!mem_diak2on) {information (2-keyb_gr,file_1,0); goto FYGE ; }
    
    for (f=0 ; f<28 ; f++) {
        sprintf (file_1,"%sICD/moon%d.ico",path_name,f);
        mem_lun[f] = icontomem(file_1,255);
        if (!mem_lun[f]) {information (2-keyb_gr,file_1,0); goto FYGE ; }
    }
    

    // ΕΙΚΟΝΙΔΙΑ
    //_puticon(movext,moveyt,mem_arrs,255);
    _puticon(leyearxt,leyearyt,mem_le,255);
    _puticon(ledayxt,ledayyt,mem_le,255);
    _puticon(riyearxt,riyearyt,mem_ri,255);
    _puticon(ridayxt,ridayyt,mem_ri,255);
    _puticon(putokxt,putokyt,mem_ok,255);
    _puticon(addokxt,addokyt,mem_ok,255);
    _puticon(akyroxt,akyroyt,mem_akyro,255);
    _puticon(flaggrxt,flaggryt,mem_flgr,255);
    
    DIAK1 = DIAK2 = 1 ;
    strcpy (str1024,"Επισημάνσεις Ημερολογίου") ; normtext_tomy(str1024,0) ; 
    _realputicon(diak2x,diak2y,mem_diak2on) ; 
    _outmystr_col(notosans_11b, str1024,diak2x+43 ,yb+7,xb,black,ejobkxr);
    strcpy (str1024,"Επισημάνσεις Υπομνήσεων") ; normtext_tomy(str1024,0) ; 
    _realputicon(diak1x,diak1y,mem_diak1on) ; 
    _outmystr_col(notosans_11b, str1024,xt+370 ,yb+7,xb,black,ejobkxr); 
    
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
    d=0;
    
    
    for (f=0;f<ar_per;f++) { 
        
        pers1[f]=pers[f].when ;

    }
        
    
    do {

                
        if ( (gyear!=uyear) || (rech) ){
            
            egiortes[0]=255; enames[0]=255;
            rech=0;
            readnote_werp = 0 ;
            year_notes = 0 ;
            if (uyear>1999) {
                
                // ΥΠΟΛΟΓΙΣΜΟΣ ΕΒΔΟΜΑΔΟΣ
                fidaye = find_dayname(uyear , 1 , 1);
                
                gsee.dm[0] = uday ; gsee.dm[1] = umonth ;
                prosee.dm[0] = prosee.dm[1] = 1 ;
                i=1;  dd=fidaye;
                week = ( (dd>=2) && (dd<=5) ) ? 1 : 0 ;
                
                 while ( gsee.tog != prosee.tog ) {
                    i++;
                    dd = (dd==7) ? 1 : dd+1 ;
                    if (dd==2) { week++ ; }
                    
                    if (prosee.dm[0] == mo[prosee.dm[1]]) {
                        
                        prosee.dm[0]=1;
                        prosee.dm[1]++;
                        
                    } else { prosee.dm[0]++; }
                }
                
                _bareacls (mhnxt , recfullyt+1 , mhnxb , mhnyt[1]-1 , olobkxr) ;
                aaday = (unsigned short int) i ;
                sprintf (str1024,"Ημέρα %dη",i);
                normtext_tomy(str1024,0);
                 _outmystr_center_col(notosans_11b, str1024,mhnxt,recfullyt+1,mhnxb,recfullyt+16,cyan,olobkxr);
                if ( (week>0) && (week<53) ) { sprintf (str1024,"ΕΒΔΟΜΑΔΑ %dη",week); }
                else if (!week) {sprintf (str1024,"Τελ.Εβδομ. %d",uyear-1);}
                else if (week==53) {
                    dd = unameday ;
                    a = uday ;
                    while (a<31) {
                        a++;
                        dd = (dd==7) ? 1 : dd+1 ;
                    }
                    dd = (dd==7) ? 1 : dd+1 ; // 1η επόμενου έτους ημέρα dd
                    a = ( (dd>=2) && (dd<=5) ) ? 1 : 0 ;
                    if (a) { sprintf (str1024,"1η Εβδομ. %d",uyear+1); }
                    else {sprintf (str1024,"ΕΒΔΟΜΑΔΑ %dη",week);}
                }
                else {str1024[0] = '\0';} // lol
                
                normtext_tomy(str1024,meravdomada);
                 _outmystr_center_col(notosans_11b, meravdomada,mhnxt,recfullyt+16,mhnxb,mhnyt[1]-1,cyan,olobkxr);
                 
                if (Diary) {
                    // Ενημέρωση πίνακα DIaryn (εξετάζει τα αρχεία δίσκου (καταχωρήσεις ημερολογίου) του έτους uyear
                    Diary_u = check_diary_notes(uyear , mo , &year_notes);
                    //sprintf(str1kb,"%s%d",Diary_path,(int) uyear);
                    //fold_p = opendir(str1kb) ;
                    if (!Diary_u) {
                        //Diary_u = 0 ;
                        // Δεν υπάρχει αρχείο-σημείωση
                        pre_diary_filename[0]=255;
                        if (there_is_note) {
                            there_is_note = 0 ;
                            _bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                        }
                    } 
                
                    if ( Diary_u ) {
                        sprintf (diary_filename,"%04d_%02d_%02d", (int) uyear , (int) umonth , (int) uday);
                        sprintf(str1kb,"%s%d/%s.dry",Diary_path,(int) uyear, diary_filename);
                        if (DIaryn[umonth][uday]) {
                            // Υπάρχει αρχείο-σημείωση
                            if (!there_is_note) {
                                _realputicon(stikx,stiky,mem_stik);
                                there_is_note=1;
                            }
                        }
                        else {
                            // Δεν υπάρχει αρχείο-σημείωση
                            pre_diary_filename[0]=255;
                            if (there_is_note) {
                                there_is_note = 0 ;
                                _bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                            }
                        }
                    }
                }
                
                sunrise_sunset(uyear,umonth,uday);
                srise_hc = srise_h ; srise_mc = srise_m ; sset_hc = sset_h; sset_mc = sset_m ;
                _bareacls(sunrise_xt,sunrise_yt,sunrise_xt+52,sunrise_yt+18,olobkxr);
                _bareacls(sunset_xt,sunset_yt,sunset_xt+52,sunset_yt+18,olobkxr);
                sprintf (str1024,"%02d:%02d",srise_hc,srise_mc);
                normtext_tomy(str1024,0);
                _outmystr_col(2,str1024,sunrise_xt,sunrise_yt,caxb-6,anatcol,olobkxr);
                sprintf (str1024,"%02d:%02d",sset_hc,sset_mc);
                normtext_tomy(str1024,0);
                _outmystr_col(2,str1024,sunset_xt,sunset_yt,caxb-6,disicol,olobkxr);
                
                MOON = moonPhases((int) uyear, (int) umonth, (int) uday) ;
                strcpy (moonstr_1,MoonStr);
                normtext_tomy(moonstr_1,str1024);
                _bareacls(moonphase_xt,moonphase_yt,lunarx-6,moonphase_yt+18,olobkxr);
                _outmystr_col(2,str1024,moonphase_xt,moonphase_yt,lunarx-6,astrchxr,olobkxr);
                 _bareacls(lunarx,lunary,lunarx+35,lunary+35,olobkxr);
                //sprintf (str1024,"%sICD/moon%d.bmp",path_name,MOON);
                //readimagefile(str1024,lunarx,lunary,0,0);
                _realputicon(lunarx,lunary,mem_lun[MOON]); refresh();
                
                moonrise_moonset(uyear,umonth,uday,mo);
                MOON_ord=moon_ord;
                strcpy (MOONrise,moonrise_txt) ; strcpy (MOONset,moonset_txt) ;
                _bareacls (moontm_xt , moonri_yt, lunarx-6 , moonse_yt+16, olobkxr);
                if (MOON_ord==1) { normtext_tomy(MOONrise,str1024); pioxr=anatcol ;}
                else { normtext_tomy(MOONset,str1024); pioxr=disicol ;}
                _outmystr_col(2,str1024,moontm_xt,moonri_yt,lunarx-6,pioxr,olobkxr);
                if (MOON_ord==1) { normtext_tomy(MOONset,str1024); pioxr=disicol ; }
                else { normtext_tomy(MOONrise,str1024); pioxr=anatcol ;}
                _outmystr_col(2,str1024,moontm_xt,moonse_yt,lunarx-6,pioxr,olobkxr);
                
                k=uyear/100 - uyear/400 - 2 ;
                aa = uyear%19 ;
                dd=(19*aa+16)%30;
                s=uyear/4;
                y=(uyear+s+dd+6)%7;  // (y : 0-6 - Κυριακή = 0 , Δευτέρα =1 ...)
                pasxa_day = dd+k-4-y ;  // April
                if (pasxa_day>30) {
                    gsee.dm[1]=pasxa_month=5;
                    pasxa_day-=30;
                    gsee.dm[0]=pasxa_day;
                    pasxa=gsee.tog;
                }
                else {
                    gsee.dm[1]=pasxa_month=4;
                    gsee.dm[0]=pasxa_day;
                    pasxa=gsee.tog;
                }
                
                               
                // Φτιάξιμο κινητών εορτών με βάση ΠΑΣΧΑ
                /*
                0 Αρχή Τριωδίου,Τελώνου και Φαρισαίου
                1 Του Ασώτου
                2 Τσικνοπέμπτη
                3 Ψυχοσάββατο Α' 
                4 Της Απόκρεω
                5 Τυροφάγου / Τυρινής
                6 Καθαρά Δευτέρα
                7 Α’ Χαιρετισμοί
                8 Αγίου Θεοδώρου Τήρωνος (θαύμα κολλύβων)
                9 Κυριακή της Ορθοδοξίας – Α’ Νηστειών
                10 Β’ Χαιρετισμοί
                11 Αγίου Γρηγορίου (Παλαμά) – Β’ Νηστειών
                12 Γ’ Νηστειών - Κυριακή της Σταυροπροσκυνήσεως
                13 Γ’ Χαιρετισμοί
                14 Δ’ Χαιρετισμοί
                15 Δ’ Νηστειών
                16 Όσιος Σάββας (εν Καλύμνω)
                17 Σάββατο του Λαζάρου
                18 Κυριακή των Βαίων
                19 Μεγάλη Δευτέρα , Ιωσήφ του Παγκάλου
                20 Μεγάλη Τρίτη , Δέκα Παρθένων
                21 Μεγάλη Τετάρτη , Της αλειψάσης τον Κύριον μύρω
                22 Μεγάλη Πέμπτη , Μυστικός Δείπνος
                23 Μεγάλη Παρασκευή , Τα Άγια Πάθη
                24 Μεγάλο Σάββατο , Η ταφή του Κυρίου
                25 ΑΓΙΟ ΠΑΣΧΑ
                26 Αγίων Ραφαήλ,Νικολάου,Ειρήνης (Μυτιλήνης)
                27 Άγιοι Εκατόν εβδομήντα εννιά Οσιομάρτυρες Νταού Πεντέλης
                28 Αγίων Θεοχάρους και Αποστόλου
                29 Ζωοδόχου Πηγής
                30 Του Θωμά – Αγίου Νικήτα (ιερόμαρτυρα)
                31 Των Μυροφόρων
                32 Του Παραλύτου
                33 Της Αναλήψεως
                34 Ψυχοσάββατο Β' 
                35 Πεντηκοστή
                36 Αγ. Πνεύματος
                37 Αγίων Πάντων
                */
                
                for (f=0; f<38; f++) {
                    ksee[f].tog=pasxa;
                    if (an_pasx[f]<0) {
                        for (i=-an_pasx[f] ; i>0 ; i--) {
                            if (ksee[f].dm[0]==1) {
                                ksee[f].dm[1]--;
                                ksee[f].dm[0] = mo [ksee[f].dm[1]];
                            }
                            else ksee[f].dm[0]--;
                        }
                    }
                    else {
                        for (i=0; i<an_pasx[f]; i++) {
                             if (ksee[f].dm[0]==mo[ ksee[f].dm[1] ]) {
                                 ksee[f].dm[1]++;
                                 ksee[f].dm[0] = 1;
                            }
                            else ksee[f].dm[0]++;
                        }
                        
                    }
                }
                // Αγ. Γεωργίου - 23 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 23 Απρ αλλιώς ΠΑΣΧΑ+1  !
                f=38;
                if (pasxa_day>=23 || pasxa_month==5) {
                        ksee[f].tog=pasxa;
                        if (ksee[f].dm[0]==30) {
                            ksee[f].dm[1]++;
                            ksee[f].dm[0] = 1;
                    }
                    else  ksee[f].dm[0]++;
                }
                else { ksee[f].dm[0]=23 ; ksee[f].dm[1]=4 ;}
                
                // Κυριακή Προπατόρων - 11 Δεκ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 11 Δεκ
                f=39;
                ksee[f].dm[1]=12 ;
                dd = find_dayname(uyear , 12 , 1);
                for (i=2 ; i<12 ; i++) {
                    dd = (dd==7) ? 1 : dd+1 ;
                }
                if (dd!=1) {
                for (i=12 ; i<25; i++) { 
                    dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { ksee[f].dm[0]=i ; break ; }
                }}
                else {ksee[f].dm[0]=11 ;}
                
                // Αγία Χλόη - 13 Φεβ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 13 Φεβ
                f=40;
                ksee[f].dm[1]=2 ;
                dd = find_dayname(uyear , 2 , 1);
                for (i=2 ; i<14; i++) { dd = (dd==7) ? 1 : dd+1 ; }
                if (dd!=1) {
                for (i=14 ; i<25; i++) { 
                    dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { ksee[f].dm[0]=i ; break ; }
                }}
                else {ksee[f].dm[0]=13 ;}

                // Αγίου Μάρκου 25 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 25 Απρ αλλιώς ΠΑΣΧΑ+2  ;
                f=41;
                if (pasxa_day>=23 || pasxa_month==5) {
                        ksee[f].tog=pasxa;
                        if (ksee[f].dm[0]==29) {
                            ksee[f].dm[1]++;
                            ksee[f].dm[0] = 1;
                    }
                    else  ksee[f].dm[0]+=2;
                }
                else { ksee[f].dm[0]=25 ; ksee[f].dm[1]=4 ;}

                // Μητέρας
                
                dd = find_dayname(uyear , 5 , 1);
                i = (dd==1) ? 1 : 0; 
                for (f=2 ; f<16 ; f++) {
                    dd = (dd==7) ? 1 : dd+1 ;
                    if(dd==1) {i++; if(i==2) break;}
                }
                gsee.dm[0]=f; gsee.dm[1]=5; mo_dm=gsee.tog;
                
                // Πατέρα
                
                dd = find_dayname(uyear , 6 , 1);
                i = (dd==1) ? 1 : 0; 
                for (f=2 ; f<24 ; f++) {
                    dd = (dd==7) ? 1 : dd+1 ;
                    if(dd==1) {i++; if(i==3) break;}
                }
                gsee.dm[0]=f; gsee.dm[1]=6; fa_dm=gsee.tog;
                
                
                
                // PROSVPIKES EPETEIOI (Ρύμιση Κινητών και όλων των προειδοποιήσεων)
                
                    for (f=1 ; f<13 ; f++) {
                        for (i=1 ; i<32 ; i++) {
                        only[f][i]=0;
                        }
                    }
                
                
                if (ar_per || ar_clue) {
                    
                    for (f=0 ; f<ar_per ; f++) {
                        if (!pers[f].mob) {
                            
                            // Προειδοποιήσεις για υπομνήσεις πάνω σε σταθερή ημερομηνία
                            
                            if (pers[f].alarm) {
                                
                                pers_aldate[f][0] = pers_aldate[f][1] = pers_aldate[f][2] = pers_aldate[f][3] = 0;
                                pers_aldate[f][4] = pers_aldate[f][5] = pers_aldate[f][6] = 0;
                                
                                gsee.tog = pers1[f];
                                
                                if ( (gsee.dm[1]==2) && (gsee.dm[0]>mo[2]) )  continue;
                                
                                //if (uyear != etnowyear) continue ;
                                
                                alyear = pers[f].year ;
                                if (alyear>uyear+1) continue ;
                                
                                k=pers[f].alarm ;    // ALarm πόσων ημερών πριν ;; (k ημερών)
                                i=0;
                                
                                do {
                                    if (gsee.dm[0]>1) {
                                        
                                        gsee.dm[0] -= 1 ;
                                        k--;
                                        
                                        if (uyear < alyear) {i++ ; continue ;}
                                        pers_aldate[f][i++] = gsee.tog ;
                                        continue;
                                    }
                                    else {
                                        gsee.dm[1] = (gsee.dm[1]>1) ? gsee.dm[1]-1 : 12 ;
                                        if ( (gsee.dm[1]!=12) && (uyear < alyear) ) break ;
                                        if (gsee.dm[1]==12) { alyear--; }                                       
                                        gsee.dm[0] = mo[gsee.dm[1]];
                                        k--;
                                        pers_aldate[f][i++] = gsee.tog ;
                                    }
                                } while(k);
                            }
                            continue ;
                        }
                        
                        switch (pers[f].mob) {
                            case 1 :
                                s =  pers[f].arkin;
                                pers1[f]=ksee[s].tog;
                                break ;
                            case 2 :
                                pers1[f] = mo_dm ;
                                break ;
                            case 3 :
                                pers1[f] = fa_dm;
                                break ;
                        }
                        
                        if (pers[f].alarm) {
                            
                            // Προειδοποιήσεις για υπομνήσεις πάνω σε κινητές εορτές
                            
                            pers_aldate[f][0] = pers_aldate[f][1] = pers_aldate[f][2] = pers_aldate[f][3] = 0;
                            pers_aldate[f][4] = pers_aldate[f][5] = pers_aldate[f][6] = 0;
                            
                            gsee.tog = pers1[f];
                            
                            if ( (gsee.dm[1]==2) && (gsee.dm[0]>mo[2]) )  continue;
                            
                            alyear = pers[f].year ;
                            if (alyear>uyear+1) continue ;
                            
                            k=pers[f].alarm ;
                            i=0;
                            do {
                                if (gsee.dm[0]>1) {
                        
                                    gsee.dm[0] -= 1 ;
                                    k--;
                                    
                                    if (uyear < alyear) {i++ ; continue ;}
                                    pers_aldate[f][i++] = gsee.tog ;
                                    continue;
                                }
                                else {
                                    gsee.dm[1] = (gsee.dm[1]>1) ? gsee.dm[1]-1 : 12 ;
                                    if ( (gsee.dm[1]!=12) && (uyear < alyear) ) break ;
                                    if (gsee.dm[1]==12) { alyear--; }                                       
                                    gsee.dm[0] = mo[gsee.dm[1]];
                                    k--;
                                    pers_aldate[f][i++] = gsee.tog ;
                                }
                                
                            } while(k);
                        }
                    }
                    
                        //check_startmonth=find_dayname(uyear , umonth , 1);
                        //if (check_startmonth != startmonth) {information (0,"18878 - Διαφορετικό startmonth...ψάξτο !!" , 0 ) ;}
                    
                    // Περιοδικές Υπομνήσεις - ενημέρωση πίνακα only και πίνακα clue
                    
                        for (f=0 ; f<ar_clue ; f++) {
                            clue[f] = proclue[f] = 0 ;
                            switch (rcr[f].freq)
                            {
                                case 0 :
                                    
                                    continue ;
                                    
                                case 1 :
                                    
                                    recur_days ( f , uyear , umonth , uday , mo);
                                    break ;
                                    
                                case 7 :
                                    
                                    recur_week ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;
                                    
                                case 30 :
                                    recur_month_st ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;
                                    
                                case 31 :
                                    
                                    recur_month_w ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;
                                    
                                case 32 :
                                    
                                    recur_month_bima (f , uyear , umonth , uday , mo);
                                    break ;
                                    
                                case 365 :
                                    
                                    recur_year_st (f , uyear , umonth , uday , mo);
                                    break ;
                                    
                                case 366 :
                                    
                                    recur_year_w ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;

                            }
                        }
                    
                
                    
                    for (f=0;f<ar_per;f++) { 
                        if (uyear >= pers[f].year) {
                            gsee.tog = pers1[f];
                            only[gsee.dm[1]][gsee.dm[0]]=1;
                        }
                    }
                
                // Τοποθέτηση κουκίδων στο πάνελ σε ημερομηνίες όπου υπάρχει ΠΑΓΙΑ/ετήσια ή ΕΠΑΝΑΛΑΜΒΑΝΟΜΕΝΗ προσωπική υπόμνηση
                    if (DIAK1) {
                        for (md=1 ; md<=mo[umonth] ; md++){
    	
                            v1 = md / 7 ;
                            v2 = md % 7 ;

                            v = (v2) ? v1 : v1-1 ;
                            dy = cayt + (v*25) + 25 ;
                            
                            v = (!v2) ? 6 : v2-1 ;
                            dx = caxt + (v*60) ;
                            
                            if (only[umonth][md]) { setcolor (COLOR(0,255,255)); } 
                            else  if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                            else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                            for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+14 ; f<=dy+21; f++) _putpixel (i,f);}
                            
                        }
                    }
                        
                } 
                
                
                if (Diary_u && DIAK2) {
                    for (md=1 ; md<=mo[umonth] ; md++){
                        
                            v1 = md / 7 ;
                            v2 = md % 7 ;

                            v = (v2) ? v1 : v1-1 ;
                            dy = cayt + (v*25) + 25 ;
                            
                            v = (!v2) ? 6 : v2-1 ;
                            dx = caxt + (v*60) ;
                            
                    // Tοποθέτηση κουκίδων στο πάνελ σε ημερομηνίες όπου υπάρχει καταχώρηση ημερολογίου
                    if (DIaryn[umonth][md]) { setcolor (COLOR(162,57,0)); } 
                    else  if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                    else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                    for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+3 ; f<=dy+10; f++) _putpixel (i,f);}
                    }
                }
                
                refresh();
                
                gsee.dm[0]=uday; gsee.dm[1]=umonth;
                
                if (klear) { _bareacls(eort_recxt, eort_recyt, eort_recxb, eort_recyb, genbkxr) ; 
                     _bareacls(onom_recxt, onom_recyt, onom_recxb, onom_recyb, genbkxr) ; 
                     _bareacls(vel_xt,vel_yt,vel_xb,vel_yb, ejobkxr);
                    klear=0; 
                }
                
                // Ξεκινάει το γράψιμο - εγγραφή !!!
                // ELEGXOS HMEROMHNIAS STAUERVN EORTVN - ΕΓΓΡΑΦΗ !
                //a=eort_recyt+1;
                y=0;a=0;
                for (f=0;f<ar_seo;f++) {
                    if (gsee.tog!=ssee[f].tog) continue ;
                    while (gsee.tog==ssee[f].tog) {
                        vrika[a][0]=0; vrika[a][1]=f ; a++;
                        egiortes[y++]=13; egiortes[y++]=0;
                        i=0; 
                        while (seort[f][i] != 255) { egiortes[y++]=seort[f][i++] ; }
                        egiortes[y++]=200;
                        f++;
                        if (f==ar_seo) break ;
                    }
                    if (f<647) {f=647; continue;}
                }
                
                // ELEGXOS HMEROMHNIAS KINHTVN EORTVN - ΕΓΓΡΑΦΗ !
                for (f=0;f<ar_keo;f++) {
                    if (gsee.tog!=ksee[f].tog) continue ;
                    vrika[a][0]=1; vrika[a][1]=f ; a++;
                    if (f< (ar_keo-1) ) { egiortes[y++]=42; } else { egiortes[y++]=13; } 
                    egiortes[y++]=0;
                    i=0; 
                    while (keort[f][i] != 255) { egiortes[y++]=keort[f][i++] ; }
                    egiortes[y++]=200;
                }
                
                // ELEGXOS HMEROMHNIAS PAGKOSMIVN HMERVN - ΕΓΓΡΑΦΗ !
                
                if (uyear>2016) {
                    
                    // Διάφορες Χύμα...
                    
                    // Παγκ. Ημέρα Πιάνου H 88η ημέρα του χρόνου, όσα και τα πλήκτρα του πιάνου
                    
                    gsee.dm[1]=1;
                    i = 0;
                    for (f=1 ; f<89 ; f++) {
                        
                        i++;
                        
                        if (i > (int) mo [gsee.dm[1]]) {
                            i=1;
                            gsee.dm[1]++;
                        }
                    }
                    
                    gsee.dm[0] = (unsigned char) i;
                    pagk_dm[piano] = gsee.tog;
                    
        // Παγκόσμια Ημέρα Κυματοδρομίας (Σέρφινγκ) - 21 Ιουνίου ή 20 Ιουνίου τα δίσεκτα έτη
                    
                    if (mo[2]==28) gsee.dm[0]=21 ; else gsee.dm[0]=20 ;
                    gsee.dm[1] = 6;
                    pagk_dm[surfing] = gsee.tog ;
                    
                    // Πεσόντων Αστυνομικών (Ελλάδα) PASXA - 57 ημέρες
                    
                    pagk_dm[pesontes] = ksee[3].tog ; // Ψυχοσάββατο Α'
                    
                    /*
                    //dd = 1 ;
                    gsee.dm[0] = pasxa_day; gsee.dm[1] = pasxa_month;
                    for (f=1 ; f<58 ; f++) {
                        //dd = (dd==1) ? 7 : dd-1 ;
                        if (gsee.dm[0] == 1) {
                            gsee.dm[1]--;
                            gsee.dm[0] = mo [gsee.dm[1]] ;
                            continue ;
                        }
                        else {gsee.dm[0]--;}
                    }
                    pagk_dm[pesontes] = gsee.tog ;
                    */
                    
            // Ημέρα Τιμής των Αποστράτων της Ελληνικής Αστυνομίας - Αγίων Πάντων
            
                    pagk_dm[apostr_ast] = ksee[37].tog ;
                    
                    // IANOYARIOS
                    // Λέπρας τελευταία Κυριακή του Ιανουαρίου 
                    
                    dd_1 = fidaye ;
                    gsee.dm[1] = 1;
                    
                    dd = dd_1;
                    for (f=2 ; f<32 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) { gsee.dm[0]=f; }
                    }
                    
                    pagk_dm[lepra] = gsee.tog;
                    
                    // Για θύματα τρομοκρατίας στην Ελλάδα - Τρίτη Κυριακή Ιανουαρίου - noe17
                    
                    dd = dd_1;
                    i = (dd==1) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[noe17] = gsee.tog;
                    
                    // FEBRUARY
                                       
                    // Παγκ. Γάμου 2η Κυριακή Φλεβάρη
                    // Παγκ. Προσευχής για Αυτισμό
                    
                    dd_1 = find_dayname(uyear , 2 , 1);
                    gsee.dm[1]=2 ;
                    
                    dd = dd_1;
                    i = (dd==1) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) {i++; if (i==2) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[gamos] = gsee.tog;
                    pagk_dm[aytism] = gsee.tog;
                    
                    // Διεθνής Ημέρα κατά της Επιληψίας - 2η Δευτ. Φεβρ.
                    
                    dd = dd_1;
                    i = (dd==2) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==2) {i++; if (i==2) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[epilhc] = gsee.tog;
                    
                    // Κατάποση Σπαθιών - τελευταίο Σάββατο Φεβρ.
                    
                    dd = dd_1;
                    for (f=2 ; f<=mo[2] ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==7) { gsee.dm[0]=f; }
                    }
                    
                    pagk_dm[spaui] = gsee.tog;
                    
                    // Παγκόσμια Ημέρα Σπάνιων Παθήσεων - Τελευταία ημέρα Φεβρ.
                    
                    gsee.dm[0]=mo[2]; 
                    pagk_dm[spanies] = gsee.tog;
                    
                    // MARTIOS
                    
                    // Παγκ. Ημέρα Νεφρού η δεύτερη Πέμπτη κάθε Μαρτίου - nefro
                    dd_1 = find_dayname(uyear , 3 , 1); // Βρες 1η Μαρτίου τι μέρα είναι...
                    gsee.dm[1]=3 ;
                    
                    dd=dd_1;
                    i = (dd==5) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==5) {i++; if (i==2) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[nefro] = gsee.tog;
                    
                    // Παγκόσμια Εβδομάδα Ψηφιακού Βιβλίου - 1η Κυρ. Μαρτίου
                    
                    dd = dd_1; 
                    i = (dd==1) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==1) { break; }
                        } 
                        
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[ebook] = gsee.tog;
                    
                    
                    // Παγκόσμια ημ. ύπνου  - 3η Παρασκευή Μαρτίου
                    
                    dd = dd_1; 
                    i = (dd==6) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==6) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[sleep_1] = gsee.tog;
                    
                    
                    // APRILIOS
                    // Ημέρα του Δισκοπωλείου - Τρίτο Σάββατο Απριλίου
                    
                    dd_1 = find_dayname(uyear , 4 , 1); 
                    gsee.dm[1] = 4 ;
                    
                    dd = dd_1;
                    i = (dd==7) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==7) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[diskop] = gsee.tog;
                    
                    
                    // Διεθνής Ημέρα κατά του Θορύβου - Τελευταία Τετάρτη Απριλίου
                    
                    dd = dd_1;
                    for (f=2 ; f<31 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==4) { gsee.dm[0]=f; }
                    }
                    
                    pagk_dm[noise] = gsee.tog;
                    
                    // MAIOS
                    // Για κάναβι - 1ο Σάββατο Μαιου
                    
                    dd_1 = find_dayname(uyear , 5 , 1);
                    gsee.dm[1]=5 ;
                    
                    dd = dd_1;
                    i = (dd==7) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==7) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[kanavi] = gsee.tog;
                    
                    // Παγκόσμια Ημέρα Αποδημητικών Πτηνών - 2o Σαβ. Μαίου
                    gsee.dm[0] += 7;
                    pagk_dm[apodhm_1] = gsee.tog ;
                    
                    // Διεθνής Ημέρα της Τούμπας , 1η Παρ. Μαί , tuba
                    
                    dd = dd_1;
                    i = (dd==6) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==6) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ;
                    pagk_dm[tuba] = gsee.tog;
                    
                    
                    // Για γέλιο - 1η Κυριακή Μαίου
                    
                    dd = dd_1;
                    i = (dd==1) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==1) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[gelio] = gsee.tog;
                    
                    // Για άσμα - 1η Τρίτη Μαίου
                    
                    dd = dd_1;
                    i = (dd==3) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==3) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[asma] = gsee.tog;
                    
                    // ΠΗ Δίκαιου Εμπορίου") - δεύτερο Σάββατο Μαΐου , emporio
                    
                    dd = dd_1;
                    i = (dd==7) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==7) {i++; if (i==2) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[emporio] = gsee.tog;

                    // ΠΗ Σκλήρυνσης Κατά Πλάκας - τελευταία Τετάρτη Μαΐου , sklhr_plak
                    
                    dd = dd_1;
                    for (f=2 ; f<32 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==4) { gsee.dm[0]=f; }
                    }
                   
                    pagk_dm[sklhr_plak] = gsee.tog;
                    
                    // Ιούλιο
                    // Παγκόσμια Ημέρα Συνεταιρισμών - 1o Σαβ. Ιουλίου , cooperat
                    
                    dd_1 = find_dayname(uyear , 7 , 1); 
                    gsee.dm[1]=7 ;
                    
                    dd = dd_1;
                    i = (dd==7) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==7) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ;
                    pagk_dm[cooperat] = gsee.tog;
                    
                    
                    // ΔΗ Διαχειριστή Συστημάτων -τελ. Παρασκευή Ιουλίου , admin
                    
                    dd = dd_1;
                    for (f=2 ; f<32 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==6) { gsee.dm[0]=f; }
                    }
                    
                    pagk_dm[admin] = gsee.tog;
                    
                    // Αύγουστος
                    // Παγκόσμια Ημέρα Φάρων - Τρίτη Κυριακή Αυγούστου , faros
                    
                    dd_1 = find_dayname(uyear , 8 , 1); 
                    gsee.dm[1] = 8 ;
                    
                    dd = dd_1;
                    i = (dd==1) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[faros] = gsee.tog;
                    
                    // ΔΗ Μπύρας - 1η Παρασκευή Αυγούστου , beer
                    
                    dd = dd_1;
                    i = (dd==6) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==6) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[beer] = gsee.tog;
                    
                    
                    // Σεπτεμβριος
                    
                    dd_1 = find_dayname(uyear , 9 , 1);
                    gsee.dm[1]=9 ;
                    // ΠΗ Γενειάδας - 1o Σαβ. Σεπτεμβρ. , geniada
                     
                    dd = dd_1;
                    i = (dd==7) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==7) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[geniada] = gsee.tog;
                    
                    // ΠΗ Πρώτων Βοηθειών - 2o Σάββατο Σεπτεμβρίου , ahelp
                    
                    gsee.dm[0] += 7;
                    pagk_dm[ahelp] = gsee.tog ;
                    
                     // ΠΗ Εθελοντικού Καθαρισμού Ακτών-3o Σάββατο Σεπτεμβρίου , paralia
                     // ΠΗ Ελεύθερου Λογισμικού - 3o Σάββατο Σεπτεμβρίου , free_software
                    
                    gsee.dm[0] += 7;
                    pagk_dm[paralia] = gsee.tog ;
                    pagk_dm[free_software] = gsee.tog ;
                    
                    
                    // ΟΚΤΩΒΡΙΟΣ
                                        
                    dd_1 = find_dayname(uyear , 10 , 1); 
                    gsee.dm[1]=10 ;
                    
                    // Παγκόσμια Ημέρα Κατοικίας - Ανθρώπινων Οικισμών - 1η Δευτέρα Οκτ. ,katoikia
                    // Παγκόσμια Ημέρα Αρχιτεκτονικής - 1η Δευτέρα Οκτωβρίου , arxitekt
                    dd = dd_1;
                    i = (dd==2) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==2) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[katoikia] = gsee.tog;
                    pagk_dm[arxitekt] = gsee.tog;
                    
                    // Πανευρωπαϊκή Γιορτή των Πουλιών - 1ο Σαβ Οκτωβρ. , birds
                    
                    dd = dd_1;
                    i = (dd==7) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==7) { break; }
                        } 
                    }
                    else f=1;
                    
                    gsee.dm[0] = f ; 
                    pagk_dm[birds] = gsee.tog;
                    
                    // Παγκόσμια Ημέρα Αποδημητικών Πτηνών (2η φορά) - 2o Σαβ. Οκτ. , apodhm_2
                    // ΠΗ Ξενώνων και Παρηγορητικής Φροντίδας - δεύτερο Σάββατο του Οκτωβρίου , parhgoria
                    
                    gsee.dm[0] += 7;
                    pagk_dm[apodhm_2] = gsee.tog ;
                    pagk_dm[parhgoria] = gsee.tog ;
                    
                    // Ευρωπαϊκή Νύχτα Χωρίς Ατυχήματα - τρίτο Σάββατο του Οκτωβρίου , euronight
                    
                    gsee.dm[0] += 7;
                    pagk_dm[euronight] = gsee.tog ;
                    
                    
                    // Ημέρα του Μακεδονικού Αγώνα - πρώτη Κυριακή μετά την 13η Οκτωβρίου , paulos_melas
                    
                    dd = dd_1;
                    for (f=2 ; f<25 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1 && f>13) break;
                    }
                    
                    gsee.dm[0] =f ;
                    pagk_dm[paulos_melas] = gsee.tog ;
                    
                    // Παγκόσμια Ημέρα Αυγού - δεύτερη Παρασκευή του Οκτωβρίου , egg
                   
                    dd = dd_1;
                    i = (dd==6) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==6) {i++; if (i==2) break;}
                    }
                    gsee.dm[0] = f ;
                    pagk_dm[egg] = gsee.tog;
                    
                    // Παγκόσμια Ημέρα Όρασης - 2η Πέμπτη του Οκτωβρίου , orasi
                    
                    dd = dd_1;
                    i = (dd==5) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==5) {i++; if (i==2) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[orasi] = gsee.tog;
                    
                    //Παγκόσμια Ημέρα των Τεχνών του Δρόμου κλπ - τελευταίο Σάββατο του Οκτωβρίου , streetart
                    
                    dd = dd_1;
                    for (f=2 ; f<32 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==7) { gsee.dm[0]=f; }
                    }
                    
                    pagk_dm[streetart] = gsee.tog;
                    
                    // Νοέμβριος
                    
                    dd_1 = find_dayname(uyear , 11 , 1); 
                    gsee.dm[1] = 11 ;
                    
                    // Ευρωπαϊκή Ημέρα Οινοτουρισμού - 2η Κυριακή Νοεμβρίου , wine_tour
                    
                    dd = dd_1;
                    i = (dd==1) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) {i++; if (i==2) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[wine_tour] = gsee.tog;
                    
                    // Ευρωπαϊκή Εβδομάδα Ευαισθητοποίησης για Κυστική Ίνωση - 3η Δευτέρα Νοεμβρίου , kyst_inosi
                    
                    dd = dd_1;
                    i = (dd==2) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==2) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[kyst_inosi] = gsee.tog;
                    
                    // Παγκόσμια Ημέρα ΧΑΠ ,3η Τετάρτη Νοε. , xap
                    
                    dd = dd_1;
                    i = (dd==4) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==4) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[xap] = gsee.tog;
                    
                    // Παγκόσμια Ημέρα Φιλοσοφίας , 3η Πέμπτη Νοε , sofia
                    
                    dd = dd_1;
                    i = (dd==5) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==5) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[sofia] = gsee.tog;
                    
                    // ΠΗ Μνήμης Θυμάτων Τροχαίων Ατυχημάτων , 3η Κυρ Νοε , troxaio
                    
                    dd = dd_1;
                    i = (dd==1) ? 1 : 0 ;
                    for (f=2 ; f<28 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) {i++; if (i==3) break;}
                    }
                    gsee.dm[0] = f ; 
                    pagk_dm[troxaio] = gsee.tog;
                    
                    // ΠΗ Αγοραστικής Αποχής , τελ. Σάββατ. Νοε , antiagora
                    
                    dd = dd_1;
                    for (f=2 ; f<31 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==7) { gsee.dm[0]=f; }
                    }
                    
                    pagk_dm[antiagora] = gsee.tog;
                    
                    // TELOS
                    
                    gsee.dm[0]=uday; gsee.dm[1]=umonth;
                    
                    for (f=0; f<ar_pagk_1 ;f++) {
                        if (gsee.tog!=pagk_dm[f]) continue ;
                        egiortes[y++]=10; egiortes[y++]=0;
                        i=0;
                        while (pagk[f][i] != 255) { egiortes[y++]=pagk[f][i++] ; }
                        egiortes[y++]=200;
                    }
                }
                
                 gsee.dm[0]=uday; gsee.dm[1]=umonth;
                
                // Μητέρας - Πατέρα - ΕΓΓΡΑΦΗ !
                
                if(gsee.tog==mo_dm) {
                    i=0;
                    while (mother[i] != 255) { egiortes[y++]=mother[i++] ; }
                    egiortes[y++]=200;
                }
                
                if(gsee.tog==fa_dm) {
                    i=0;
                    while (father[i] != 255) { egiortes[y++]=father[i++] ; }
                    egiortes[y++]=200;
                }
                
                // Πάγιες Προσωπικές Επέτειοι/Υπομνήσεις - ΕΓΓΡΑΦΗ !
                dx=y;
                dy=0;
                for (f=0; f<ar_per ;f++) {
                    if (gsee.tog!=pers1[f] || uyear<pers[f].year) continue ;
                    if (!dy) {
                        dy=1;
                        egiortes[y++]=200;
                        i=0;
                        while (perm_str[i] != 255) { egiortes[y++]=perm_str[i++] ; }
                        egiortes[y++]=200;
                    }
                    egiortes[y++]=30; egiortes[y++]=30; egiortes[y++]=0;
                    i=0;
                    while (pers[f].tex[i] != 255) { egiortes[y++]=pers[f].tex[i++] ; }
                    egiortes[y++]=200;
                }
                
                // Recursive Εγγραφή ΗΜΕΡΑΣ
                dy=0;
                for (f=0 ; f<ar_clue ; f++) {
                    if (clue[f]) {
                        if (!dy) {
                            dy=1;
                            egiortes[y++]=200;
                            i=0;
                            while (perc_str[i] != 255) { egiortes[y++]=perc_str[i++] ; }
                            egiortes[y++]=200;
                        }
                        egiortes[y++]=30; egiortes[y++]=30; egiortes[y++]=0;
                        i=0;
                        while (rcr[f].keim[i] != 255) { egiortes[y++]=rcr[f].keim[i++] ; }
                        egiortes[y++]=200;
                    }
                }
                
                if ( dx!=y ) {if (!mati) { _realputicon(eyext,eyeyt,mem_eye); mati=1; }}
                else {if (mati) {mati=0; _bareacls(eyext,eyeyt,eyext+36,eyeyt+18,ejobkxr);}}
                
                // Προειδοποιήσεις Πάγιων (ετήσιων) Υπομνήσεων - ΕΓΓΡΑΦΗ στη μνήμη !
                
                dx=0 ;
                if (alrm) {
                    alrm=0;
                     _bareacls(memox,memoy,memox+33, memoy+18,ejobkxr);
                }
                for (f=0 ; f<ar_per; f++) {
                    k = pers[f].alarm ;
                    if (!k) continue ;
                    for (s=0; s<k ; s++) {
                        if (pers_aldate[f][s] == gsee.tog) {
                        
                            if (!dx) { // Γράψε ** Προειδοποιήσεις **
                                dx=1;
                                egiortes[y++]=200;
                                i=0;
                                while (alert_str[i] != 255) { egiortes[y++]=alert_str[i++] ; }
                                egiortes[y++]=200;
                                
                                // Μήπως κάποιο σήμα προειδοποίησης να σκάσει εδώ ;
                                alrm=1;
                                 _realputicon(memox,memoy,mem_memo);
                            }
                        
                            // Γράψε σε πόσες ημέρες....
                            i=0;
                            while (seposes[s][i] != 255) { egiortes[y++]=seposes[s][i++] ; }
                            egiortes[y++]=0;
                            
                            // Γράψε το κείμενο της προειδοποίησης
                            i=0;
                            while (pers[f].tex[i] != 255) { egiortes[y++]=pers[f].tex[i++] ; }
                            egiortes[y++]=200;
                            
                            break;
                        }
                    }
                }
                
                // Recursice Προειδοποιήσεις
                for (f=0 ; f<ar_clue ; f++) {
                    if (proclue[f]) {
                        
                        s=proclue[f]-1 ;
                        
                        if (!dx) { // Γράψε ** Προειδοποιήσεις **
                            dx=1;
                            egiortes[y++]=200;
                            i=0;
                            while (alert_str[i] != 255) { egiortes[y++]=alert_str[i++] ; }
                            egiortes[y++]=200;
                            
                            // Μήπως κάποιο σήμα προειδοποίησης να σκάσει εδώ ;
                            alrm=1;
                            _realputicon(memox,memoy,mem_memo);
                        }
                        
                        // Γράψε σε πόσες ημέρες....
                        i=0;
                        while (seposes[s][i] != 255) { egiortes[y++]=seposes[s][i++] ; }
                        egiortes[y++]=0;
                        
                        // Γράψε το κείμενο της προειδοποίησης
                        i=0;
                        while (rcr[f].keim[i] != 255) { egiortes[y++]=rcr[f].keim[i++] ; }
                        egiortes[y++]=200;
                        
                    }
                }
                
                if (y) {y--;egiortes[y]=255;y=0;klear=1;}
                
                for (f=0 ; f<a ; f++) {
                    if (!vrika[f][0]) {
                        k=vrika[f][1];
                        i=0;
                        while ( (ase_aa[i] != k) && (i<ar_son) ) i++;
                        if(i==ar_son) continue;
                        dx=i;
                        do {
                            i=0;
                            while (ase_sonoma[dx][i]!=255) {
                                enames[y++]=ase_sonoma[dx][i++];}
                            enames[y++]=12; enames[y++]=0;dx++;
                            if (dx==ar_son) break ;
                            } while (ase_aa[dx]==k) ;
                        y-=2; enames[y++]=200;
                    }
                    else {
                        i=0;
                        k=vrika[f][1];
                        while ( (ake_aa[i] != k) && (i<ar_kon) ) i++;
                         if(i==ar_kon) continue;
                        dx=i;
                        do {
                            i=0;
                            while (ake_konoma[dx][i]!=255) {
                                enames[y++]=ake_konoma[dx][i++];}
                            enames[y++]=12; enames[y++]=0;dx++;
                            if (dx==ar_kon) break ;
                            } while (ake_aa[dx]==k) ;
                        y-=2; enames[y++]=200;
                    }
                }
                if (y) { y--; enames[y]=255;klear=1;}
                if(klear) {
                gouv=myfont[eortes_font];
                eort_cur=onom_cur=0 ;
                _txt_show (egiortes , 0 ,eort_recxt+1, eort_recyt+1, eort_recxb-1, eort_recyb-1  , 59998 , genchxr,  genbkxr, ejobkxr);
                gouv=myfont[names_font];
                _txt_show (enames , 0,onom_recxt+1, onom_recyt+1, onom_recxb-1, onom_recyb-1  , 19998 , genchxr,  genbkxr, ejobkxr);}
                refresh();
                gyear=uyear; gmonth=umonth; gday=uday;
            }
            else {
                _bareacls (mhnxt , recfullyt+1 , mhnxb , mhnyt[1]-1 , olobkxr) ;
                readnote_werp = 0 ;
                year_notes = 0 ;
                // Σβήσε Ανατολή-Δύση Ηλίου - κλπ
                _bareacls(sunrise_xt,sunrise_yt,sunrise_xt+52,sunrise_yt+18,olobkxr);
                _bareacls(sunset_xt,sunset_yt,sunset_xt+52,sunset_yt+18,olobkxr);
                _bareacls(moonphase_xt,moonphase_yt,lunarx-2,moonphase_yt+18,olobkxr);
                _bareacls(lunarx,lunary,lunarx+35,lunary+35,olobkxr);
                _bareacls (moontm_xt , moonri_yt, lunarx-6 , moonse_yt+16, olobkxr);
                
                Diary_u = 0 ;
                if (there_is_note) {
                there_is_note = 0 ;
                _bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                }
                if (alrm) {
                    alrm=0;
                     _bareacls(memox,memoy,memox+33, memoy+18,ejobkxr);
                }
                if (mati) {mati=0; _bareacls(eyext,eyeyt,eyext+36,eyeyt+18,ejobkxr);}
                
                if (klear) { _bareacls(eort_recxt, eort_recyt, eort_recxb, eort_recyb, genbkxr) ; 
                     _bareacls(onom_recxt, onom_recyt, onom_recxb, onom_recyb, genbkxr) ; 
                     _bareacls(vel_xt,vel_yt,vel_xb,vel_yb, ejobkxr);
                    klear=0; }
                refresh();
                gyear=uyear; gmonth=umonth; gday=uday;
            }
        }
        else if ( ((gmonth!=umonth) || (gday!=uday) || (rech) ) && (uyear>1999) ) {
            
                // ΥΠΟΛΟΓΙΣΜΟΣ ΕΒΔΟΜΑΔΟΣ
                
                gsee.dm[0] = uday ; gsee.dm[1] = umonth ;
                prosee.dm[0] = prosee.dm[1] = 1 ;
                i=1;  dd=fidaye;
                week = ( (dd>=2) && (dd<=5) ) ? 1 : 0 ;
                
                 while ( gsee.tog != prosee.tog ) {
                    i++;
                    dd = (dd==7) ? 1 : dd+1 ;
                    if (dd==2) { week++ ; }
                    
                    if (prosee.dm[0] == mo[prosee.dm[1]]) {
                        
                        prosee.dm[0]=1;
                        prosee.dm[1]++;
                        
                    } else { prosee.dm[0]++; }
                }
                
                _bareacls (mhnxt , recfullyt+1 , mhnxb , mhnyt[1]-1 , olobkxr) ;
                aaday = (unsigned short int) i ;
                sprintf (str1024,"Ημέρα %dη",i);
                normtext_tomy(str1024,0);
                 _outmystr_center_col(notosans_11b, str1024,mhnxt,recfullyt+1,mhnxb,recfullyt+16,cyan,olobkxr);
                if ( (week>0) && (week<53) ) { sprintf (str1024,"ΕΒΔΟΜΑΔΑ %dη",week); }
                else if (!week) {sprintf (str1024,"Τελ. Εβδομ. %d",uyear-1);}
                else if (week==53) {
                    dd = unameday ;
                    a = uday ;
                    while (a<31) {
                        a++;
                        dd = (dd==7) ? 1 : dd+1 ;
                    }
                    dd = (dd==7) ? 1 : dd+1 ; // 1η επόμενου έτους ημέρα dd
                    a = ( (dd>=2) && (dd<=5) ) ? 1 : 0 ;
                    if (a) { sprintf (str1024,"1η Εβδομ. %d",uyear+1); }
                    else {sprintf (str1024,"ΕΒΔΟΜΑΔΑ %dη",week);}
                }
                else {str1024[0] = '\0';} // lol
                
                normtext_tomy(str1024,meravdomada);
                 _outmystr_center_col(notosans_11b, meravdomada,mhnxt,recfullyt+16,mhnxb,mhnyt[1]-1,cyan,olobkxr);
               
            readnote_werp = 0 ;
            
            if ( Diary_u ) {
                sprintf (diary_filename,"%04d_%02d_%02d", (int) uyear , (int) umonth , (int) uday);
                sprintf(str1kb,"%s%d/%s.dry",Diary_path,(int) uyear, diary_filename);
                if (DIaryn[umonth][uday]) {
                    // Υπάρχει αρχείο-σημείωση
                    if (!there_is_note) {
                        _realputicon(stikx,stiky,mem_stik);
                        there_is_note=1;
                    }
                }
                else {
                    // Δεν υπάρχει αρχείο-σημείωση
                    pre_diary_filename[0]=255;
                    if (there_is_note) {
                        there_is_note = 0 ;
                        _bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                    }
                }
            }
                
            
                sunrise_sunset(uyear,umonth,uday);
                srise_hc = srise_h ; srise_mc = srise_m ; sset_hc = sset_h; sset_mc = sset_m ;
                _bareacls(sunrise_xt,sunrise_yt,sunrise_xt+52,sunrise_yt+18,olobkxr);
                _bareacls(sunset_xt,sunset_yt,sunset_xt+52,sunset_yt+18,olobkxr);
                sprintf (str1024,"%02d:%02d",srise_hc,srise_mc);
                normtext_tomy(str1024,0);
                _outmystr_col(2,str1024,sunrise_xt,sunrise_yt,lunarx-6,anatcol,olobkxr);
                sprintf (str1024,"%02d:%02d",sset_hc,sset_mc);
                normtext_tomy(str1024,0);
                _outmystr_col(2,str1024,sunset_xt,sunset_yt,caxb-6,disicol,olobkxr);
                
                MOON = moonPhases((int) uyear, (int) umonth, (int) uday) ;
                strcpy (moonstr_1,MoonStr);
                normtext_tomy(moonstr_1,str1024);
                _bareacls(moonphase_xt,moonphase_yt,lunarx-6,moonphase_yt+18,olobkxr);
                _outmystr_col(2,str1024,moonphase_xt,moonphase_yt,lunarx-6,astrchxr,olobkxr);
                _bareacls(lunarx,lunary,lunarx+35,lunary+35,olobkxr);
                //sprintf (str1024,"%sICD/moon%d.bmp",path_name,MOON);
                //readimagefile(str1024,lunarx,lunary,0,0);
                _realputicon(lunarx,lunary,mem_lun[MOON]); refresh();
                
                moonrise_moonset(uyear,umonth,uday,mo);
                MOON_ord=moon_ord;
                strcpy (MOONrise,moonrise_txt) ; strcpy (MOONset,moonset_txt) ;
                _bareacls (moontm_xt , moonri_yt, lunarx-6 , moonse_yt+16, olobkxr);
                if (MOON_ord==1) { normtext_tomy(MOONrise,str1024); pioxr=anatcol ;}
                else { normtext_tomy(MOONset,str1024); pioxr=disicol ;}
                _outmystr_col(2,str1024,moontm_xt,moonri_yt,lunarx-6,pioxr,olobkxr);
                if (MOON_ord==1) { normtext_tomy(MOONset,str1024); pioxr=disicol ; }
                else { normtext_tomy(MOONrise,str1024); pioxr=anatcol ;}
                _outmystr_col(2,str1024,moontm_xt,moonse_yt,lunarx-6,pioxr,olobkxr);
                
                egiortes[0]=255; enames[0]=255;
                
                gsee.dm[0]=uday; gsee.dm[1]=umonth;
                rech=0;
                if (klear) { _bareacls(eort_recxt, eort_recyt, eort_recxb, eort_recyb, genbkxr) ; 
                     _bareacls(onom_recxt, onom_recyt, onom_recxb, onom_recyb, genbkxr) ; 
                     _bareacls(vel_xt,vel_yt,vel_xb,vel_yb, ejobkxr);
                    klear=0; }
                    
                        //check_startmonth=find_dayname(uyear , umonth , 1);
                        //if (check_startmonth != startmonth) {information (0,"19829-Διαφορετικό startmonth...ψάξτο !!" , 0 ) ;}
                    
                    // Έλεγχος Recursive 
                    
                        for (f=0 ; f<ar_clue ; f++) {
                            clue[f] = proclue[f] = 0 ;
                            switch (rcr[f].freq)
                            {
                                case 0 :
                                    
                                    continue ;
                                    
                                case 1 :
                                    
                                    recur_days ( f , uyear , umonth , uday , mo);
                                    break ;
                                    
                                case 7 :
                                    recur_week ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;
                                    
                                case 30 :
                                    recur_month_st ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;
                                    
                                case 31 :
                                    
                                    recur_month_w ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;
                                    
                                case 32 :
                                    
                                    recur_month_bima (f , uyear , umonth , uday , mo);
                                    break ;
                                    
                                case 365 :
                                    
                                    recur_year_st (f , uyear , umonth , uday , mo);
                                    break ;
                                    
                                case 366 :
                                    
                                    recur_year_w ( f , uyear , umonth , uday , startmonth , mo);
                                    break ;

                            }
                        }
                    
                    
                    
                // Τσεκάρισμα Προσωπικών Υπομνήσεων πάνω στο πάνελ
                
                if ( ( (ar_per) || (ar_clue) ) && (DIAK1) ) {
                    for (md=1 ; md<=mo[umonth] ; md++){
                            
                        v1 = md / 7 ;
                        v2 = md % 7 ;

                        v = (v2) ? v1 : v1-1 ;
                        dy = cayt + (v*25) + 25 ;
                        
                        v = (!v2) ? 6 : v2-1 ;
                        dx = caxt + (v*60) ;
                        
                        if (only[umonth][md]) { setcolor (COLOR(0,255,255)); } 
                        else  if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                        else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); } 
                        for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+14 ; f<=dy+21; f++) _putpixel (i,f);}
                    }
                }
                
                // Tοποθέτηση κουκίδων στο πάνελ σε ημερομηνίες όπου υπάρχει καταχώρηση ημερολογίου
                
                if (Diary_u && DIAK2) {
                    for (md=1 ; md<=mo[umonth] ; md++){
    
                        v1 = md / 7 ;
                        v2 = md % 7 ;

                        v = (v2) ? v1 : v1-1 ;
                        dy = cayt + (v*25) + 25 ;
                        
                        v = (!v2) ? 6 : v2-1 ;
                        dx = caxt + (v*60) ;
                        
                        if (DIaryn[umonth][md]) { setcolor (COLOR(162,57,0)); } 
                        else  if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                        else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                        for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+3 ; f<=dy+10; f++) _putpixel (i,f);}
                    }
                    
                }
                
                refresh();
                // ELEGXOS HMEROMHNIAS STAUERVN EORTVN
                
                y=0; a=0;
                
                for (f=0;f<ar_seo;f++) {
                    if (gsee.tog!=ssee[f].tog) continue ;
                    while (gsee.tog==ssee[f].tog) {
                        vrika[a][0]=0; vrika[a][1]=f ; a++;
                        egiortes[y++]=13; egiortes[y++]=0;
                        i=0; 
                        while (seort[f][i] != 255) { egiortes[y++]=seort[f][i++] ; }
                        egiortes[y++]=200;
                        f++;
                        if (f==ar_seo) break ;
                    }
                    if (f<647) {f=647; continue;}
                }
                
                // ELEGXOS HMEROMHNIAS KINHTVN EORTVN
                for (f=0;f<ar_keo;f++) {
                    if (gsee.tog!=ksee[f].tog) continue ;
                    vrika[a][0]=1; vrika[a][1]=f ; a++;
                    if (f< (ar_keo-1) ) { egiortes[y++]=42; } else { egiortes[y++]=13; } 
                    egiortes[y++]=0;
                    i=0; 
                    while (keort[f][i] != 255) { egiortes[y++]=keort[f][i++] ; }
                    egiortes[y++]=200;
                }
                
                // ELEGXOS HMEROMHNIAS PAGKOSMIVN HMERVN
                
                
                    for (f=0; f<ar_pagk_1 ;f++) {
                        if (gsee.tog!=pagk_dm[f]) continue ;
                        egiortes[y++]=10; egiortes[y++]=0;
                        i=0;
                        while (pagk[f][i] != 255) { egiortes[y++]=pagk[f][i++] ; }
                        egiortes[y++]=200;
                    }
                
                // Μητέρας - Πατέρα
                
                if(gsee.tog==mo_dm) {
                    i=0;
                    while (mother[i] != 255) { egiortes[y++]=mother[i++] ; }
                    egiortes[y++]=200;
                }
                
                if(gsee.tog==fa_dm) {
                    i=0;
                    while (father[i] != 255) { egiortes[y++]=father[i++] ; }
                    egiortes[y++]=200;
                }
                
                dx=y;
                dy=0;
                
                // Πάγιες Προσωπικές Επέτειοι/Υπομνήσεις - ΕΓΓΡΑΦΗ !
                
                for (f=0; f<ar_per ;f++) {
                    if (gsee.tog!=pers1[f] || uyear<pers[f].year) continue ;
                        if (!dy) {
                        dy=1;
                        egiortes[y++]=200;
                        i=0;
                        while (perm_str[i] != 255) { egiortes[y++]=perm_str[i++] ; }
                        egiortes[y++]=200;
                        }
                    egiortes[y++]=30; egiortes[y++]=30; egiortes[y++]=0;
                    i=0;
                    while (pers[f].tex[i] != 255) { egiortes[y++]=pers[f].tex[i++] ; }
                    egiortes[y++]=200;
                }
                
                // Recursive Εγγραφή
                dy = 0 ;
                for (f=0 ; f<ar_clue ; f++) {
                    if (clue[f]) {
                        if (!dy) {
                            dy=1;
                            egiortes[y++]=200;
                            i=0;
                            while (perc_str[i] != 255) { egiortes[y++]=perc_str[i++] ; }
                            egiortes[y++]=200;
                        }
                        egiortes[y++]=30; egiortes[y++]=30; egiortes[y++]=0;
                        i=0;
                        while (rcr[f].keim[i] != 255) { egiortes[y++]=rcr[f].keim[i++] ; }
                        egiortes[y++]=200;
                    }
                }
                
                
                if (dx!=y) {if (!mati) { _realputicon(eyext,eyeyt,mem_eye);mati=1; }}
                else {if (mati) {mati=0; _bareacls(eyext,eyeyt,eyext+36,eyeyt+18,ejobkxr);}}
                
                
                // Προειδοποιήσεις Πάγιων (ετήσιων) Υπομνήσεων - ΕΓΓΡΑΦΗ στη μνήμη !
                
                dx=0 ; 
                if (alrm) {
                    alrm=0;
                     _bareacls(memox,memoy,memox+33, memoy+18,ejobkxr);
                }
                for (f=0 ; f<ar_per; f++) {
                    k = pers[f].alarm ;
                    if (!k) continue ;
                    for (s=0; s<k ; s++) {
                        if (pers_aldate[f][s] == gsee.tog) {
                        
                            if (!dx) { // Γράψε ** Προειδοποιήσεις ** - Δείξε εικόνα memo
                                dx=1;
                                egiortes[y++]=200;
                                i=0;
                                while (alert_str[i] != 255) { egiortes[y++]=alert_str[i++] ; }
                                egiortes[y++]=200;
                                alrm=1;
                                 _realputicon(memox,memoy,mem_memo);
                                // Μήπως κάποιο σήμα προειδοποίησης να σκάσει εδώ ;
                            }
                        
                            // Γράψε σε πόσες ημέρες....
                            i=0;
                            while (seposes[s][i] != 255) { egiortes[y++]=seposes[s][i++] ; }
                            egiortes[y++]=0;
                            
                            // Γράψε το κείμενο της προειδοποίησης
                            i=0;
                            while (pers[f].tex[i] != 255) { egiortes[y++]=pers[f].tex[i++] ; }
                            egiortes[y++]=200;
                            
                            break;
                        }
                    }
                }
                
                // Recursice Προειδοποιήσεις
                for (f=0 ; f<ar_clue ; f++) {
                    if (proclue[f]) {
                        
                        s=proclue[f]-1 ;
                        
                        if (!dx) { // Γράψε ** Προειδοποιήσεις **
                            dx=1;
                            egiortes[y++]=200;
                            i=0;
                            while (alert_str[i] != 255) { egiortes[y++]=alert_str[i++] ; }
                            egiortes[y++]=200;
                            
                            // Μήπως κάποιο σήμα προειδοποίησης να σκάσει εδώ ;
                            alrm=1;
                            _realputicon(memox,memoy,mem_memo);
                        }
                        
                        // Γράψε σε πόσες ημέρες....
                        i=0;
                        while (seposes[s][i] != 255) { egiortes[y++]=seposes[s][i++] ; }
                        egiortes[y++]=0;
                        
                        // Γράψε το κείμενο της προειδοποίησης
                        i=0;
                        while (rcr[f].keim[i] != 255) { egiortes[y++]=rcr[f].keim[i++] ; }
                        egiortes[y++]=200;
                        
                    }
                }
                
                if (y) {y--;egiortes[y]=255;y=0;klear=1;}
                
                                
                for (f=0 ; f<a ; f++) {
                    if (!vrika[f][0]) {
                        k=vrika[f][1];
                        i=0;
                        while ( (ase_aa[i] != k) && (i<ar_son) ) i++;
                        if(i==ar_son) continue;
                        dx=i;
                        
                        do {
                            i=0;
                            while (ase_sonoma[dx][i]!=255) {
                                enames[y++]=ase_sonoma[dx][i++];}
                            enames[y++]=12; enames[y++]=0;dx++;
                            if (dx==ar_son) break ;
                            } while (ase_aa[dx]==k) ;
                        y-=2; enames[y++]=200;
                    }
                    else {
                        i=0;
                        k=vrika[f][1];
                        while ( (ake_aa[i] != k) && (i<ar_kon) ) i++;
                        if(i==ar_kon) continue;
                        dx=i;
                        do {
                            i=0;
                            while (ake_konoma[dx][i]!=255) {
                                enames[y++]=ake_konoma[dx][i++];}
                            enames[y++]=12; enames[y++]=0;dx++;
                            if (dx==ar_kon) break ;
                            } while (ake_aa[dx]==k) ;
                        y-=2; enames[y++]=200;
                    }
                }
                
                
                if (y) {y--; enames[y]=255;klear=1;}
                
                if(klear) {
                    gouv=myfont[eortes_font];
                    eort_cur=onom_cur=0 ;
                    _txt_show (egiortes , 0,eort_recxt+1, eort_recyt+1, eort_recxb-1, eort_recyb-1  , 59998 , genchxr,  genbkxr, ejobkxr);
                    gouv=myfont[names_font];
                    _txt_show (enames , 0,onom_recxt+1, onom_recyt+1, onom_recxb-1, onom_recyb-1  , 19998 , genchxr,  genbkxr, ejobkxr);
                }
                
                
                refresh();
                gyear=uyear; gmonth=umonth; gday=uday;
            }

        if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
            
            
case SDL_WINDOWEVENT :
                  
                if (secwin) {
                    switch (sdlev.window.event) {
                        
                        case SDL_WINDOWEVENT_SHOWN:
                            
                        pran_1 = sdlev.window.windowID ;
                        if ( (pran_1 != sdlwin1) && (pran_1 != sdlwin2) )  {SDL_FlushEvent(SDL_WINDOWEVENT) ; refresh(); continue;}
                        if (pran_1 == pran) {break;}
                        
                        if (pran_1 == sdlwin1) {
                            pran = sdlwin1 ;
                            setcurrentwindow (win_id);
                            memcpy (info_p , info_p3 , size_info);
                            SDL_RaiseWindow(bgi_window);
                        }
                            
                        else {
                            pran = sdlwin2 ;
                            setcurrentwindow(win_id_2) ;
                            memcpy (info_p , info_p2 , size_info);
                            SDL_RaiseWindow(bgi_window);
                            
                        }
                            
                            break;
                            
                        case SDL_WINDOWEVENT_HIDDEN:
                            //sdlev.window.windowID;
                            
                            if (sdlev.window.windowID == sdlwin1) {
                                win1h=1;  
                                if (pran != sdlwin2) {
                                pran = sdlwin2 ;
                                setcurrentwindow (win_id_2);
                                memcpy (info_p , info_p2 , size_info);
                                SDL_RaiseWindow(bgi_window);
                                
                                
                                }
                            }
                            else if (sdlev.window.windowID == sdlwin2) {
                                win2h=1;
                                if (pran!=sdlwin1) {  
                                pran = sdlwin1 ;
                                setcurrentwindow (win_id);
                                memcpy (info_p , info_p3 , size_info);
                                SDL_RaiseWindow(bgi_window);
                                
                            }
                          }

                            break;
                            
                        case SDL_WINDOWEVENT_MINIMIZED:
                           
                            if (sdlev.window.windowID == sdlwin1) {
                                win1m=1; 
                                if (pran != sdlwin2) {
                                pran = sdlwin2 ;
                                setcurrentwindow (win_id_2);
                                memcpy (info_p , info_p2 , size_info);
                                }
                            }
                            else if (sdlev.window.windowID == sdlwin2) {
                                win2m=1;
                                if (pran!=sdlwin1) {  
                                pran = sdlwin1 ;
                                setcurrentwindow (win_id);
                                memcpy (info_p , info_p3 , size_info);    
                            }
                          }
                            
                            break;
                    

                        case SDL_WINDOWEVENT_RESTORED:
                        case SDL_WINDOWEVENT_MAXIMIZED:
                            //SDL_Log("Window %d restored", sdlev.window.windowID);
                            
                            if (sdlev.window.windowID == sdlwin1) {
                                win1h=win1m=0;
                                pran = sdlwin1 ;
                                setcurrentwindow (win_id);
                                memcpy (info_p , info_p3 , size_info); 
                                SDL_ShowWindow (bgi_window);
                                SDL_RaiseWindow(bgi_window);
                                   
                            }
                            else if (sdlev.window.windowID == sdlwin2) {
                                win2h=win2m=0;  
                                pran = sdlwin2 ;
                                setcurrentwindow (win_id_2);
                                memcpy (info_p , info_p2 , size_info); 
                                SDL_ShowWindow (bgi_window);
                                SDL_RaiseWindow(bgi_window);
                                     
                          }

                            break ;
                            
                        case SDL_WINDOWEVENT_ENTER:
                            //"Mouse entered window %d
                            pran_1 = sdlev.window.windowID ;

                            if (pran_1 == pran) break ;

                            if ( (pran_1!=sdlwin1) && (pran_1!=sdlwin2) ) {

                                if (pran == sdlwin1) {
                                setcurrentwindow (win_id);
                                memcpy (info_p , info_p3 , size_info);
                                SDL_RaiseWindow(bgi_window);
                                }

                                else {
                                    setcurrentwindow (win_id_2);
                                    memcpy (info_p , info_p2 , size_info);
                                    SDL_RaiseWindow(bgi_window);
                                }

                                break ;
                            }
                            else {
                               if ( pran == sdlwin1) {
                                   if (dhide) break ;
                                   pran = sdlwin2;
                                    setcurrentwindow (win_id_2);
                                    memcpy (info_p , info_p2 , size_info);
                                    SDL_RaiseWindow(bgi_window);
                                }

                                else {
                                    if (dmetav) break ;
                                    pran = sdlwin1;
                                    setcurrentwindow (win_id);
                                    memcpy (info_p , info_p3 , size_info);
                                    SDL_RaiseWindow(bgi_window);
                                }

                            }
                            break;
                            
                                case SDL_WINDOWEVENT_MOVED:
                                //SDL_Log("Window %d moved to %d,%d",event->window.windowID, event->window.data1,event->window.data2);
                                    pran_1 = sdlev.window.windowID ;
                                    if ( (pran_1 != sdlwin1) && (pran_1 != sdlwin2) )  {SDL_FlushEvent(SDL_WINDOWEVENT) ; continue;}
                                    if (pran_1 == pran) {break;}
                                    
                                    if (pran_1 == sdlwin1) {
                                        pran = sdlwin1 ;
                                        setcurrentwindow (win_id);
                                        memcpy (info_p , info_p3 , size_info);
                                        SDL_RaiseWindow(bgi_window);
                                    }
                                        
                                    else {
                                        pran = sdlwin2 ;
                                        setcurrentwindow(win_id_2) ;
                                        memcpy (info_p , info_p2 , size_info);
                                        SDL_RaiseWindow(bgi_window);
                                        
                                    }
                                
                                break;
                            
                        case SDL_WINDOWEVENT_LEAVE:
                            // Mouse left window sdlev.window.windowID
                        
                            break;

                        case SDL_WINDOWEVENT_CLOSE:
                            //Window %d closed - sdlev.window.windowID
                            if (sdlev.window.windowID == sdlwin2) {
                                //secwin=0;
                                setcurrentwindow (win_id_2);
                                SDL_HideWindow(bgi_window);
                                win2h=1;
                                //closewindow(win_id_2);
                                //SDL_DestroyTexture(bgi_texture);
                                //printf ("%s\n",SDL_GetError());
                                //SDL_DestroyRenderer(bgi_renderer) ;
                                //printf ("%s\n",SDL_GetError());
                                //SDL_DestroyWindow(bgi_window);
                                //printf ("%s\n",SDL_GetError());
                                setcurrentwindow (win_id);
                                memcpy (info_p , info_p3 , size_info);
                                pran = sdlwin1 ;
                                qyear=0;
                                et.k = et1.k = 0 ;
                                etnote=etphoto=etoption=etsvou=etallag=etwinsv=etshowhide=etgoto=etakir=etdiarnote=0;
                            }
                            else if (sdlev.window.windowID == sdlwin1) {
                                if (win2h==1 || win2m==1) {fyge=1; continue; }
                                 if (pran != sdlwin1) break ;
                                fyge=1;
                                continue ;
                            }
                            
                            break;
                    }
                    
                    refresh();
                    continue ;
                    
                }
                else {
                    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                    if (sdlev.window.windowID == sdlwin1){
                    switch (sdlev.window.event) {
                        
                         case SDL_WINDOWEVENT_MINIMIZED:
                            win1m=1;
                            break ;
                            
                        case SDL_WINDOWEVENT_RESTORED:
                        case SDL_WINDOWEVENT_MAXIMIZED:
                            win1h=0; win1m=0;
                            SDL_RaiseWindow(bgi_window);
                            break ;
                            
                        case SDL_WINDOWEVENT_SHOWN:
                            win1h=0;
                            break ;
                            
                        case SDL_WINDOWEVENT_HIDDEN:
                            win1h=1;
                            break;
                            
                        case SDL_WINDOWEVENT_CLOSE:
                            fyge=1;
                            continue ;
                            
                        }}
                    }
                    
                    refresh();
                    /*
                    do {
                        SDL_PollEvent(&sdlev);
                        } while (sdlev.type == SDL_WINDOWEVENT) ;
                      */  
                    
                    continue ;
            
            
            case SDL_MOUSEMOTION:
                
                
              /*  
                if (secwin && (!win2m) && (win2h!=2) ) {
                                  
                    pran_1 = sdlev.window.windowID;
                    if (pran_1 == sdlwin1 || pran_1 == sdlwin2) {
                        if (pran != pran_1) {
                            if (pran == sdlwin2) {
                            pran = sdlwin1 ;
                            setcurrentwindow (win_id);
                            memcpy (info_p , info_p3 , size_info);
                            SDL_RaiseWindow(bgi_window);
                            
                        }
                        else {
                            pran = sdlwin2 ;
                            setcurrentwindow (win_id_2);
                            memcpy (info_p , info_p2 , size_info);
                            SDL_RaiseWindow(bgi_window);
                            
                        }
                        refresh ();
                    }
                }
            }
            */
                   


                //while ( sdlev.type==SDL_MOUSEMOTION ) continue ; 
                //mx1 = sdlev.button.x ; my1= sdlev.button.y ;
                
                
                if (pran == sdlwin2) {

                    if (sdlev.motion.windowID == sdlwin1) { if (dmetav) {SDL_FlushEvent(SDL_MOUSEMOTION) ;} continue ; }
                    mx=sdlev.motion.x ; my=sdlev.motion.y;
                    SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    if (mx<info.left || my<info.top || mx>info.right || my>info.bottom) { continue ;}
                    dmetav=0;

                    auto int p1 , p2 , a1 , b1 ;
                    
                        if (mx>etcaxt && mx<etcaxb && my>etcayt && my<etcayb) { // Στο χώρο των ημερομηνιών
                            
                            if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                            
                            if (etoption) {
                                    if (etnote) {
                                        if (mx>etnx && mx<etnx1 && my>etny && my<etny1) {
                                            if (etsvou) continue;
                                            etsvou=1;
                                            setcolor(4);
                                            rectangle (etnx,etny,etnx1,etny1); refresh();
                                            if (etektos) {
                                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                                            SDL_SetCursor(cursor);
                                            etektos=0;
                                            }
                                            continue ;
                                        }
                                        if (etsvou) {
                                            etsvou=0;
                                            setcolor(2);
                                            rectangle (etnx,etny,etnx1,etny1); refresh();
                                        }
                                    }
                                }
                            
                            
                                    // Ας δούμε που ακριβώς είμαστε...
                                                
                                p1 = p2 = -1 ;
                                mx -= etcaxt ; my -= etcayt;
                                
                                for (i=0 ; i<3 ; i++) {
                                    a1 = (i*420) + (i*40) ;
                                    b1 = a1+420 ;
                                    if (mx>a1 && mx<b1) {p1=i ; break;}
                                }
                                if (p1!=-1) {
                                    
                                    for (f=0; f<4; f++) {
                                        a1 = (f*150) + (f*40) + 25;
                                        b1 = a1 + 125 ;
                                        if (my>a1 && my<b1) {p2 = f; break ;}
                                    }
                                }
                                if (p2!=-1) {
                                    et1.damo[1] = (unsigned char) (p1+1+(p2*3));
                                    a1 = mx - (p1*40) - (p1*420) ;
                                    b1 = my - (p2*150) - (p2*40) - 25 ;
                                    a1 = a1/60;
                                    b1 = b1/25;
                                    et1.damo[0]= (unsigned char) ((b1*7) + a1 + 1) ;
                                    if (et1.damo[0] > etmo[et1.damo[1]]) {p2=-1;}
                                }
                                
                                if (p1==-1 || p2==-1) { // Εκτός κουτιών ημερομηνίας αν και μέσα στο χώρο !!
                                    if (et.k && (!etoption) ) { // Υπάρχει αναμμένο κουτί και αναμμένος μήνας από πριν ??
                                        // Αποκατάσταση στα προηγούμενα AN δεν έχει γίνει επιλογή !
                                        putimage(etkx, etky ,mem_etk , 0 );
                                        normtext_tomy(etmonth[et.damo[1]],str1kb);
                                        a1 = etcomo[et.damo[1]][0];
                                        b1 = etcomo[et.damo[1]][1];
                                        _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                                        _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                                        refresh();
                                    }
                                    
                                    if (!etektos) {
                                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                    SDL_SetCursor(cursor);
                                    etektos=1;
                                    }
                                    if (!etoption) { et.k = et1.k = 0 ;}
                                    else et1.k=0;
                                    continue;
                                }
                                
                                // Είμαστε σίγουρα σε κάποιο κουτί ημερομηνίας !!
                                
                                // Έλεγχος προηγούμενης κατάστασης...
                                
                                
                                                
                                if ( (et.k == et1.k) && (!etoption) ) continue ;
                                
                                if ( (et.k == et1.k) && (etoption) ) {
                                    
                                    if (etektos) {
                                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                                    SDL_SetCursor(cursor);
                                    etektos=0;
                                    }
                                    
                                    continue ;
                                }
                                
                                if (etoption) {   // Δεν έχει νόημα να συνεχίσει εκεί μέσα...
                                    et1.k=0;
                                    
                                    if (!etektos) {
                                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                    SDL_SetCursor(cursor);
                                    etektos=1;
                                    }
                                    
                                    continue ;
                                    
                                }
                                    
                                    // Ψάχνει το νέο κουτί
                                    
                                if (etektos) {
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                                SDL_SetCursor(cursor);
                                etektos=0;
                                }
                                
                                if (et.k) { // Αποκατάσταση προηγούμενου κουτιού - ίσως και μήνα
                                    putimage(etkx, etky , mem_etk , 0 );
                                    if (et1.damo[1] != et.damo[1]) {
                                    normtext_tomy(etmonth[et.damo[1]],str1kb);
                                    a1 = etcomo[et.damo[1]][0];
                                    b1 = etcomo[et.damo[1]][1];
                                    _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                                    _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                                    }
                                    refresh();
                                }
                                
                                // Να βρούμε ακριβώς συνταταγμένες για το νέο κουτί ...
                                
                                a1 = et1.damo[1] / 3 ;
                                b1 = et1.damo[1] % 3 ;

                                a1 = (b1) ? a1 : a1-1 ;
                                etky = etcayt + (a1 * 150) + (a1*40) + 25 ;

                                a1 = et1.damo[1] % 3 ;
                                a1 = (a1) ? a1-1 : 2 ;
                                etkx = etcaxt + (a1*420) + (a1*40) ;

                                a1 = et1.damo[0] / 7 ;
                                b1 = et1.damo[0] % 7 ;

                                b1 = (b1) ? a1 : a1-1 ;
                                etky = etky + (b1*25) +1  ;

                                b1 = et1.damo[0] % 7 ;

                                b1 = (!b1) ? 6 : b1-1 ;
                                etkx = etkx + (b1*60) + 1 ;

                                                        
                                // Εμφάνιση νέου μήνα αν απαιτείται
                                if (et1.damo[1] != et.damo[1]) {
                                    normtext_tomy(etmonth[et1.damo[1]],str1kb);
                                    a1 = etcomo[et1.damo[1]][0];
                                    b1 = etcomo[et1.damo[1]][1];
                                    _bareacls(a1+1,b1+1,a1+209,b1+21,etyelxr);
                                    _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etyelxr);
                                    refresh();
                                }
                                // Άναμα νέου κουτιού
                                
                                getimage(etkx,etky,etkx+58,etky+23,mem_etk) ;
                                _transp_fill (etkx, etky, 58 , 23 , 255 , 255 , 0 , 130);
                                refresh ();
                                
                                et.k = et1.k ;
                                continue ;
                                
                            } // Πέρας Ελέγχου χώρου ημερομηνιών
                
                
                    if ( (et.k) && (!etoption) ) { // Υπάρχει αναμμένο κουτί και αναμμένος μήνας από πριν ??
                        // Αποκατάσταση στα προηγούμενα
                        putimage(etkx, etky ,mem_etk , 0 );
                        normtext_tomy(etmonth[et.damo[1]],str1kb);
                        a1 = etcomo[et.damo[1]][0];
                        b1 = etcomo[et.damo[1]][1];
                        _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                        _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                        et.k = et1.k = 0 ;
                        refresh();
                    }
                    
                    if (mx>etminx && mx<etminx1 && my>etminy && my<etminy1) {
                        if (etwinsv) continue ;
                        if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                        
                        if (etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        etektos=0;
                        }
                        
                        if (etphoto) {
                        etphoto=0;
                        _bareacls(etfotx+1 , etfoty+1 , etfotx1-1 , etfoty1-1 , etbkxr);
                        _outmystr_center_col(2, sosefoto,etfotx+2 , etfoty+2 , etfotx1-1 , etfoty1-1 ,etchxr,etbkxr);
                        refresh();
                        }
                        
                        else if (etallag) {
                        etallag=0;
                        _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                        _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                        refresh();
                        }
                        
                        else if (etgoto) {
                        etgoto=0;
                        _bareacls (etgox+1 , etgoy+1 , etgox1-1 , etgoy1-1 , etbkxr);
                        _outmystr_center_col(2, enallagh,etgox+2 , etgoy+2 , etgox1-1 , etgoy1-1 ,etchxr,etbkxr);
                        refresh();
                        }
                        
                        else if (etakir) {
                        etakir=0;
                        _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , etbkxr);
                        _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,etchxr, etbkxr);
                        refresh();
                        }
                        
                        else if (etdiarnote) { etdiarnote=0; Rputicon(etstikx,etstiky,mem_stik,etbkxr); }
                        
                        etwinsv=1;
                        _bareacls (etminx+1 , etminy+1 , etminx1-1 , etminy1-1 , etyelxr);
                        _outmystr_center_col(2,hidepara,etminx+2,etminy+2,etminx1-1,etminy1-1,redchxr,etyelxr);
                        refresh();
                        continue ;
                    }
                    
                    if (etwinsv) {
                        etwinsv=0;
                        _bareacls (etminx+1 , etminy+1 , etminx1-1 , etminy1-1 , etbkxr);
                        _outmystr_center_col(2,hidepara,etminx+2,etminy+2,etminx1-1,etminy1-1,etchxr,etbkxr);
                        refresh();
                    }
                    
                    if (mx>etfotx && mx<etfotx1 && my>etfoty && my<etfoty1) {
                        if (etphoto) continue ;
                        if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                        if (etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        etektos=0;
                        }
                        
                        if (etallag) {
                        etallag=0;
                        _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                        _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                        refresh();
                        }
                        
                        else if (etgoto) {
                        etgoto=0;
                        _bareacls (etgox+1 , etgoy+1 , etgox1-1 , etgoy1-1 , etbkxr);
                        _outmystr_center_col(2, enallagh,etgox+2 , etgoy+2 , etgox1-1 , etgoy1-1 ,etchxr,etbkxr);
                        refresh();
                        }
                        
                        else if (etakir) {
                        etakir=0;
                        _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , etbkxr);
                        _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,etchxr, etbkxr);
                        refresh();
                        }
                        
                        else if (etdiarnote) { etdiarnote=0; Rputicon(etstikx,etstiky,mem_stik,etbkxr); }
                    
                        etphoto=1;
                        _bareacls(etfotx+1 , etfoty+1 , etfotx1-1 , etfoty1-1 , etyelxr);
                        _outmystr_center_col(2, sosefoto,etfotx+2 , etfoty+2 , etfotx1-1 , etfoty1-1 ,redchxr,etyelxr);
                        refresh();
                        continue ;
                    }
                    
                    if (etphoto) {
                        etphoto=0;
                        _bareacls(etfotx+1 , etfoty+1 , etfotx1-1 , etfoty1-1 , etbkxr);
                        _outmystr_center_col(2, sosefoto,etfotx+2 , etfoty+2 , etfotx1-1 , etfoty1-1 ,etchxr,etbkxr);
                        refresh();
                    }
                    
                    if (qyear>1999 && !etoption && ar_per_1) {
                    if (mx>etmemox && mx<etmemox1 && my>etmemoy && my<etmemoy1) { // Εναλλαγή με ή χωρίς υπομνήσεις
                        if (etallag) continue ;
                        if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                        if (etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        etektos=0;
                        }
                        
                        if (etgoto) {
                        etgoto=0;
                        _bareacls (etgox+1 , etgoy+1 , etgox1-1 , etgoy1-1 , etbkxr);
                        _outmystr_center_col(2, enallagh,etgox+2 , etgoy+2 , etgox1-1 , etgoy1-1 ,etchxr,etbkxr);
                        refresh();
                        }
                        
                        else if (etakir) {
                        etakir=0;
                        _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , etbkxr);
                        _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,etchxr, etbkxr);
                        refresh();
                        }
                        else if (etdiarnote) { etdiarnote=0; Rputicon(etstikx,etstiky,mem_stik,etbkxr); }
                        
                        etallag=1;
                        _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etyelxr);
                        _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,redchxr,etyelxr);
                        refresh();
                        continue ;
                    }
                    
                    if (etallag) {
                        etallag=0;
                        _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                        _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                        refresh();
                    }}
                    
                    if (etoption) {
                    if (mx>etgox && mx<etgox1 && my>etgoy && my<etgoy1) {  // Μετάβαση σε ημερομηνία
                        if (etgoto) continue ;
                        if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                        if (etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        etektos=0;
                        }
                        
                        if (etakir) {
                        etakir=0;
                        _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , etbkxr);
                        _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,etchxr, etbkxr);
                        refresh();
                        }
                        else if (etdiarnote) { etdiarnote=0; Rputicon(etstikx,etstiky,mem_stik,etbkxr); }
                    
                        etgoto=1;
                        _bareacls (etgox+1 , etgoy+1 , etgox1-1 , etgoy1-1 , etyelxr);
                        _outmystr_center_col(2, metabst,etgox+2 , etgoy+2 , etgox1-1 , etgoy1-1 ,redchxr,etyelxr);
                        refresh();
                        continue ;
                    }
                    
                    if (etgoto) {
                        etgoto=0;
                        _bareacls (etgox+1 , etgoy+1 , etgox1-1 , etgoy1-1 , etbkxr);
                        _outmystr_center_col(2, metabst,etgox+2 , etgoy+2 , etgox1-1 , etgoy1-1 ,etchxr,etbkxr);
                        refresh();
                    }
                    
                    if (mx>etakx && mx<etakx1 && my>etaky && my<etaky1) {
                        if (etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        etektos=0;
                        }
                        
                    if (etdiarnote) { etdiarnote=0; Rputicon(etstikx,etstiky,mem_stik,etbkxr); }
                        
                        if (etakir) continue ;
                        etakir=1;
                        _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , etyelxr);
                        _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,redchxr, etyelxr);
                        refresh();
                        continue ;
                    }
                    
                    if (etakir) {
                        etakir=0;
                        _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , etbkxr);
                        _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,etchxr, etbkxr);
                        refresh();
                    }
                }
                
                if (et_is_note==1) {
                    
                    if (mx>=etstikx && mx<=etstikx+34 && my>=etstiky && my<=etstiky+22) {
                        
                        if (etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        etektos=0;
                        }
                        
                        if (etdiarnote) continue ;
                        
                        etdiarnote=1;
                        ROputicon (etstikx,etstiky,mem_stik,etbkxr);
                        // Καταχώρηση Ημερολογίου
                        show_help(" Καταχώρηση Ημερολογίου ", etstikx + 37 , etstiky , &hdhlpxt , &hdhlpyt) ;
                        continue ;
                    }
                
                if (etdiarnote) {
                    etdiarnote=0;
                    if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                    Rputicon(etstikx,etstiky,mem_stik,etbkxr);
                }
            } 
                
                    
                    et1.k = 0 ;
                    if (!etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                        SDL_SetCursor(cursor);
                        etektos=1;
                        }
                    continue ;
                }
        
                if (sdlev.motion.windowID == sdlwin2) {if (dhide) {SDL_FlushEvent(SDL_MOUSEMOTION) ;}  continue ;}
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                SDL_FlushEvent(SDL_MOUSEMOTION) ;
                if (mx<info.left || my<info.top || mx>info.right || my>info.bottom) { continue ;}
                dhide = 0 ;
                if (mx>caxt && mx<caxb && my>cayt && my<cayb) { // Motion into Panel
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0; 
                    }
                    
                    if (promonbox!=-1) {
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                        line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                        refresh();
                        promonbox=monbox=-1;
                    }
                    else if (inpyear) {
                        inpyear=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                        refresh();
                    }
                    else if (inpmonth) {
                        inpmonth=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                        refresh();
                    }
                    else if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    //else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
    
                    if (!panel) {
                        panel=1;
                        setrgbcolor(dbmag);
                        rectangle (caxt,cayt,caxb,cayb);
                        refresh();
                    }
                    if (my<cy[1]) box=-1;
                    else {
                    dx=(mx-caxt)/60; dy=(my-cy[1])/25;
                    box=(dy*7)+dx+1;}
                    
                    if (box==probox) continue ;
                    if (!specmonth){
                        if (probox!=-1) {
                            a=(probox/7)+1 ; b=probox%7 ;
                            if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                            if (probox!=uday) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            else {
                            setcolor (COLOR(ejobkxr[0],ejobkxr[1],ejobkxr[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            refresh();
                        }
                        if (box>mo[umonth] || box==-1) {box=probox=-1;continue;}
                        //if (box!=uday) setrgbcolor(dbyel); else setrgbcolor(dbblack);
                        if (box!=uday) setcolor (COLOR(ejobkxr[0],ejobkxr[1],ejobkxr[2])); else setrgbcolor(dbblack);
                        rectangle (cx[dx+1]+1,cy[dy+1]+1,cx[dx+1]+59,cy[dy+1]+24);
                        rectangle (cx[dx+1]+2,cy[dy+1]+2,cx[dx+1]+58,cy[dy+1]+23);
                        refresh();
                        probox=box;
                        continue;
                    }
                    else { // specmonth=1 - Okt 1582

                        if (probox!=-1) {
                            
                            a=(probox/7)+1 ; b=probox%7 ;
                            if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                            c=(probox<5) ? 0 : 4 ;
                            
                            if (probox!=uday+c) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            else {
                            setcolor (COLOR(ejobkxr[0],ejobkxr[1],ejobkxr[2]));   
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            
                            refresh();
                        }
                        if (box>4 && box<19) {box=probox=-1;continue;}
                        if (box==-1) {box=probox=-1;continue;}
                        c=(box<5) ? 0 : 4 ;
                        //if (box!=uday+c) setrgbcolor(dbyel); else setrgbcolor(dbblack);
                        if (box!=uday+c) setcolor (COLOR(ejobkxr[0],ejobkxr[1],ejobkxr[2])); else setrgbcolor(dbblack);
                        rectangle (cx[dx+1]+1,cy[dy+1]+1,cx[dx+1]+59,cy[dy+1]+24);
                        rectangle (cx[dx+1]+2,cy[dy+1]+2,cx[dx+1]+58,cy[dy+1]+23);
                        refresh();
                        probox=box;
                        
                    }
                    continue ;
                }
                
                if (panel) {
                    panel=0;
                    setrgbcolor(dbaspro);
                    rectangle (caxt,cayt,caxb,cayb);
                    if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                    else c=0;
                    if (probox!=-1) {
                        a=(probox/7)+1 ; b=probox%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        if (probox!=uday+c) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                        }
                        else {
                            setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                        }
                        box=probox=-1;
                    }
                    refresh();
                }
                
                if (mx>mhnxt && mx<mhnxb && my>mhnyt[1] && my<mhnyb[12]) { // into 12 months
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (inpyear) {
                        inpyear=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                        refresh();
                    }
                    else if (inpmonth) {
                        inpmonth=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                        refresh();
                    }
                    else if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    //else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    monbox=((my-mhnyt[1])/30) + 1;
                    if (monbox>12) monbox=12;
                    if (promonbox==monbox) continue ;
                    if (promonbox!=-1) {
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                        line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                    }
                    setrgbcolor(dbmag);
                    rectangle (mhnxt,mhnyt[monbox],mhnxb,mhnyb[monbox]);
                    line(mhnxt-1,mhnyt[monbox]+1,mhnxt-1,mhnyb[monbox]+1);
                    line(mhnxt-1,mhnyb[monbox]+1,mhnxb,mhnyb[monbox]+1);
                    promonbox=monbox;
                    refresh();
                    continue;
                }
                
                if (promonbox!=-1) {
                    setrgbcolor(dbaspro);
                    rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                    line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                    refresh();
                    promonbox=monbox=-1;
                }                
                

                if (mx>inpyearxt && mx<inpyearxb && my>inpyearyt && my<inpyearyb) { // into inpyear
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                if (inpmonth) {
                    inpmonth=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                }
                else if (inpday) {
                    inpday=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                }
                else if (adddays) {
                    adddays=0;
                    setrgbcolor(dbaspro);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                }
                //else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (inpyear) continue;
                    inpyear=1;
                    setrgbcolor(dbmag);
                    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                    rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpyear) {
                    inpyear=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                    refresh();
                }
                
                
                if (mx>inpmonthxt && mx<inpmonthxb && my>inpmonthyt && my<inpmonthyb) { // into inmonth
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    //else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (inpmonth) continue;
                    inpmonth=1;
                    setrgbcolor(dbmag);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpmonth) {
                    inpmonth=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                }
                
                
                if (mx>inpdayxt && mx<inpdayxb && my>inpdayyt && my<inpdayyb) { // into inpday
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    //else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (inpday) continue;
                    inpday=1;
                    setrgbcolor(dbmag);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpday) {
                    inpday=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                }
                
                
                if (mx>adddaysxt && mx<adddaysxb && my>adddaysyt && my<adddaysyb) { // into adddays
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    //if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (adddays) continue;
                    adddays=1;
                    setrgbcolor(dbmag);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (adddays) {
                    adddays=0;
                    setrgbcolor(dbaspro);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                }
                   

                if (mx>leyearxt && mx<leyearxt+26 && my>leyearyt && my<leyearyt+26) { // Left Year
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (leyear) continue ;
                    leyear=1;
                    putNOTicon(leyearxt,leyearyt,mem_le);
                    continue ;
                }
        
                if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                
                
                if (mx>riyearxt && mx<riyearxt+26 && my>riyearyt && my<riyearyt+26) { // Right Year
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (riyear) continue ;
                    riyear=1;
                    putNOTicon(riyearxt,riyearyt,mem_ri);
                    continue ;
                }
        
                if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                
                
                if (mx>ledayxt && mx<ledayxt+26 && my>ledayyt && my<ledayyt+26) { // Left day
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                                        
                    if (leday) continue ;
                    leday=1;
                    putNOTicon(ledayxt,ledayyt,mem_le);
                    continue ;
                }
        
                if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                
                
                if (mx>ridayxt && mx<ridayxt+26 && my>ridayyt && my<ridayyt+26) { // Right day
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                                        
                    if (riday) continue ;
                    riday=1;
                    putNOTicon(ridayxt,ridayyt,mem_ri);
                    continue ;
                }
        
                if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                
                
                if (mx>putokxt && mx<putokxt+30 && my>putokyt && my<putokyt+30) { // Put OK !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                                        
                    if (putok) continue ;
                    putok=1;
                    putNOTicon(putokxt,putokyt,mem_ok);
                    if (year_t[0]!=255) {show_help(" Κλικ για Μετάβαση ", putokxt,putokyt+35, &hdhlpxt , &hdhlpyt) ;}
                    continue ;
                }
        
                if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255);if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                
                
                if (mx>addokxt && mx<addokxt+30 && my>addokyt && my<addokyt+30) { // Add OK !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                                        
                    if (addok) continue ;
                    addok=1;
                    putNOTicon(addokxt,addokyt,mem_ok);
                    if (prosadd!=0) {show_help(" Κλικ για Μετάβαση ", addokxt,addokyt+35, &hdhlpxt , &hdhlpyt) ;}
                    continue ;
                }
        
                if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                         
                
                if (mx>akyroxt && mx<akyroxt+69 && my>akyroyt && my<akyroyt+19) { // ΜΕΝΟΥ ΜΕΝΟΥ !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    
                    if (pronow) {
                        pronow=0; 
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh(); 
                    }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (akyro) continue ;
                    akyro=1;
                    putNOTicon(akyroxt,akyroyt,mem_akyro);
                    continue ;
                }
                
                if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                
                
                if (!nowon) {
                    if (mx>recshmxt && mx<recshmxb && my>recshmyt && my<recshmyb) { // SHMERA !
                        
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                        if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (sbou) {
                        sbou=0;
                        inpx-=3 ; inpx1+=3; inpy1+=3;
                        setcolor(2);
                        line (inpx+1,yt+11,movext-1,yt+11);
                        line (inpx+1,yt+11,inpx+1,inpy1-1);
                        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                        line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                        line (inpx1-1,yt+11,inpx1-358,yt+11);
                        setcolor(5);
                        line (inpx+2,yt+12,movext-1,yt+12);
                        line (inpx+2,yt+12,inpx+2,inpy1-2);
                        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                        line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                        line (inpx1-2,yt+12,inpx1-358,yt+12);
                        refresh();
                        inpx+=3 ; inpx1-=3; inpy1-=3;
                    }
                    else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                                            
                        if (pronow) continue ;
                        pronow=1;
                        setrgbcolor(dbred);
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh();
                        continue ;
                    }
            
                    if (pronow) {
                        pronow=0; 
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh(); 
                    }
                }
                
                if (flaggryes) {
                    if (mx>flaggrxt && mx<flaggrxt+25 && my>flaggryt && my<flaggryt+26) {
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                    if (sbou) {
                    sbou=0;
                     inpx-=3 ; inpx1+=3; inpy1+=3;
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                    refresh();
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                }
                else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                else if (diak1b) {
                    diak1b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                    if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                    else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                }
                else if (diak2b) {
                    diak2b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                    if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                    else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                }
                        
                        if (flaggr) continue;
                        flaggr=1;
                        putNOTicon (flaggrxt,flaggryt,mem_flgr);
                        if (keyb_gr) show_help("  Επέκταση  Ιουλιανού  Ημερολογίου  από  Οκτ  1582  μέχρι  το  1923..  ", flaggrxt,flaggryt+28, &hdhlpxt , &hdhlpyt) ;
                        else show_help(" Extension of the Julian calendar from Oct 1582 to year 1923... ", flaggrxt,flaggryt+28, &hdhlpxt , &hdhlpyt) ;
                        continue;
                    }
                    
                    if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255); hide_help(hdhlpxt , hdhlpyt);}

                }
                
                if (mx>onom_recxt && mx<onom_recxb && my>onom_recyt && my<onom_recyb) {  // Στα ονόματα...
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                     if (sbou) {
                    sbou=0;
                     inpx-=3 ; inpx1+=3; inpy1+=3;
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                    refresh();
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                }
                else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                else if (diak1b) {
                    diak1b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                    if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                    else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                }
                else if (diak2b) {
                    diak2b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                    if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                    else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                }
                    
                    setcolor(1);
                    rectangle (onom_recxt-1, onom_recyt-1, onom_recxb+1, onom_recyb+1);
                    rectangle (onom_recxt-2, onom_recyt-2, onom_recxb+2, onom_recyb+2);
                    gouv=myfont[names_font];
                    Rclik = 0 ;
                    dx=txt_scroll_min (enames, onom_cur, onom_recxt+1, onom_recyt+1, onom_recxb-1, onom_recyb-1 ,19998, &Rclik, genchxr,  genbkxr, ejobkxr);
                    onom_cur= (unsigned short int) ((abs) (dx-1)) ;
                    //_txt_show (enames , onom_cur,onom_recxt+1, onom_recyt+1, onom_recxb-1, onom_recyb-1  , 19998 , genchxr,  genbkxr, genbkxr);
                    setcolor(2);
                    rectangle (onom_recxt-2, onom_recyt-2, onom_recxb+2, onom_recyb+2);
                    setcolor(5);
                    rectangle (onom_recxt-1, onom_recyt-1, onom_recxb+1, onom_recyb+1);
                    refresh();
                    if (Rclik) {
                        Header = "Γραμματοσειρά για Ονόματα που Εορτάζουν";
                        Rclik=0;
                        slxr[0]=99; slxr[1]=186; slxr[2]=95;
                        user_ans=fonts_show(names_font, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, genchxr, genbkxr, slxr );
                        Header = (char *) NULL ;
                        ektos=1;
                        if (user_ans>=0) {
                        names_font = user_ans ;
                        gouv=myfont[names_font];
                        _txt_show (enames , onom_cur, onom_recxt+1, onom_recyt+1, onom_recxb-1, onom_recyb-1  , 19998 , genchxr,  genbkxr, ejobkxr);
                        refresh();
                        }
                    }
                }
                
                if (mx>eort_recxt && mx<eort_recxb && my>eort_recyt && my<eort_recyb) {  // Στις γιορτές...
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                     if (sbou) {
                    sbou=0;
                     inpx-=3 ; inpx1+=3; inpy1+=3;
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                    refresh();
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                }
                else if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                else if (diak1b) {
                    diak1b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                    if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                    else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                }
                else if (diak2b) {
                    diak2b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                    if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                    else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                }
                
                    setcolor(1);
                    rectangle (eort_recxt-1, eort_recyt-1, eort_recxb+1, eort_recyb+1);
                    rectangle (eort_recxt-2, eort_recyt-2, eort_recxb+2, eort_recyb+2);
                    gouv=myfont[eortes_font];
                    Rclik=0;
                    dx=txt_scroll_min (egiortes, eort_cur, eort_recxt+1, eort_recyt+1, eort_recxb-1, eort_recyb-1 ,59998, &Rclik, genchxr,  genbkxr, ejobkxr );
                    eort_cur= (unsigned short int) ((abs) (dx-1)) ;
                    //_txt_show (egiortes , eort_cur,eort_recxt+1, eort_recyt+1, eort_recxb-1, eort_recyb-1  , 9998 , genchxr,  genbkxr, genbkxr);
                    setcolor(2);
                    rectangle (eort_recxt-2, eort_recyt-2, eort_recxb+2, eort_recyb+2);
                    setcolor(5);
                    rectangle (eort_recxt-1, eort_recyt-1, eort_recxb+1, eort_recyb+1);
                    refresh();
                    if (Rclik) {
                        Header = "Γραμματοσειρά Εορτών και Επετείων" ;
                        Rclik=0;
                        slxr[0]=99; slxr[1]=186; slxr[2]=95;
                        user_ans=fonts_show(eortes_font, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, genchxr, genbkxr, slxr );
                        Header = (char *) NULL ;
                        if (user_ans>=0) {
                        eortes_font = user_ans ;
                        gouv=myfont[eortes_font];
                        _txt_show (egiortes , eort_cur ,eort_recxt+1, eort_recyt+1, eort_recxb-1, eort_recyb-1  , 59998 , genchxr,  genbkxr, ejobkxr);
                        refresh();
                        }
                        ektos=1;
                    }
                    
                }
                
                if (inpbox) {
                if (mx>inpx && mx<inpx1 && my>inpy && my<inpy1) {  // Στις σημειώσεις...
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (diarnote) { diarnote=0; hide_help(hdhlpxt , hdhlpyt); Rputicon(stikx,stiky,mem_stik,ejobkxr); }
                    else if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    else if (diak2b) {
                        diak2b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                        if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                        else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (sbou) continue ;
                    
                    movext=xt+360;
                    inpx-=3 ; inpx1+=3; inpy1+=3;
                    
                    setcolor(1);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);

                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                                     
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                    refresh();
                    
                    if (notes_str[0]==255) {sbou=1; continue ;}
                    sbou=0;
                    
                    trampa=gouv;
                    gouv=myfont[notes_font];
                    Rclik=0;
                    dx=txt_scrollsearch (notes_str, inp_cur, inpx, inpy, inpx1, inpy1 ,60000, &Rclik, olochxr, notesbkxr, ejobkxr);
                    inp_cur = (unsigned short int) ((abs) (dx-1)) ;                    
                    
                    if (dx<0) {
                    bareacls(inpx1+4,inpy,inpx1+15,inpy1,ejobkxr); //σβήνει βελάκια...
                    inpx-=3 ; inpx1+=3; inpy1+=3;
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                    refresh();
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                    
                    bkxr[0]=notesbkxr[0]; bkxr[1]=notesbkxr[1]; bkxr[2]=notesbkxr[2]; 
                    chxr[0]=noteschxr[0]; chxr[1]=noteschxr[1]; chxr[2]=noteschxr[2];
                    //slxr[0]=66;slxr[1]=33;slxr[2]=66;
                    slxr[0]=112;slxr[1]=0;slxr[2]=0;
                    
                    strcpy (submenu[0],"Κλήση ΔΙΑΔΙΚΤΥΑΚΟΥ συνδέσμου με Firefox");
                    strcpy (submenu[1],"Κλήση ΔΙΑΔΙΚΤΥΑΚΟΥ συνδέσμου με Google-Chrome");
                    gouv=myfont[notes_font];

                    ix=inpx-1; ; iy=yt ;  ix1=inpx1 ; iy1=inpy1 ; 
                    
                    metr=input(notes_str, &ix, &iy, &ix1, &iy1, 60000, -1,inp_cur);
                    while (metr<0) metr=input(notes_str, &ix, &iy, &ix1, &iy1, 60000 , -1,0);
                    inp_cur = (unsigned short int) metr;                                   
                    
                    for (f=0;f<3;f++) {
                        bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
                    }
                    gouv=trampa;    
                    ektos=1;
                    gouv=myfont[notes_font];
                    _txt_show (notes_str , inp_cur, inpx, inpy ,inpx1 , inpy1 , 60000 , olochxr, notesbkxr, ejobkxr);
                    refresh();
                    strcpy (submenu[0],"ΑΝΤΙΓΡΑΦΗ στοιχείων ημέρας στον Clipboard");
                    strcpy (submenu[1],"Αναζήτηση ονόματος (ελεύθερη)");
                    continue ;
                    }
                    else {
                    gouv=trampa ;
                    inpx-=3 ; inpx1+=3; inpy1+=3;
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                    refresh();
                    inpx+=3 ; inpx1-=3; inpy1-=3;

                    }
                    if (Rclik) {
                        Header = "Γραμματοσειρά Σημειώσεων & Ημερολογίου" ;
                        Rclik=0;
                        slxr[0]=32; slxr[1]=0; slxr[2]=180;
                        user_ans=fonts_show(notes_font,Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, noteschxr, notesbkxr, slxr );
                        Header = (char *) NULL ;
                        ektos=1;
                        if (user_ans<0) continue;
                        notes_font = user_ans ;
                        gouv=myfont[notes_font];
                        _txt_show (notes_str , inp_cur, inpx, inpy ,inpx1 , inpy1 , 60000 , olochxr, notesbkxr, ejobkxr);
                        refresh();
                    }
                    continue ;
                }
                }
                
                if (sbou) {
                    sbou=0;
                     inpx-=3 ; inpx1+=3; inpy1+=3;
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                    refresh();
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                }
                
                if (there_is_note) {
                    if (mx>=stikx && mx<=stikx+34 && my>=stiky && my<=stiky+22) {  // Στο εικονίδιο καταχώργης ημερολογίου...
                    
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                        if (diak1b) {
                            diak1b=0;
                            setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                            line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                            if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                            else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                        }
                        else if (diak2b) {
                            diak2b=0;
                            setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                            if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                            else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                        }
                            
                        if (diarnote) continue ;
                        diarnote = 1 ;
                        ROputicon (stikx,stiky,mem_stik,ejobkxr);
                        // Καταχώρηση Ημερολογίου
                        show_help(" Καταχώρηση Ημερολογίου ", stikx + 47 , stiky , &hdhlpxt , &hdhlpyt) ;
                        continue ;
                    }
                    
                    if (diarnote) {
                        diarnote=0;
                        if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                        Rputicon(stikx,stiky,mem_stik,ejobkxr);
                    }
                    
                }
                
                
                if (mx>=diak2x && mx<=diak2x+41 && my>=diak2y && my<= diak2y+22) { // Στο διακόπτη ΟΝ-OFF των επισημάνσεων ημερολογίου
                    
                    auto int apocol[3] , proscol[3] ;
                    
                    apocol[0] = apocol[1] = apocol[2] = 73 ;
                    proscol[0] = 200; proscol[1] = proscol[2] = 0 ;
                        
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (diak1b) {
                        diak1b=0;
                        setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                        line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17);
                        if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                        else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                    }
                    
                    if (diak2b) continue ;
                    diak2b=1;
                    setcolor (COLOR(162, 57,0));
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                    if (DIAK2) { change_col (diak2x,diak2y,mem_diak2on , apocol , proscol) ; }
                    else { change_col (diak2x,diak2y,mem_diakoff , apocol , proscol) ; }

                    continue ;
                }
                
                if (diak2b) {
                    diak2b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak2x+43 , diak2y+17 , diak2x+207 , diak2y+17);
                    if (DIAK2) { Rputicon (diak2x,diak2y,mem_diak2on , ejobkxr) ; }
                    else { Rputicon (diak2x,diak2y,mem_diakoff , ejobkxr) ; }
                }
                
                
                
                if (mx>=diak1x && mx<=diak1x+41 && my>=diak1y && my<= diak1y+22) { // Στο διακόπτη ΟΝ-OFF των επισημάνσεων ημερολογίου
                    
                    auto int apocol[3] , proscol[3] ;
                    
                    apocol[0] = apocol[1] = apocol[2] = 73 ;
                    proscol[0] = 200; proscol[1] = proscol[2] = 0 ;
                        
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (diak1b) continue ;
                    diak1b=1;
                    setcolor (COLOR(0, 255, 255)) ;
                    line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17); 
                    if (DIAK1) { change_col (diak1x,diak1y,mem_diak1on , apocol , proscol) ; }
                    else { change_col (diak1x,diak1y,mem_diakoff , apocol , proscol) ; }

                    continue ;
                }
                
                if (diak1b) {
                    diak1b=0;
                    setcolor (COLOR(ejobkxr[0], ejobkxr[1], ejobkxr[2])) ;
                    line (diak1x+43 , diak1y+17 , diak1x+205 , diak1y+17); 
                    if (DIAK1) { Rputicon (diak1x,diak1y,mem_diak1on , ejobkxr) ; }
                    else { Rputicon (diak1x,diak1y,mem_diakoff , ejobkxr) ; }
                }
                
            // ΤΕΛΟΣ ΤΑ ΠΙΘΑΝΑ ΣΗΜΕΙΑ !!
                if (!ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                ektos=1;
                }
                
            break ; // Πέρας mousemotion
            
            case SDL_MOUSEBUTTONDOWN:
                
              /*
                if (secwin && (!win2m) ) {
                                  
                    pran_1 = sdlev.window.windowID;
                    if (pran_1 == sdlwin1 || pran_1 == sdlwin2) {
                        if (pran != pran_1) {
                            if (pran == sdlwin2) {
                            pran = sdlwin1 ;
                            setcurrentwindow (win_id);
                            memcpy (info_p , info_p3 , size_info);
                            SDL_RaiseWindow(bgi_window);
                            
                        }
                        else {
                            pran = sdlwin2 ;
                            setcurrentwindow (win_id_2);
                            memcpy (info_p , info_p2 , size_info);
                            SDL_RaiseWindow(bgi_window);
                            
                        }
                        refresh ();
                    }
                }
            }
            */

            //while ( (SDL_PollEvent(&sdlev)) && (sdlev.type==SDL_MOUSEBUTTONDOWN) ) continue ;    
                
            //SDL_FlushEvent(SDL_MOUSEBUTTONDOWN) ;
            
            if (pran == sdlwin2) {
                auto int a1 , b1 , ks , h , w , etmot , etfat , kk , kp , kep , kep_1 ;
                auto unsigned char petsok[102];
                auto int locbkxr [3] ;
                dmetav=0;
                if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                
                locbkxr[0]=olobkxr[0] ; locbkxr[1] = olobkxr[1] ; locbkxr[2] = olobkxr[2] ;
                
                if (sdlev.button.windowID == sdlwin1) continue ;
                mx=sdlev.button.x ; my=sdlev.button.y;
                SDL_FlushEvent(SDL_MOUSEBUTTONDOWN) ;

                if ( (et_is_note==1) && (etdiarnote) ) { // Κλικ στο εικονίδιο καταχώρησης ημερολογίου
                    
                    
                    auto void *mem_scr_note = NULL ;
                    auto int ntx , nty , nth , nty1 , ntx1 ;
                    short int area[4] ;
                    auto int etanatcol [3] ;
                       
                    etanatcol[0] = etanatcol[1] = 255 ; etanatcol[2] = 0 ;
                    sprintf(str1kb,"%s%d/%s.dry",Diary_path,(int) qyear, etdiary_filename);   
                    
                    fp=fopen(str1kb,"rb");
                    if (fp!=NULL) {
                        i=0;
                        fread (&what,1,1,fp);
                        do {
                            if (what<164 || what==200) {diary_notes[i++]=what ;}
                            fread(&what,1,1,fp);
                        }while (what!=255 && i<60000);
                        diary_notes[i]=255;
                        fclose(fp);
                    }
                    else {
                        diary_notes[0] = 255 ;
                    }
                    
                    if (diary_notes[0] == 255) {
                        et_is_note = 0 ;
                        bareacls(etstikx,etstiky,etstikx+34,etstiky+22,locbkxr);
                        etdiarnote=0;
                        etektos=1 ;
                        continue ;
                    }
                        
                    
                    ntx = etstikx + 36 ; nty = etstiky + 11 ;
                    if (i<=500) { nth=200; ntx1 = ntx + 400; }
                    else if (i<1000) { nth=250; ntx1 = ntx + 450; }
                    else if (i<2500) { nth=300 ; ntx1 = ntx + 500; }
                    else if (i<5000) { nth=400; ntx1 = ntx + 550; }
                    else { nth=500; ntx1 = ntx + 600; }
                    nty1 = nty + nth ;
                    area[0] = 0; area[2] = ntx1+10 ; area[1] = 0 ; area[3] = nty1+10 ;
                    mem_scr_note = malloc (imagesize (ntx, nty, ntx1 , nty1)) ;
                    if (mem_scr_note != NULL) {
                        
                        getimage (ntx, nty , ntx1 , nty1 , mem_scr_note);
                        bareacls (ntx , nty , ntx1 , nty1 , locbkxr) ;
                        setcolor (1);
                        
                        rectangle (ntx , nty , ntx1 , nty1);
                        rectangle (ntx+1 , nty+1 , ntx1-1 , nty1-1);
                        sprintf (str1kb,"Καταχώρηση Ημερολογίου της %02d/%02d/%04d", (int) et.damo[0], (int) et.damo[1] , qyear);
                        normtext_tomy (str1kb,0);
                        bareacls(ntx+3 , nty+2 , ntx1-3, nty+21,black);
                        _outmystr_center_col(neohell_18n, str1kb, ntx+7 , nty+2 , ntx1-3, nty+22, etanatcol,black);
                        bareacls (ntx+6 , nty+22 , ntx1-6 , nty1-6 , white) ;
                        trampa=gouv;
                        gouv=myfont[notosans_16n];
                        et_werp = field_txt_scroll (diary_notes , et_werp , ntx+6 , nty+22 , ntx1-20 , nty1-6 , 60000 , black, white, area) ; 
                        putimage (ntx,nty,mem_scr_note,0) ; refresh();
                        gouv=trampa;
                        free (mem_scr_note) ;
                    
                    } else { printf ("Out of memory..!!\n"); }
                    
                    etdiarnote=0;
                    Rputicon(etstikx,etstiky,mem_stik,locbkxr);
                    etektos=1;
                    continue ;
                }
                
                if ( (etoption) && (etsvou) ) { // Σβήνω πρώην επιλεγμένη ημερομ.
                    etoption = 0;
                    etsvou = 0;
                    
                    if (etnote) {
                        etnote=0;
                        putimage (etnx,etny,mem_et800,0);
                    }
                    
                    
                    if (et_is_note) {
                       et_is_note = 0 ;
                       _bareacls(etstikx,etstiky,etstikx+34,etstiky+22,locbkxr);
                    }
                    
                    //if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                    
                    // Καθαρίζω πινακίδα ημερομηνίας
                    _bareacls(etdatex+1 , etdatey+1 , etdatex1-1 , etdatey1-1 , etyelxr);
                    
                    // Καθαρίζω στοιχεία φωτός
                    _bareacls (etfosx , etfosy , etfosx1, etfosy1, locbkxr) ;
                    _bareacls (etskotx , etskoty , etskotx1, etskoty1, locbkxr) ;
                    _bareacls (etlunarx , etsely , etselx1 , etsely1, locbkxr) ;
                    
                    // Γκριζάρω πινακίδες μετάβαση - ακύρωση
                    _bareacls(etgox+1 , etgoy+1 , etgox1-1, etgoy1-1 , genbkxr);
                    _outmystr_center_col(2, metabst, etgox+2 , etgoy+2 , etgox1-1, etgoy1-1 ,black,genbkxr);
                    _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , genbkxr);
                    _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,black, genbkxr);
                    
                    if (qyear>1999 && ar_per_1) {
                    // Ενεργοποιώ πινακίδα δείξε-σβήσε υπομνήσεις
                    _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                    _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                    }
                    
                    // Αποκαθιστώ οθόνη
                    putimage(etkx, etky , mem_etk , 0 );
                    normtext_tomy(etmonth[et.damo[1]],str1kb);
                    a1 = etcomo[et.damo[1]][0];
                    b1 = etcomo[et.damo[1]][1];
                    _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                    _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                    refresh();
                    et.k = et1.k =0 ;
                    continue ;
                }
                
                if ( (et.k) && (etoption) && (etakir)) {  // Ακυρωση επιλογης με πινακίδα ακύρωση
                    
                    auto int locbkxr [3] ;
                    locbkxr[0]=olobkxr[0] ; locbkxr[1] = olobkxr[1] ; locbkxr[2] = olobkxr[2] ;
                    
                    etakir = 0 ;
                    
                    if (etnote) {
                        etnote=0;
                        putimage (etnx,etny,mem_et800,0);
                    }
                    
                    if (et_is_note) {
                       et_is_note = 0 ;
                       _bareacls(etstikx,etstiky,etstikx+34,etstiky+22,locbkxr);
                    }
                    
                    //if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                    
                    // Καθαρίζω πινακίδα ημερομηνίας
                    _bareacls(etdatex+1 , etdatey+1 , etdatex1-1 , etdatey1-1 , etyelxr);
                    
                    // Καθαρίζω στοιχεία φωτός
                    _bareacls (etfosx , etfosy , etfosx1, etfosy1, locbkxr) ;
                    _bareacls (etskotx , etskoty , etskotx1, etskoty1, locbkxr) ;
                    _bareacls (etlunarx , etsely , etselx1 , etsely1, locbkxr) ;
                    
                    // Γκριζάρω πινακίδες μετάβαση - ακύρωση
                    _bareacls(etgox+1 , etgoy+1 , etgox1-1, etgoy1-1 , genbkxr);
                    _outmystr_center_col(2, metabst, etgox+2 , etgoy+2 , etgox1-1, etgoy1-1 ,black,genbkxr);
                    _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , genbkxr);
                    _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,black, genbkxr);
                    
                    if (qyear>1999 && ar_per_1) {
                    // Ενεργοποιώ πινακίδα δείξε-σβήσε υπομνήσεις
                    _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                    _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                    }
                    
                    putimage(etkx, etky , mem_etk , 0 );
                    normtext_tomy(etmonth[et.damo[1]],str1kb);
                    a1 = etcomo[et.damo[1]][0];
                    b1 = etcomo[et.damo[1]][1];
                    _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                    _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                    refresh();
                    et.k = et1.k =0 ;
                    etoption = etsvou = 0 ; 
                    continue ;
                }
                
                if ( (et.k) && (etoption) && (et.k==et1.k) ) {     // Υπήρχε επιλογή που θέλω να σβηστεί
                    
                    auto int locbkxr [3] ;

                    locbkxr[0]=olobkxr[0] ; locbkxr[1] = olobkxr[1] ; locbkxr[2] = olobkxr[2] ;
                    
                    if (etnote) {
                        etnote=0;
                        putimage (etnx,etny,mem_et800,0);
                    }
                    
                    if (et_is_note) {
                       et_is_note = 0 ;
                       _bareacls(etstikx,etstiky,etstikx+34,etstiky+22,locbkxr);
                    }
                    
                    //if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                    
                    // Καθαρίζω πινακίδα ημερομηνίας
                    _bareacls(etdatex+1 , etdatey+1 , etdatex1-1 , etdatey1-1 , etyelxr);
                    
                    // Καθαρίζω στοιχεία φωτός
                    _bareacls (etfosx , etfosy , etfosx1, etfosy1, locbkxr) ;
                    _bareacls (etskotx , etskoty , etskotx1, etskoty1, locbkxr) ;
                    _bareacls (etlunarx , etsely , etselx1 , etsely1, locbkxr) ;
                    
                    // Γκριζάρω πινακίδες μετάβαση - ακύρωση
                    _bareacls(etgox+1 , etgoy+1 , etgox1-1, etgoy1-1 , genbkxr);
                    _outmystr_center_col(2, metabst, etgox+2 , etgoy+2 , etgox1-1, etgoy1-1 ,black,genbkxr);
                    _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , genbkxr);
                    _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,black, genbkxr);
                    
                    if (qyear>1999 && ar_per_1) {
                    // Ενεργοποιώ πινακίδα δείξε-σβήσε υπομνήσεις
                    _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                    _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                    }
                    
                    putimage(etkx, etky , mem_etk , 0 );
                    normtext_tomy(etmonth[et.damo[1]],str1kb);
                    a1 = etcomo[et.damo[1]][0];
                    b1 = etcomo[et.damo[1]][1];
                    _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                    _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                    refresh();
                    et.k = et1.k =0 ;
                    etoption = etsvou = 0 ; 
                    continue ;
                    
                }
                    
                
                
                if ( (et.k) && (!etoption) ) { // Κάποια επιλογή ημερομηνίας μόλις έγινε - να τη βρω και να δείξω στοιχεία

                    auto int locbkxr [3] ;
                    short int oriod = 25 ;
                    locbkxr[0]=olobkxr[0] ; locbkxr[1] = olobkxr[1] ; locbkxr[2] = olobkxr[2] ;  
        
                    etoption=1; etnote=0;
                                        
                    et_werp = 0 ;
                    // Ενημερώνω πινακίδα ημερομηνίας
                    //_bareacls(etdatex+1 , etdatey+1 , etdatex1-1 , etdatey1-1 , etyelxr);
                    dd = find_dayname(qyear , (unsigned short int) et.damo[1] , 1);
                    for (f=1 ; f <= (int)etmo[et.damo[1]]; f++) {
                        if (f == (int) et.damo[0]) break ;
                        dd = (dd==7) ? 1 : dd+1 ;
                    }
                    
                    sprintf (str1kb ,"%hu %s %d , %s" , et.damo[0] , normonth[et.damo[1]] , qyear , mera[dd]);
                    normtext_tomy (str1kb,0);
                    _outmystr_center_col(2, str1kb, etdatex+2 , etdatey+2 , etdatex1-1 , etdatey1-1 , etchxr , etyelxr); 
                    
                    if (qyear > 1999) {
                        // ΣΤΟΙΧΕΙΑ ΦΩΤΟΣ - ΈΝΔΕΙΞΗ ΚΑΤΑΧΩΡΗΣΗΣ ΗΜΕΡΟΛΟΓΙΟΥ
                        
                        auto int etanatcol [3] , etdisicol [3] , etastrchxr[3] ;
                        
                        etastrchxr[0]=etastrchxr[2]=0 ; etastrchxr[1]=255;
                        etanatcol[0] = etanatcol[1] = 255 ; etanatcol[2] = 0 ;
                        etdisicol[0] = etdisicol[1] = etdisicol[2] = 255 ;
                        
                        sunrise_sunset(qyear, (unsigned short int) et.damo[1] , (unsigned short int) et.damo[0]);
                        //srise_h , srise_m , sset_h ,sset_m 
                        
                        etmoon = moonPhases((int) qyear, (int) et.damo[1], (int) et.damo[0]) ;
                        //MoonStr
                        
                        moonrise_moonset(qyear,(unsigned short int) et.damo[1] ,(unsigned short int) et.damo[0],etmo);
                        //moon_ord , moonrise_txt ,moonset_txt
                    
                        
                        
                        sprintf (str1kb,"%02d:%02d", srise_h , srise_m);
                        normtext_tomy (str1kb,0);
                        _outmystr_col(2, str1kb, etfosx , etfosy , etfosx1 , etanatcol, locbkxr); 
                        
                        sprintf (str1kb,"%02d:%02d", sset_h , sset_m);
                        normtext_tomy (str1kb,0);
                        _outmystr_col(2, str1kb, etskotx , etskoty , etskotx1 , etdisicol, locbkxr); 
                        
                        //sprintf (str1024,"%sICD/moon%d.bmp",path_name,etmoon);
                        //readimagefile(str1024,etlunarx,etlunary,0,0);
                        _realputicon(etlunarx,etlunary,mem_lun[etmoon]); refresh();
                        
                        normtext_tomy (MoonStr,str1kb);
                        _outmystr_col(2, str1kb, etselx , etsely , etselx1 , etastrchxr, locbkxr); 
                        
                        if (moon_ord==1) { normtext_tomy (moonrise_txt,str1kb); pioxr = etanatcol ; }
                        else { normtext_tomy (moonset_txt,str1kb); pioxr = etdisicol ; }
                        _outmystr_col(2, str1kb, etselx , etselrisey , etselx1, pioxr, locbkxr);
                        
                        if (moon_ord==1) { normtext_tomy (moonset_txt,str1kb); pioxr = etdisicol ; }
                        else { normtext_tomy (moonrise_txt,str1kb); pioxr = etanatcol ; }
                        _outmystr_col(2, str1kb, etselx , etselsety , etselx1, pioxr, locbkxr);
                                                         
                        if ( (Diary_q) && (etDIaryn[et.damo[1]][et.damo[0]]) ) {
                            et_is_note = 1 ;
                            sprintf (etdiary_filename,"%04d_%02d_%02d", (int) qyear , (int) et.damo[1] , (int) et.damo[0]);
                            sprintf(str1kb,"%s%d/%s.dry",Diary_path,(int) qyear, etdiary_filename);
                            //printf ("%s\n",str1kb) ;
                            if (!access(str1kb, F_OK )) {
                                // Υπάρχει αρχείο-σημείωση όπως στην αρχική κλήση του πίνακα έτους
                                    _realputicon(etstikx,etstiky,mem_stik);
                            }
                            else {
                                // Δεν υπάρχει αρχείο-σημείωση - προφανώς διεγράφη προ ολίγου !
                                    et_is_note = 2 ;
                                    //_realputicon(etstikx,etstiky,mem_stik);
                                    show_help(" Η καταχώρηση ημερολογίου διαγράφτηκε προ ολίγου ", etstikx , etstiky , &hdhlpxt , &hdhlpyt) ;
                                    //et_is_note = 0 ;
                                    //_bareacls(etstikx,etstiky,etstikx+34,etstiky+22,locbkxr);
                            
                            }
                        } else { et_is_note = 0 ; }
                        
                    
                    }
                    
                    // Ενεργοποιώ πινακίδες μετάβαση - ακύρωση
                    
                    _bareacls(etgox+1 , etgoy+1 , etgox1-1, etgoy1-1 , etbkxr);
                    _outmystr_center_col(2, metabst, etgox+2 , etgoy+2 , etgox1-1, etgoy1-1 ,etchxr,etbkxr);
                    _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , etbkxr);
                    _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,etchxr, etbkxr);
                    
                    // Χρωματίζω γκρί την πινακίδα δείξε-σβήσε προσωπικές υπομνήσεις
                    _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , genbkxr);
                    _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,black,genbkxr);
                    refresh();
                    
                    // ELEGXOS .........
                    
                    if (qyear>1999) {
                        a=0; a1=0; b1=0; ks=-1 ; kk=-1; kp=-1 , kep=-1 , kep_1=-1 ;
                        gsee.dm[1] = et.damo[1] ;
                        gsee.dm[0] = et.damo[0] ;
                        
                        for (f=0;f<ar_seo;f++) {
                            if (gsee.tog!=ssee[f].tog) continue ;
                            while (gsee.tog==ssee[f].tog) {
                                // To a Μετράει giortew - στήλες eno to α1 θα θυμάται το μεγαλύτερο μήκος
                                if (a==oriod) { b1=1 ; break; }
                                etseort[a] = (unsigned short int) f ;
                                ks=a;  a++;
                                i=0;
                                while (seort[f][i]!=255) { i++; }
                                if (a1 < i) a1 = i ; 
                                f++;
                                if (f==ar_seo) break ;
                            }
                            if (b1) break ;
                            if (f<647) {f=647; continue;}
                        }
                    
                        
                        
                        // ELEGXOS HMEROMHNIAS KINHTVN EORTVN
                        for (f=0;f<ar_keo;f++) {
                            if (gsee.tog!=etksee[f].tog) continue ;
                            if (a==oriod) { b1=1 ; break; }
                            etseort[a] = f ; 
                            kk=a; a++;
                            i=0;
                            while (keort[f][i]!=255) { i++; }
                            if (a1 < i) a1 = i ; 
                        }
                        
                        // Μητέρας - Πατέρα
                        etmot = etfat = 0 ;
                                
                        if(gsee.tog==etmo_dm) {
                            
                            if (a<oriod) { a++ ; etmot=1 ;}
                        }
                        
                        if(gsee.tog==etfa_dm) { 
                            if (a<oriod) { a++ ; etfat = 1 ; }
                        }
                        
                        
                            // Προσωπικές Επέτειοι
                                
                                
                        for (f=0; f<ar_per_1 ;f++) {
                            if (gsee.tog!=etpers[f] || qyear<etpersyear[f]) continue ;
                            if (a==oriod) { b1=1 ; break; }
                            etseort[a] = f ;
                            kep=a ; a++;
                            i=0;
                            while (ettex[f][i]!=255) { i++; }
                            if (a1 < i) a1 = i ; 
                        }

                        
                        if (etar_clue) {
                            // Έλεγχος recursive για περιπτώσεις freq : 1 - 7 
                            for (f=0 ; f<c_arst ; f++) {
                                mrs = mri_1 + f ;
                                if (mrs->date == gsee.tog) {
                                    if (a==oriod) { b1=1 ; break; }
                                    etseort[a] = f ;
                                    kep_1 = a ; a++ ;
                                    i=0;
                                    while (etrcr[mrs->dom].keim[i]!=255) { i++; }
                                    if (a1 < i) a1 = i ; 
                                }
                            }
                        }
                        
                        
                        if (qyear>2016) {

                        // Έλεγχος για Παγκόσμιες ημέρες
                        
                            for (f=0; f<ar_pagk_1 ;f++) {
                            if (gsee.tog!=etpagk_dm[f]) continue ;
                            if (a==oriod) { b1=1 ; break; }
                            etseort[a] = f ; 
                            kp=a; a++;
                            i=0;
                            while (pagk[f][i]!=255 ) { i++; }
                            if (i>97) i=98 ;
                            if (a1 < i) a1 = i ; 
                            }
                        }

                        if (a) {
                            
                        int redchxr_1 [3] ;
                        int etfont;
                        
                        
                        etfont = bookman_16n;
                        
                        redchxr_1 [0] = 255; 
                        redchxr_1 [1] = 50; 
                        redchxr_1 [2] = 0 ;
                        
                        etnote=1;
                        h = a * myfont_hei[etfont] + 2 + a ; // height
                        if (b1)  { h = h + myfont_hei[etfont] + 1 ; }
                        w = 3 * (a1 * myfont_wid[etfont]) / 5  ; // width
                        if (w>800) w=800;
                        etnx = etkx + 65 ; etny = etky+30 ;
                        
                        if ( (etnx + w) > (etcaxb-2) ) {
                            a1 = (int) (etnx - (short int) w - 67) ;
                            while (a1<info.left+2)
                            {
                                w--;
                                a1 = (int) (etnx - (short int) w - 67) ;
                            } 
                        etnx = (short int) a1;
                        }
                        
                        
                        if ( (etny + h) > (etcayb-2) ) {
                            etny = etny - (short int) h - 32 ;
                            if (etny<info.top+2) etny = info.top+2 ;
                        }
                        etnx1 = etnx+w ; etny1 = etny+h ;
                        getimage (etnx,etny,etnx1,etny1,mem_et800);
                        setcolor (2);
                        rectangle (etnx,etny,etnx1,etny1);
                        _transp_fill (etnx+1,etny+1 , w-1 , h-1, 0 , 20 , 30 , 230);
                        
                        for (f=0 ; f<a ; f++) {
                            
                            if (ks!=-1) {
                                _outmystr_col_transp(etfont, seort[ etseort[f] ] , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, white , 0);
                                if (f!=ks) continue; else {ks=-1; continue ;}
                            }
                            
                            if (kk!=-1) {
                                _outmystr_col_transp(etfont, keort[ etseort[f] ] , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, white , 0);
                                if (f!=kk) continue ; else {kk=-1; continue ;}
                            }
                            
                            if (etmot) {
                                _outmystr_col_transp(etfont, mother , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, white , 0);
                                etmot=0;
                                continue ;
                            }
                            
                            if (etfat) {
                                _outmystr_col_transp(etfont, father , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, white , 0);
                                etfat=0;
                                continue ;
                            }
                            
                            if (kep!=-1) {
                                _outmystr_col_transp(etfont, ettex[ etseort[f] ] , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, redchxr_1 , 0);
                                if (f!=kep) continue ; else {kep=-1; continue ;}
                            }
                            
                            if (kep_1!=-1) {
                                mrs = mri_1 + etseort[f] ;
                                _outmystr_col_transp(etfont, etrcr[mrs->dom].keim , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, redchxr_1 , 0);
                                if (f!=kep_1) continue ; else {kep_1=-1; continue ;}
                            }
                            
                            if (qyear>2016) {
                               if (kp!=-1) {
                                
                                i=0;
                                while (i<99) { petsok[i] = pagk[ etseort[f] ][i] ; i++; }
                                petsok[99] = 255;
                                _outmystr_col_transp(etfont, petsok , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, white , 0);
                                if (f!=kp) continue ; else kp=-1;
                                }
                            }
                            
                        }
                        
                        if (b1) {
                            strcpy (petsok , "...κλπ..");
                            normtext_tomy(petsok,0);
                            _outmystr_col_transp(etfont, petsok , etnx+2, etny+2+f+f*myfont_hei[etfont] , etnx1-2, white , 0);
                        }
                        refresh();
                    }
                    continue ;
                }
                continue ;
                
            }
                    
                    // Υπάρχει αναμμένο κουτί και αναμμένος μήνας από πριν !
                    // Αποκατάσταση στα προηγούμενα
                    /*
                    putimage(etkx, etky ,mem_etk , 0 );
                    normtext_tomy(etmonth[et.damo[1]],str1kb);
                    a1 = etcomo[et.damo[1]][0];
                    b1 = etcomo[et.damo[1]][1];
                    _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                    _outmystr_center_col(3, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                    eprosyear = qyear ;
                    eprosmonth = qmonth = (short int) et.damo[1];
                    eprosday = qday = (short int) et.damo[0];
                    et.k = et1.k = 0 ;
                    refresh();
                    */
                    
                    if (etoption && et.k && etgoto) {
                    
                    // Πέρνα την ημερομηνία στη μηχανή....στο άλλο παράθυρο
                        
                    etgoto=0;
                    et1.k = 0;
                    _bareacls(etgox+1 , etgoy+1 , etgox1-1, etgoy1-1 , etbkxr);
                    _outmystr_center_col(2, metabst, etgox+2 , etgoy+2 , etgox1-1, etgoy1-1 ,etchxr,etbkxr);
                    refresh();
                    if (!etektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                        SDL_SetCursor(cursor);
                        etektos=1;
                        }
                    //SDL_MinimizeWindow(bgi_window);
                    //win2m=1;
                    win2h=1;
                    pran = sdlwin1 ;
                    setcurrentwindow (win_id);
                    memcpy (info_p , info_p3 , size_info);
                    
                    if (win1h || win1m) {
                        
                        if (win1m) SDL_MaximizeWindow(bgi_window);
                        SDL_RestoreWindow(bgi_window);
                        SDL_ShowWindow(bgi_window);
                        win1h = win1m = 0;
                    }
                    SDL_RaiseWindow(bgi_window);
                    refresh();
                    
                    eprosyear = qyear ;
                    eprosmonth = qmonth = (short int) et.damo[1];
                    eprosday = qday = (short int) et.damo[0];
                
                if (eprosmonth==umonth && eprosday==uday && eprosyear==uyear) goto ANNARROF_EVENT  ;

                uday=eprosday;

                greg=1;

                    if (eprosyear%4) b=28;
                    else {
                        if (eprosyear%100) b=29;
                        else {b=(eprosyear%400) ? 28 : 29 ;}
                        }


                if (eprosmonth==2) {
                    if (eprosday>b) {uday=b ;}
                }
                else if (eprosday>mo[eprosmonth]) uday=mo[eprosmonth] ;

                mo[2]=b;

                if (uday!=eprosday) {
                    eprosday=uday;
                    sprintf (str1024,"%02u",uday);
                    sprintf (day_t,"%u",uday);
                    normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                    _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                    _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                    refresh();
                }

                                                                
                if (eprosyear!=uyear) {
                    // ΑΛΛΑΓΗ ΕΤΟΥΣ
                    uyear=eprosyear;
                    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                    sprintf (str1024,"%04u",uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                }

                if (umonth!=eprosmonth) {
                    // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                    _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                    setrgbcolor(dbaspro);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);

                    umonth=eprosmonth;

                    // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                    _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                    setrgbcolor(dbmag);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                }

                startmonth=find_dayname(uyear , umonth , 1);


                if (uday>mo[umonth]) uday=mo[umonth];
                unameday=startmonth;
                for (f=2 ; f<=uday; f++) {
                unameday = (unameday==7) ? 1 : unameday+1 ;}

                specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);

                // Στήλες Σαββατοκύριακου έγχρωμες 
                a=startmonth;
                for (f=1; f<8; f++) {
                    if (a==1) reddy=f;
                    else if (a==7) bluedy=f;
                    a++;
                    if (a==8) a=1;}

                strcpy (mera[0],mera[unameday]);

                // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                normtext_tomy(str1024,0);
                _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                refresh ();

                loctim=time(NULL);
                diar=localtime(&loctim);
                nownameday=diar->tm_wday+1;
                nowday= diar->tm_mday;
                nowmonth = diar->tm_mon+1;
                nowyear = diar->tm_year+1900;

                if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                    if (nowon) goto ANNARROF_EVENT; // Αν το "σήμερα" είναι αναμμένο φύγε.
                    // Αναβω το button "Σήμερα"
                    nowon=1;
                    _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                    if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                    else strcpy(str1024,"TODAY");
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                    refresh() ;
                }
                else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                    if (!nowon) goto ANNARROF_EVENT; // Αν το "σήμερα" είναι σβηστό φύγε !
                    // Το σβήνω....
                    nowon=0;
                    _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                    if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                    else strcpy(str1024,"TODAY");
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                    refresh() ;
                }
                
ANNARROF_EVENT :
                //do {
                  //  SDL_PollEvent(&sdlev);
                    // } while (sdlev.type == SDL_WINDOWEVENT) ;
                    dhide=1;
                    SDL_FlushEvent(SDL_WINDOWEVENT) ;
                continue ;
            }
            
            if (etwinsv) {
                etwinsv=0;
                et1.k = 0;
                _bareacls (etminx+1 , etminy+1 , etminx1-1 , etminy1-1 , etbkxr);
                _outmystr_center_col(2,hidepara,etminx+2,etminy+2,etminx1-1,etminy1-1,etchxr,etbkxr);
                refresh();
                if (!etektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                    SDL_SetCursor(cursor);
                    etektos=1;
                    }
                //SDL_MinimizeWindow(bgi_window);
                //win2m=1;
                win2h=1;
                pran = sdlwin1 ;
                setcurrentwindow (win_id);
                memcpy (info_p , info_p3 , size_info);
                
                if (win1h || win1m) {
                    win1h = win1m = 0;
                    SDL_ShowWindow(bgi_window);
                }
                SDL_RaiseWindow(bgi_window);
                dhide=1;
                refresh();
                //SDL_FlushEvent(SDL_MOUSEMOTION) ;
                //SDL_FlushEvent(SDL_MOUSEBUTTONDOWN) ;
                //SDL_FlushEvent(SDL_WINDOWEVENT) ;
                continue ;
        }
            
            if (etphoto) {
                void *bigmem ;
                etphoto = 0 ;
                _bareacls(etfotx+1 , etfoty+1 , etfotx1-1 , etfoty1-1 , etbkxr);
                _outmystr_center_col(2, sosefoto,etfotx+2 , etfoty+2 , etfotx1-1 , etfoty1-1 ,etchxr,etbkxr);
                refresh();
                bigmem = malloc (imagesize(0,0,info.right,info.bottom));
                if (!bigmem) {information (0,"Ανεπαρκής Μνήμη!",0); continue ;}
                getimage(0,0,info.right,info.bottom,bigmem);
                
                
                sprintf (file_2,"%s%s",user_path,picts_str);

                if (keyb_gr) strcpy (file_1,"Σώστε ή Σώστε ως..");
                else strcpy (file_1,"Save or Save as..");
                
                switch (fsel_code) {
                    
                    case 0 :
                        
                        sprintf(str1kb,"%s%s_Year_%d.bmp", user_path,picts_str,(int) qyear);
                        
                        break ;
                    
                    case 1 : //yad
                        sprintf (big_char,"%s --file-selection --save --confirm-overwrite --title=\"%s\" --filename=%s --file-filter=*.bmp --center --width=%d --height=%d",efarm_path,file_1,file_2,(int) (2*DM.w/3) , (int) (2*DM.h/3) ) ;
                        break ;
                        
                    case 2 : //kdialog
                        sprintf (big_char,"%s --getsavefilename %s",efarm_path,file_2);
                        break;
                        
                    case 3 : //zenity
                        sprintf(big_char,"%s --file-selection --save --confirm-overwrite --title=\"%s\" --filename=%s --file-filter=*.bmp",efarm_path,file_1,file_2);

                }
                
                if (fsel_code) {
                
                    f = fileselector( big_char, str1kb , 1024);
                    if (!f) { free(bigmem) ; continue ;}
                    
                    a1=strlen(str1kb); 
                    if (!a1) {free(bigmem) ; continue ;}
                    
                    for (f=1;f<a1;f++) {
                    if (str1kb[f]!='.') continue ;
                    else {for (i=f ; i<a1 ; i++) str1kb[i]='\0';}
                    break;}
                    
                    strcat(str1kb,".bmp");
                }
                
                writeimagefile (str1kb, info.left,info.top,info.right,etcayb+7);
                putimage(0,0,bigmem,0);
                refresh();
                free(bigmem) ;
                information (0,"Η εικόνα σώθηκε στο αρχείο :",str1kb);
                continue ;
                
            }
            
            if (etallag && (!etoption) && qyear>1999 && ( (ar_per_1) || (etar_clue) || (Diary_q) ) ) {
                auto short int et_what ;
                etallag = 0;
                _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                refresh() ;
                
                // Να φανούν οι ημέρες επετείων
                if (ar_per_1 || etar_clue) {
                    if (!etshowhide) {
                        
                        
                        for (f=1 ; f<13 ; f++) {
                            for (i=1 ; i<=etmo[f] ; i++){
                                if (only_1[f][i]) {
                                
                                a1 = f / 3 ;
                                b1 = f % 3 ;
                                
                                a1 = (b1) ? a1 : a1-1 ;
                                etky = etcayt + (a1 * 150) + (a1*40) + 25 ;
                                
                                a1 = f % 3 ;
                                a1 = (a1) ? a1-1 : 2 ;
                                etkx = etcaxt + (a1*420) + (a1*40) ;
                                
                                a1 = i / 7 ;
                                b1 = i % 7 ;

                                b1 = (b1) ? a1 : a1-1 ;
                                etky = etky + (b1*25) ;
                                
                                b1 = i % 7 ;
                                
                                b1 = (!b1) ? 6 : b1-1 ;
                                etkx = etkx + (b1*60) ;
                                
                                _bareacls (etkx+51,etky+16,etkx+58,etky+23,epbkxr); 

                                }
                            }
                        }
                            
                    }
                    else {  // Να κρυφτούν οι επισημάνσεις επετείων
                        for (f=1 ; f<13 ; f++) {
                            for (i=1 ; i<=etmo[f] ; i++){
                                if (only_1[f][i]) {
                                
                                gsee.dm[0] = (char) i ; gsee.dm[1] = (char) f ;
                                et_what = gsee.tog;
                                
                                a1 = f / 3 ;
                                b1 = f % 3 ;
                                
                                a1 = (b1) ? a1 : a1-1 ;
                                etky = etcayt + (a1 * 150) + (a1*40) + 25 ;
                                
                                a1 = f % 3 ;
                                a1 = (a1) ? a1-1 : 2 ;
                                etkx = etcaxt + (a1*420) + (a1*40) ;
                                
                                a1 = i / 7 ;
                                b1 = i % 7 ;

                                b1 = (b1) ? a1 : a1-1 ;
                                etky = etky + (b1*25) ;
                                
                                b1 = i % 7 ;
                                
                                b1 = (!b1) ? 6 : b1-1 ;
                                etkx = etkx + (b1*60) ;
                                
                                if (et_enter!=et_what) _bareacls (etkx+51,etky+16,etkx+58,etky+23,genbkxr);
                                else _areacls (etkx+51,etky+16,etkx+58,etky+23,et_udrgb[0],et_udrgb[1],et_udrgb[2]) ;
                                }
                            }
                        }
                    }
                }
                
                
                if (Diary_q) {
                    if (!etshowhide) {
                        
                        
                        for (f=1 ; f<13 ; f++) {
                            for (i=1 ; i<=etmo[f] ; i++){
                                if (etDIaryn[f][i]) {
                                
                                a1 = f / 3 ;
                                b1 = f % 3 ;
                                
                                a1 = (b1) ? a1 : a1-1 ;
                                etky = etcayt + (a1 * 150) + (a1*40) + 25 ;
                                
                                a1 = f % 3 ;
                                a1 = (a1) ? a1-1 : 2 ;
                                etkx = etcaxt + (a1*420) + (a1*40) ;
                                
                                a1 = i / 7 ;
                                b1 = i % 7 ;

                                b1 = (b1) ? a1 : a1-1 ;
                                etky = etky + (b1*25) ;
                                
                                b1 = i % 7 ;
                                
                                b1 = (!b1) ? 6 : b1-1 ;
                                etkx = etkx + (b1*60) ;
                                
                                _areacls (etkx+51,etky+3,etkx+58,etky+10,162,57,0); 

                                }
                            }
                        }
                            
                    }
                    else {  // Να κρυφτούν οι επισημάνσεις επετείων
                        for (f=1 ; f<13 ; f++) {
                            for (i=1 ; i<=etmo[f] ; i++){
                                if (etDIaryn[f][i]) {
                                
                                gsee.dm[0] = (char) i ; gsee.dm[1] = (char) f ;
                                et_what = gsee.tog;
                                
                                a1 = f / 3 ;
                                b1 = f % 3 ;
                                
                                a1 = (b1) ? a1 : a1-1 ;
                                etky = etcayt + (a1 * 150) + (a1*40) + 25 ;
                                
                                a1 = f % 3 ;
                                a1 = (a1) ? a1-1 : 2 ;
                                etkx = etcaxt + (a1*420) + (a1*40) ;
                                
                                a1 = i / 7 ;
                                b1 = i % 7 ;

                                b1 = (b1) ? a1 : a1-1 ;
                                etky = etky + (b1*25) ;
                                
                                b1 = i % 7 ;
                                
                                b1 = (!b1) ? 6 : b1-1 ;
                                etkx = etkx + (b1*60) ;
                                
                                if (et_enter!=et_what) _bareacls (etkx+51,etky+3,etkx+58,etky+10,genbkxr);
                                else _areacls (etkx+51,etky+3,etkx+58,etky+10,et_udrgb[0],et_udrgb[1],et_udrgb[2]) ;
                                }
                            }
                        }
                    }
                }
                
                refresh();
                
                
                etshowhide = 1 - etshowhide ;
                continue ;
            }
            
            continue ;
        }
        
                if (sdlev.button.windowID == sdlwin2) continue ;
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                if (ektos) continue ;
                mx1 = sdlev.button.x ; my1= sdlev.button.y ;
                SDL_FlushEvent(SDL_MOUSEBUTTONDOWN) ;
                SDL_FlushEvent(SDL_MOUSEMOTION) ;
                dhide = 0 ;
                if (diak1b) {   // Επισημάνσεις Υπομνήσεων
                    
                    if (DIAK1) { // Κλείνουν

                        
                    if (ar_per || ar_clue) {
                // Τοποθέτηση κουκίδων στο πάνελ σε ημερομηνίες όπου υπάρχει ΠΑΓΙΑ/ετήσια ή ΕΠΑΝΑΛΑΜΒΑΝΟΜΕΝΗ προσωπική υπόμνηση
                        for (md=1 ; md<=mo[umonth] ; md++){
                            
                            if (! only[umonth][md]) { continue ; } 
                            
                            v1 = md / 7 ;
                            v2 = md % 7 ;

                            v = (v2) ? v1 : v1-1 ;
                            dy = cayt + (v*25) + 25 ;
                            
                            v = (!v2) ? 6 : v2-1 ;
                            dx = caxt + (v*60) ;
                            
                            // Καθάρισμα κουκίδων 
                            if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                            else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                            for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+14 ; f<=dy+21; f++) _putpixel (i,f);}
                            
                        }
                        refresh();
                    }
            
                        DIAK1=0;
                        Rputicon (diak1x,diak1y,mem_diakoff,ejobkxr) ; 
                    }
                    else {  // Ανοίγουν
                        
                    if (ar_per || ar_clue) {
                // Τοποθέτηση κουκίδων στο πάνελ σε ημερομηνίες όπου υπάρχει ΠΑΓΙΑ/ετήσια ή ΕΠΑΝΑΛΑΜΒΑΝΟΜΕΝΗ προσωπική υπόμνηση
                        for (md=1 ; md<=mo[umonth] ; md++){
    	
                            v1 = md / 7 ;
                            v2 = md % 7 ;

                            v = (v2) ? v1 : v1-1 ;
                            dy = cayt + (v*25) + 25 ;
                            
                            v = (!v2) ? 6 : v2-1 ;
                            dx = caxt + (v*60) ;
                            
                            if (only[umonth][md]) { setcolor (COLOR(0,255,255)); } 
                            else  if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                            else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                            for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+14 ; f<=dy+21; f++) _putpixel (i,f);}
                            
                        }
                        refresh();
                    }

                        DIAK1=1;
                        Rputicon (diak1x,diak1y,mem_diak1on,ejobkxr) ;
                    }
                    
                    diak1b = 0 ;
                    continue ;
                }
                
                if (diak2b) {  // Επισημάνσεις Ημερολογίου
                    
                    if (DIAK2) {      // Κλείνουν
                        
                        if (Diary_u) {
                            for (md=1 ; md<=mo[umonth] ; md++){
                                if (!DIaryn[umonth][md]) { continue ; }
                                    v1 = md / 7 ;
                                    v2 = md % 7 ;

                                    v = (v2) ? v1 : v1-1 ;
                                    dy = cayt + (v*25) + 25 ;
                                    
                                    v = (!v2) ? 6 : v2-1 ;
                                    dx = caxt + (v*60) ;
                                    
                            // Καθάρισμα κουκίδων 
                            
                            if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                            else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                            for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+3 ; f<=dy+10; f++) _putpixel (i,f);}
                            }
                            refresh();
                        }
                        
                        DIAK2 = 0 ;
                        Rputicon (diak2x,diak2y,mem_diakoff,ejobkxr) ; 
                    }
                    else {            // Ανοίγουν
                    
                        if (Diary_u) {
                            for (md=1 ; md<=mo[umonth] ; md++){
                                
                                    v1 = md / 7 ;
                                    v2 = md % 7 ;

                                    v = (v2) ? v1 : v1-1 ;
                                    dy = cayt + (v*25) + 25 ;
                                    
                                    v = (!v2) ? 6 : v2-1 ;
                                    dx = caxt + (v*60) ;
                                    
                            // Tοποθέτηση κουκίδων στο πάνελ σε ημερομηνίες όπου υπάρχει καταχώρηση ημερολογίου
                            if (DIaryn[umonth][md]) { setcolor (COLOR(162,57,0)); } 
                            else  if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                            else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                            for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+3 ; f<=dy+10; f++) _putpixel (i,f);}
                            }
                            refresh();
                        }
                        
                        DIAK2 = 1 ;
                        Rputicon (diak2x,diak2y,mem_diak2on,ejobkxr) ;
                    }
                
                    diak2b=0;
                    continue ;
                }
                
                if (diarnote) { // στο εικονίδιο καταχώρηση ημερολογίου

                    auto void *mem_scr_note = NULL ;
                    auto int ntx , nty , nth , ntx1, nty1;
                    short int area[4] ;
                    auto int etanatcol [3] ;
                        
                    etanatcol[0] = etanatcol[1] = 250 ; etanatcol[2] = 0 ;
                    sprintf(str1kb,"%s%d/%s.dry",Diary_path,(int) uyear, diary_filename);   

                    fp=fopen(str1kb,"rb");
                    if (fp!=NULL) {
                        i=0;
                        fread (&what,1,1,fp);
                        do {
                            if (what<164 || what==200) {diary_notes[i++]=what ;}
                            fread(&what,1,1,fp);
                        }while (what!=255 && i<60000);
                        diary_notes[i]=255;
                        fclose(fp);
                    }
                    else {
                        diary_notes[0] = 255 ;
                    }

                    if (diary_notes[0] == 255) {
                        there_is_note = 0 ;
                        pre_diary_filename[0]=255;
                        bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                        diarnote=0;
                        ektos=1;
                        continue ;
                    }
                        

                    ntx = stikx + 47 ; nty = stiky -3 ;
                    if (i<=500) nth=200;
                    else if (i<1000) nth=250;
                    else if (i<2500) nth=300 ;
                    else if (i<5000) nth=400;
                    else nth=494;
                    nty1 = nty + nth ; ntx1 = ntx + 710;
                    area[0] = stikx-10 ; area[2] = ntx1+10 ; area[1] = nty-8 ; area[3] = nty1+10 ;
                    mem_scr_note = malloc (imagesize (ntx, nty, ntx1 , nty1)) ;
                    if (mem_scr_note != NULL) {
                        
                        getimage (ntx, nty , ntx1 , nty1 , mem_scr_note);
                        bareacls (ntx , nty , ntx1 , nty1 , genbkxr) ;
                        setcolor (1);
                        
                        rectangle (ntx , nty , ntx1 , nty1);
                        rectangle (ntx+1 , nty+1 , ntx1-1 , nty1-1);
                        sprintf (str1kb,"Καταχώρηση Ημερολογίου της %02d/%02d/%04d", (int) uday, umonth , uyear);
                        normtext_tomy (str1kb,0);
                        bareacls(ntx+3 , nty+2 , ntx1-3, nty+21,black);
                        _outmystr_center_col(neohell_18n, str1kb, ntx+7 , nty+2 , ntx1-3, nty+22, etanatcol,black);
                        bareacls (ntx+6 , nty+22 , ntx1-6 , nty1-6 , white) ;
                        trampa=gouv;
                        gouv=myfont[notosans_16n];
                        readnote_werp = field_txt_scroll (diary_notes , readnote_werp , ntx+6 , nty+22 , ntx1-20 , nty1-6 , 60000 , black, white, area) ; 
                        putimage (ntx,nty,mem_scr_note,0) ; refresh();
                        gouv=trampa;
                        free (mem_scr_note) ;

                    } else { printf ("Out of memory..!!\n"); }

                    diarnote=0;
                    Rputicon(stikx,stiky,mem_stik,ejobkxr);
                    ektos=1;
                    continue ;
                    
                }
                
                if (inpbox) {
                if (mx1>inpx && mx1<inpx1 && my1>inpy && my1<inpy1) {  // Στις σημειώσεις...
                                        
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    sbou=0;
                    movext=xt+360;
                    inpx-=3 ; inpx1+=3; inpy1+=3;
                    
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                            
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                    trampa=gouv;
                  
                    bareacls(inpx1+4,inpy,inpx1+15,inpy1,ejobkxr);
                    
                    //inp_cur=0;
                    bkxr[0]=notesbkxr[0]; bkxr[1]=notesbkxr[1]; bkxr[2]=notesbkxr[2]; 
                    chxr[0]=noteschxr[0]; chxr[1]=noteschxr[1]; chxr[2]=noteschxr[2];
                    //slxr[0]=66;slxr[1]=33;slxr[2]=66;
                    slxr[0]=112;slxr[1]=0;slxr[2]=0;
                    
                    strcpy (submenu[0],"Κλήση ΔΙΑΔΙΚΤΥΑΚΟΥ συνδέσμου με Firefox");
                    strcpy (submenu[1],"Κλήση ΔΙΑΔΙΚΤΥΑΚΟΥ συνδέσμου με Google-Chrome");
                    gouv=myfont[notes_font];

                    ix=inpx-1; ; iy=yt ;  ix1=inpx1 ; iy1=inpy1 ; 
                    
                    metr=input(notes_str, &ix, &iy, &ix1, &iy1, 60000, -1, inp_cur);
                    while (metr<0) metr=input(notes_str, &ix, &iy, &ix1, &iy1, 60000 , -1,0);
                    inp_cur = (unsigned short int) metr;                                   
                    
                    for (f=0;f<3;f++) {
                        bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
                    }
                    gouv=trampa;    
                    ektos=1;
                    gouv=myfont[notes_font];
                    _txt_show (notes_str , inp_cur, inpx, inpy ,inpx1 , inpy1 , 60000 , olochxr, notesbkxr, ejobkxr);
                    refresh();
                    strcpy (submenu[0],"ΑΝΤΙΓΡΑΦΗ στοιχείων ημέρας στον Clipboard");
                    strcpy (submenu[1],"Αναζήτηση ονόματος (ελεύθερη)");

                    continue ;
                }
                }
                
                if (probox!=-1) {
LIKE_PROBOX:
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    if (specmonth) {c=(uday<5) ? 0 : 4 ;}
                    else c=0;
                    if (probox!=uday+c) {
                        a=((uday+c)/7)+1 ; b=(uday+c)%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        _bareacls (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24,genbkxr);
                        if (b==bluedy) _outmystr_center_col (neohell_20n,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,bluechxr,genbkxr);
                        else if (b==reddy) _outmystr_center_col (neohell_20n,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,redchxr,genbkxr);
                        else _outmystr_center_col (neohell_20n,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,genchxr,genbkxr);
                        
                        if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                        else c=0;
                        uday=probox-c;
                        //specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        a=(probox/7)+1 ; b=probox%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        _bareacls (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24,bkxrepi);
                        if (b==bluedy) _outmystr_center_col (neohell_20n,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,bluechxr,bkxrepi);
                        else if (b==reddy) _outmystr_center_col (neohell_20n,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,redchxr,bkxrepi);
                        else _outmystr_center_col (neohell_20n,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,genchxr,bkxrepi);
                       
                        setrgbcolor(dbblack);
                        rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                        rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                        
                        // Τι μέρα έχουμε στις τάδε του μήνα ;
                        unameday=startmonth;
                        for (f=2; f<=uday ; f++) {
                            unameday++;
                            if (unameday==8) unameday=1;
                        }
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                        
                        if (!d) {
                        // Ξαναχρωμάτισε το panel
                        setrgbcolor(dbmag);
                        rectangle (caxt,cayt,caxb,cayb);}
                        else { probox=-1; d=0;}
                        refresh();
                        
                    }
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    continue ;
                }
                                
                if(riday){
                    
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    size=500000000;
                    
                    do{
                    if (uyear==2500) {
                        if (umonth==12 && uday==31) break ;
                    }


                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    if (uday==mo[umonth]) { 
                        uday=1; 
                        unameday++;
                        if (unameday==8) unameday=1;
                        startmonth=unameday;
                        
                        // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                        _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                        _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                        line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        
                        umonth++;
                        if (umonth==13) { 
                            umonth=1; 
                            uyear++;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                            
                            story.olo=0;
                            story.meros[0]= uday;
                            story.meros[1]= umonth;
                            story.mewo[1]=uyear;
                                                        
                            uolo=story.olo ;
                            
                            greg = (uolo>=arx_grh) ? 1 : 0 ; 
                            
                            if (greg) {
    
                                if (uyear%4) mo[2]=28;
                                else {
                                    if (uyear%100) mo[2]=29;
                                    else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                    }
                            }

                            else { mo[2] = (uyear%4) ? 28 : 29 ; }
                        }
                        
                        // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                        _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                        _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                        setrgbcolor(dbmag);
                        rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                        line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                        line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        
                    }
                    else { 
                        uday++; 
                        unameday++;
                        if (unameday==8) unameday=1;
                        story.olo=0;
                        story.meros[0]= uday;
                        story.meros[1]= umonth;
                        story.mewo[1]=uyear;
                        
                        //printf("uday = %u , umonth = %u , uyear/mewo = %u/%u \n", uday, umonth, uyear,story.mewo);
                        uolo=story.olo ;
                        if (uolo==first_xam) {
                            greg=1;
                            uday=15;
                        }
                    }
                        
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                        refresh ();
                        
                        f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                        
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= ridayxt) && (sdlev.motion.x <= ridayxt+18) && (sdlev.motion.y >= ridayyt) && (sdlev.motion.y <= ridayyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}

                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                        } while ( (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                        continue ;
                    }
                    
                    if (pronow) {
SHMERIS :
                        pronow=0; nowon=1;d=0;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh(); 
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        unameday=diar->tm_wday+1;
                        uday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        strcpy (mera[0],mera[unameday]);
                        greg=1;
                        
                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            
                            umonth=nowmonth;
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        if (nowyear != uyear) {
                        // ΕΤΟΣ - ΣΗΜΕΡΑ
                        
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",nowyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                            if (nowyear%4) mo[2]=28;
                            else {
                                if (nowyear%100) mo[2]=29;
                                else {mo[2]=(nowyear%400) ? 28 : 29 ;}
                            }
                            uyear = nowyear ;
                        }
                        
                        startmonth=unameday+1;
                        if (startmonth==8) startmonth=1;
                        for (f=uday ; f>0 ; f--){
                            startmonth--;
                            if (!startmonth) startmonth=7;
                        }
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                        
                       
                        // ΑΝΑΨΕ ΤΟ ΚΟΥΜΠΙ ΣΗΜΕΡΑ
                        
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        
                        // ΠΑΝΕΛ
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;
                        }
                        
                        refresh();
                        continue ;
                    }
                    
                if(leday){
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    size=500000000;
                    do {
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                                        
                    if (uday==1) {
                        if (umonth==1){
                            if (uyear==1) break;
                            else {
                                uyear--;
                                // ΑΛΛΑΓΗ ΕΤΟΥΣ
                                _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                                sprintf (str1024,"%04u",uyear);
                                normtext_tomy(str1024,0);
                                _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                                
                                uday=31; umonth=12;
                                
                                startmonth=unameday;
                                for (f=31 ; f>0 ; f--) {
                                startmonth--;
                                if (!startmonth) startmonth=7;
                                }
                                
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                
                                uolo=story.olo ;
                                
                                greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                
                                if (greg) {

                                    if (uyear%4) mo[2]=28;
                                    else {
                                        if (uyear%100) mo[2]=29;
                                        else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                        }
                                }

                                else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[1]+1,mhnxb-1,mhnyb[1]-1,olobkxr);
                            _outmystr_center_col(neohell_22n,month[1],mhnxt,mhnyt[1]+1, mhnxb, mhnyb[1],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[1],mhnxb,mhnyb[1]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[1]+1,mhnxt-1,mhnyb[1]+1);
                            line(mhnxt-1,mhnyb[1]+1,mhnxb,mhnyb[1]+1);
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗNA
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            }
                        }
                        else {
                            
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            umonth--;
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            
                            uday=mo[umonth];
                            startmonth=unameday;
                            for (f=uday ; f>0 ; f--) {
                                startmonth--;
                                if (!startmonth) startmonth=7;
                            }
                        }
                    }
                    else { uday--; }
                    
                    unameday--;
                    if (!unameday) unameday=7;
                        
                    story.olo=0;
                    story.meros[0]= uday;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                        
                    if (uolo==last_xam) uday=4;
                                
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                    refresh ();
                    
                    f=0; while (f<size) f++;
                   if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= ledayxt) && (sdlev.motion.x <= ledayxt+18) && (sdlev.motion.y >= ledayyt) && (sdlev.motion.y <= ledayyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    } while ( (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                    continue ;
                }
                    
                if (promonbox!=-1) {
                    if (umonth==promonbox) continue ;
                    //nowday=uday; nowmonth=umonth; nownameday=unameday;

                    // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                    _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                    setrgbcolor(dbaspro);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                    
                    umonth = promonbox;
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                    
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                    _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                    setrgbcolor(dbmag);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    
                }
                
                
                if (leyear) {
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    if (uyear==1) continue ;
                    size=500000000;
                    do{
                    uyear--;

                    // ΑΛΛΑΓΗ ΕΤΟΥΣ
                    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                    sprintf (str1024,"%04u",uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);

                    a = (uday>28) ? 28 : uday ;
                    story.olo=0;
                    story.meros[0]= a;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                    
                    greg = (uolo>=arx_grh) ? 1 : 0 ; 
                    
                    if (greg) {

                        if (uyear%4) mo[2]=28;
                        else {
                            if (uyear%100) mo[2]=29;
                            else {mo[2]=(uyear%400) ? 28 : 29 ;}
                            }
                    }

                    else { mo[2] = (uyear%4) ? 28 : 29 ; }
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= leyearxt) && (sdlev.motion.x <= leyearxt+18) && (sdlev.motion.y >= leyearyt) && (sdlev.motion.y <= leyearyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    } while ( (uyear!=1) && (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                    continue ;
                }
                
                
                if (riyear) {
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    if (uyear==2500) continue ;
                    size=500000000;
                    do {
                    uyear++;

                    // ΑΛΛΑΓΗ ΕΤΟΥΣ
                    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                    sprintf (str1024,"%04u",uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);

                    a = (uday>28) ? 28 : uday ;
                    story.olo=0;
                    story.meros[0]= a;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                    
                    greg = (uolo>=arx_grh) ? 1 : 0 ; 
                    
                    if (greg) {

                        if (uyear%4) mo[2]=28;
                        else {
                            if (uyear%100) mo[2]=29;
                            else {mo[2]=(uyear%400) ? 28 : 29 ;}
                            }
                    }

                    else { mo[2] = (uyear%4) ? 28 : 29 ; }
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= riyearxt) && (sdlev.motion.x <= riyearxt+18) && (sdlev.motion.y >= riyearyt) && (sdlev.motion.y <= riyearyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    
                    } while ( (uyear!=2500) && (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                    continue;
                }
                
                if (inpyear) {
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[6];
                    bareacls(inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb-1,olobkxr);
                    i=num_input(year_t,inpyearxt+20,inpyearyt+1,inpyearxb-1,inpyearyb-1,4,0);
                    ektos=1;
                    if (year_t[0]==255) {prosyear=0 ; continue ;}
                    prosyear=(unsigned short int) convert_str (4,year_t);
                    if (!prosyear) prosyear=1;
                    else if (prosyear>2500) prosyear=2500; 
                    
                    sprintf (str1024,"%04u",prosyear);
                    sprintf (year_t,"%u",prosyear);
                    normtext_tomy(str1024,0); normtext_tomy(year_t,0);
                    _bareacls(inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb-1,olobkxr);
                    _outmystr_center_col(6, str1024,  inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb,olochxr,olobkxr);
                    refresh();
                    

                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpyearxt,inpyearyt,inpyearxb,inpyearyb);
                        setrgbcolor (dbmag);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        inpmonth=1; inpyear=0;
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        refresh();
                        i=num_input(month_t,inpmonthxt+10,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,2,0);
                        ektos=1;
                        prosmonth=(unsigned short int) convert_str (2,month_t);
                        if (!prosmonth) prosmonth=1;
                        else if (prosmonth>12) prosmonth=12; 
                        
                        sprintf (str1024,"%02u",prosmonth);
                        sprintf (month_t,"%u",prosmonth);
                        normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                        refresh();
                        
                    }
                    else continue ;
                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        setrgbcolor (dbmag);
                        rectangle (inpdayxt,inpdayyt,inpdayxb,inpdayyb);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        refresh();
                        inpmonth=0; inpday=1;
                        if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                        i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                        ektos=1;
                        prosday=(unsigned short int) convert_str (2,day_t);
                        if (!prosday) prosday=1; 
                        else if (prosday>b) prosday=b; 
                        sprintf (day_t,"%u",prosday);
                        sprintf (str1024,"%02u",prosday);
                        normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, 
                                             olochxr,olobkxr);
                        refresh();
                        
                    }
                    
                    continue;
                }
                
                
                if (inpmonth) {
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[6];
                    bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                    i=num_input(month_t,inpmonthxt+10,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,2,0);
                    ektos=1;
                    if (month_t[0]==255) {prosmonth=0; continue ;}
                    prosmonth=(unsigned short int) convert_str (2,month_t);
                    if (!prosmonth) prosmonth=1;
                    else if (prosmonth>12) prosmonth=12; 
                    sprintf (month_t,"%u",prosmonth);    
                    sprintf (str1024,"%02u",prosmonth);
                    normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                    _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                    _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                    refresh();
                
                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        setrgbcolor (dbmag);
                        rectangle (inpdayxt,inpdayyt,inpdayxb,inpdayyb);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        refresh();
                        inpmonth=0; inpday=1;
                        if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                        
                        i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                        ektos = 1 ;
                        prosday=(unsigned short int) convert_str (2,day_t);
                        if (!prosday) prosday=1; 
                        else if (prosday>b) prosday=b; 
                        sprintf (day_t,"%u",prosday);
                        sprintf (str1024,"%02u",prosday);
                        normtext_tomy(str1024,0);
                        normtext_tomy(day_t,0);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                        refresh();
                    }
                    
                    continue;
                }
                
                
                if (inpday) {
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[6];
                    
                    bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                    i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                    ektos=1;
                    if (day_t[0]==255) { prosday=0 ; continue ;}
                    
                    prosday=(unsigned short int) convert_str (2,day_t);
                    
                    if (!prosmonth) {
                        prosmonth=1;
                        sprintf (str1024,"%02u",prosmonth);
                        sprintf (month_t,"%u",prosmonth);
                        normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                    }
                    if (prosmonth==2) b=29; else b=mo[prosmonth] ;

                    if (!prosday) prosday=1; 
                    else if (prosday>b) prosday=b; 
                        
                    sprintf (str1024,"%02u",prosday);
                    sprintf (day_t,"%u",prosday);
                    normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                    _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                    _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                    refresh();
                    continue ;
                }
                    
                    if (putok) {
                        
                        if (year_t[0]==255) continue;
                        if (prosyear==uyear && prosmonth==umonth && prosday==uday) continue ;
                        if (month_t[0]==255) {
                            prosmonth=1;
                            sprintf (str1024,"%02u",prosmonth);
                            sprintf (month_t,"%u",prosmonth);
                            normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                            _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                            refresh();
                        }
                        
                        if (day_t[0]==255) {
                            prosday=1;
                            sprintf (str1024,"%02u",prosday); sprintf (day_t,"%u",prosday);
                            normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                            _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                        a = (prosday>28) ? 28 : prosday ;
                        story.olo=0;
                        story.meros[0]= a;
                        story.meros[1]= prosmonth;
                        story.mewo[1]=prosyear;
                        uolo=story.olo ;

                        greg = (uolo>=arx_grh) ? 1 : 0 ;
                        
                        uday=greday=prosday;
                        
                        if (greg) {

                            if (prosyear%4) b=28;
                            else {
                                if (prosyear%100) b=29;
                                else {b=(prosyear%400) ? 28 : 29 ;}
                                }
                        }

                        else { b = (prosyear%4) ? 28 : 29 ; }
                        
                        
                        if (prosmonth==2) {
                            if (prosday>b) {uday=b ;}
                        }
                        else if (prosday>mo[prosmonth]) uday=mo[prosmonth] ;
                        
                        story.olo=0;
                        story.meros[0]=greday;
                        story.meros[1]=prosmonth;
                        story.mewo[1]=prosyear;
                         if (story.olo<first_xam || story.olo>gre_xam_t) {greday=40;}
                        
                        mo[2]=b;
                        
                        if (uday!=prosday) {
                            prosday=uday;
                            sprintf (str1024,"%02u",uday);
                            sprintf (day_t,"%u",uday);
                            normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                            _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                                                                        
                        if (prosyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            uyear=prosyear;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                        }

                        if (umonth!=prosmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);

                            umonth=prosmonth;

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        startmonth=find_dayname(uyear , umonth , 1);
                        
                        if (startmonth!=20) {
                            if (uday>mo[umonth]) uday=mo[umonth];
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        else {
                            startmonth=2;
                            if (uday>mo[umonth]) uday=mo[umonth];
                            else if (uday>4 && uday<15) {
                                uday=15;
                            }
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            if (f>4 && f<15) continue;
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        
                        
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                        continue ;
                        
                    }
                    
                    if (adddays) {
                        
                        for (f=0 ; f<3 ; f++) {
                            chxr[f] = olochxr[f];
                            bkxr[f] = olobkxr[f];
                            slxr[f] = bkxrepi[f];
                        }
                        
                        gouv=myfont[6];
                        bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                        num_input(addday_t,adddaysxt+10,adddaysyt+1,adddaysxb-1,adddaysyb-1,7,2);
                        ektos=1;
                        if (addday_t[0]==255) {prosadd=0 ; continue;}
                        prosadd=(int) convert_str (7,addday_t);
                        if (prosadd<0) {
                            if (prosadd<-913107) prosadd=-913107;
                            sprintf (str1024,"%07d",prosadd);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                        } 
                        else { 
                            if (prosadd>913107) prosadd=913107;
                            sprintf (str1024,"%06d",prosadd);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                        }
                        
                        normtext_tomy(str1024,0);
                        _bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb, olochxr,olobkxr);
                        refresh();
                        continue ;
                    }
                    
                    if (addok) {
                        
                        if (!prosadd) continue ;
                            
                        story.olo=0;
                        story.meros[0]= uday;
                        story.meros[1]= umonth;
                        story.mewo[1]=uyear;
                        uolo=story.olo ;
                        
                        nowmonth = umonth;
                        nowyear = uyear;
                        
                        if (prosadd>0) { // ΠΡΟΣΘΕΣΗ
                            if (uolo == tel_diary) continue ;
                            i=prosadd;
                            while(i) {
                                unameday = (unameday==7) ? 1 : unameday+1;
                                uday = (uday == mo[umonth]) ? 1 : uday+1;
                                if (uday==1) {
                                    umonth=(umonth==12) ? 1 : umonth+1;
                                    if (umonth==1) {
                                        uyear++;
                                        
                                        story.olo=0;
                                        story.meros[0]= uday;
                                        story.meros[1]= umonth;
                                        story.mewo[1]=uyear;
                                        uolo=story.olo ;
                                        
                                        greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                        
                                        if (greg) {

                                            if (uyear%4) mo[2]=28;
                                            else {
                                                if (uyear%100) mo[2]=29;
                                                else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                                }
                                        }

                                        else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                        i--;
                                        continue;
                                    }
                                }
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                uolo=story.olo ;
                                
                                if (uolo==first_xam) uday=15;
                                else if (uolo==tel_diary) {i--;break;}
                                i--;
                            }
                        }
                        else { // ΑΦΑΙΡΕΣΗ
                            if (uolo == arx_diary) continue ;
                            i=abs(prosadd);
                            while (i) {
                                unameday = (unameday==1) ? 7 : unameday-1 ;
                                if (uday==1){
                                    if (umonth==1) {
                                        if (uyear==1) {unameday = (unameday==7) ? 1 : unameday+1; break;}
                                        else {
                                            uyear--; uday=31; umonth=12;
                                            story.olo=0;
                                            story.meros[0]= uday;
                                            story.meros[1]= umonth;
                                            story.mewo[1]=uyear;
                                            uolo=story.olo ;
                                            
                                            greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                            
                                            if (greg) {

                                                if (uyear%4) mo[2]=28;
                                                else {
                                                    if (uyear%100) mo[2]=29;
                                                    else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                                    }
                                            }

                                            else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                            i--;
                                            continue ;
                                        }
                                    } else { umonth--; uday=mo[umonth]; i--; continue ;}
                                }
                                else { uday--;}
                                
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                uolo=story.olo ;
                                
                                if (uolo==last_xam) uday=4;
                                i--;
                                
                            }
                        }
                        
                        if (i) {
                            if (prosadd<0) {
                                prosadd=-i+1;
                                sprintf (str1024,"%07d",prosadd);
                            }
                            else {
                            prosadd=i-1;
                            sprintf (str1024,"%06d",prosadd);}
                            normtext_tomy(str1024,0);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                            _bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                        if (nowyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                        }

                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[nowmonth]+1,mhnxb-1,mhnyb[nowmonth]-1,olobkxr);
                            _outmystr_center_col(neohell_22n,month[nowmonth],mhnxt,mhnyt[nowmonth]+1, mhnxb, mhnyb[nowmonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[nowmonth],mhnxb,mhnyb[nowmonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[nowmonth]+1,mhnxt-1,mhnyb[nowmonth]+1);
                            line(mhnxt-1,mhnyb[nowmonth]+1,mhnxb,mhnyb[nowmonth]+1);

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        startmonth=unameday+1;
                        if (startmonth==8) startmonth=1;
                        
                        for (f=uday ; f>0 ; f--) {
                            startmonth=(startmonth==1) ? 7 : startmonth-1 ;
                        }
                        
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                            
                        continue ;    
                    }
                    
                    
                    if (flaggr) {
                        
                        story.olo=0;
                        story.meros[0]=uday;
                        story.meros[1]=umonth;
                        story.mewo[1]=uyear;
                        
                        if (story.olo<first_xam || story.olo>gre_xam_t) {greday=40; continue ;}
                        if (keyb_gr && story.olo>=gre_xam_1 && story.olo<=gre_xam_t) { information (0,"Η ημερομηνία αυτή δεν υπήρξε,\nλόγω εφαρμογής του Γρηγοριανού ημερολογίου!",0); greday=40;continue;}
                        if (greday==40) greday=uday; 
                        gremonth=umonth; 
                        greyear=uyear;
                        
                        b = (greyear%4) ? 28 : 29 ;
                        if (gremonth==2 && greday>b) greday=b;
                        else if (greday>mo[gremonth]) greday=mo[gremonth];
                        
                        nowyear=1582 ; 
                        // 1/1/1582 ήταν Δευτέρα !
                        //staday=2; 
                                
                        dx=1;
                        a = mo[1]+mo[3]+mo[4]+mo[5]+mo[6]+mo[7]+mo[8]+mo[9]+mo[10]+mo[11]+mo[12] ;

                        while(greyear>nowyear) {
                            
                            b = (nowyear%4) ? 28 : 29 ;
                            
                            dx=dx+a+b;
                            nowyear++;
                        }

                        b = (nowyear%4) ? 28 : 29 ;
                            
                        for (f=1 ; f<gremonth ; f++) {
                                dx = (f==2) ? dx+b : dx+mo[f] ;
                            }

                        for(f=1; f<=greday ; f++) dx++; 

                        grenameday = dx%7;
                        if (!grenameday) grenameday=7;
                        
                        if (keyb_gr) sprintf (str1024,"Ελλάδα, %02u-%02u-%04u ημέρα %s" , greday,gremonth,greyear,mera[grenameday]);
                        else sprintf(str1024,"(Julian) %02u-%02u-%04u : %s" , gremonth,greday,greyear,mera[grenameday]);
                        normtext_tomy(str1024,0);
                        mytext_toclipboard (str1024);
                        
                        if (keyb_gr) {
                        sprintf (str1024,"ΆΤΥΠΗ ΑΝΑΦΟΡΑ !!\nΕλλάδα, %02u-%02u-%04u ..",greday,gremonth,greyear);
                        sprintf (file_2,"..ήταν ημέρα %s !\nΤυπικά..δεν χρησιμοιείται!\nΔεν καταχωρείται! Γράφτηκε στο clipboard.",mera[grenameday]);}
                        else {
                            sprintf (str1024,"ATYPICAL REPORT !!\n%02u-%02u-%04u ..",gremonth,greday,greyear);
                            sprintf (file_2,"..was %s !\nTypically..it is not usable!\nCan't save! Just copied to  clipboard.",mera[grenameday]);
                        }
                        information (0,str1024,file_2);
                        
                        greday=40;
                        continue ;
                    }
                                  
                    
                    if (akyro) {                    // MENOU !!
                        if (uyear>1923) sprintf (str1kb,"%s%hu",submenu_1[15], uyear);
                        else sprintf (str1kb,"%s****",submenu_1[15]);
                        strcpy (submenu[15],str1kb);
                        
                        //opt[13] = (win_count==10) ? 0 : 1 ;
                        
                        if (uyear>1999) {
                            sprintf (str1kb,"%s%hu",submenu_1[4], uyear);
                            strcpy (submenu[4] , str1kb);
                            sprintf (str1kb,"%s%hu",submenu_1[6], uyear);
                            strcpy (submenu[6] , str1kb);
                            sprintf (str1kb,"%s%hu",submenu_1[7], uyear);
                            strcpy (submenu[7] , str1kb);
                            sprintf (str1kb,"%s%hu",submenu_1[8], uyear);
                            strcpy (submenu[8] , str1kb);
                            sprintf (str1kb,"%s%hu",submenu_1[9], uyear);
                            strcpy (submenu[9] , str1kb);
                            sprintf (str1kb,"%s%s%hu",submenu_1[14], omonth[umonth] , uyear);
                            strcpy (submenu[14],str1kb);
                            sprintf (str1kb,"%s%hu/%hu/%hu",submenu_1[18], uday,umonth,uyear);
                            strcpy (submenu[18],str1kb);
                            sprintf (str1kb,"%s%hu",submenu_1[19], uyear);
                            strcpy (submenu[19],str1kb);
                        }
                        else {
                            sprintf (str1kb,"%s****",submenu_1[4]);
                            strcpy (submenu[4] , str1kb);
                            sprintf (str1kb,"%s****",submenu_1[6]);
                            strcpy (submenu[6] , str1kb);
                            sprintf (str1kb,"%s****",submenu_1[7]);
                            strcpy (submenu[7] , str1kb);
                            sprintf (str1kb,"%s****",submenu_1[8]);
                            strcpy (submenu[8] , str1kb);
                            sprintf (str1kb,"%s****",submenu_1[9]);
                            strcpy (submenu[9] , str1kb);
                            sprintf (str1kb,"%s%s****",submenu_1[14], omonth[umonth]);
                            strcpy (submenu[14],str1kb);
                            sprintf (str1kb,"%s**/**/****",submenu_1[18]);
                            strcpy (submenu[18],str1kb);
                            sprintf (str1kb,"%s****",submenu_1[19]);
                            strcpy (submenu[19],str1kb);
                        }
                        
                        if (uyear<2000) {
                            opt[1] = opt[4] = opt[5] = opt[6] = opt[7] = opt[8] = opt[9] = opt[14] = 0 ; 
                        }
                        else {
                            opt[1] = opt[4] = opt[5] = opt[6] = opt[7] = opt[8] = opt[9] = opt[14] = 1 ; 
                        }
                        
                        if ( (uyear>1999) && (Diary) ) { opt[18] = 1 ;}  else { opt[18] = 0; } 
                        if ( (uyear>1999) && (year_notes) ) { opt[19] = 1 ;}  else { opt[19] = 0; } 
                        opt[10] = (uyear < 2017) ? 0 : 1 ;
                        opt[15] = (uyear < 1924) ? 0 : 1 ;
                        opt[11] = (ar_per && uyear>1999) ? 1 : 0 ;
                        opt[16] = (ar_clue && uyear>1999) ? 1 : 0 ;
                        opt[12] = (ar_per<730 && uyear>1999) ? 1 : 0 ;
                        opt[17] = (ar_clue<250 && uyear>1999) ? 1 : 0 ;
                        dx=fastmenu_show_opt(21, opt, submenu, epilogeas , akyroxt, akyroyt-463);
                        ektos=1;
                        akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255);
                        if (dx<0) continue ;
                        
                        
                        switch (dx) {
                            case 0:     // ΑΝΤΙΓΡΑΦΗ στοιχείων ημέρας στον Clipboard
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                strcpy (mera[0],mera[unameday]);
                                if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                                else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                                i=0;
                                normtext_tomy(str1024,flddate);
                                while (flddate[i]!=255) i++;
                                
                                if (uyear>1999) {
                                    
                                    flddate[i++]=200;
                                    sprintf(str1024,"Ημέρα του έτους %dη - ", (int) aaday);
                                    normtext_tomy(str1024,file_3);
                                    f=0;
                                    while (file_3[f]!=255) { flddate[i++] = file_3[f++] ; }
                                    f=0;
                                    while (meravdomada[f]!=255) { flddate[i++] = meravdomada[f++] ; }
                                    
                                    flddate[i++]=200; 
                                    sprintf (str1024,"Ανατ. Ηλίου : %02d.%02d , Δύση Ηλίου : %02d.%02d",srise_hc,srise_mc,sset_hc,sset_mc);
                                    normtext_tomy(str1024,file_3);
                                    f=0;
                                    while (file_3[f]!=255) { flddate[i++] = file_3[f++] ; }
                                    
                                    flddate[i++]=200; 
                                    normtext_tomy(moonstr_1,file_3);
                                    f=0;
                                    while (file_3[f]!=255) { flddate[i++] = file_3[f++] ; }
                                    
                                    flddate[i++]=0; flddate[i++]=12; flddate[i++]=0 ;
                                    if (MOON_ord==1) sprintf (file_3,"%s , %s",MOONrise,MOONset);
                                    else sprintf (file_3,"%s , %s",MOONset,MOONrise);
                                    normtext_tomy(file_3,0);
                                    f=0;
                                    while (file_3[f]!=255) { flddate[i++] = file_3[f++] ; }
                                }
                                
                                f=0;
                                if (egiortes[0] != 255) {
                                    flddate[i++]=200; 
                                    normtext_tomy ("Εορτές - Υπομνήσεις :\n",file_3);
                                    while (file_3[f]!=255) { flddate[i++] = file_3[f++] ; }
                                    f=0;
                                    while (egiortes[f]!=255) { flddate[i++] = egiortes[f++] ; }
                                }

                                f=0;
                                if (enames[0] !=255) {
                                flddate[i++]=200;
                                normtext_tomy ("Σχετικά Ονόματα :\n",file_3);
                                while (file_3[f]!=255) { flddate[i++] = file_3[f++] ; }
                                f=0;
                                while (enames[f]!=255) { flddate[i++] = enames[f++] ; }
                                }
                                flddate[i]=255;
                                dx = mytext_toclipboard (flddate);
                                if (dx) information (0,"Επιτυχής αντιγραφή !",0);
                                continue ;
                            
                            case 1:     // Αναζήτηση ονόματος (ελεύθερη)
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue;}
                                dx=input_dbsearch_text(onomax , -2);
                                if (dx!=1 || onomax[0]==255) continue ;
                                if (onomax[1]==255) { onomax[0]=255; continue;}
                                atona(onomax);
                                i=0;
                                for (f=0;f<ar_son;f++) {
                                    if (mystrstr(sonoma_a[f],onomax)) {
                                        vrika[i][0]=0;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }

                                for (f=0;f<ar_kon;f++) {
                                    if (mystrstr(konoma_a[f],onomax)) {
                                        vrika[i][0]=1;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }
                                if (!i) // Μήνυμα εδώ...τίποτε !
                                {information (0,"Δεν βρέθηκε τίποτε!",0); continue;}
                                if (i==1) {
                                    
                                    if (!vrika[0][0]) {
                                        dx=vrika[0][1] ;
                                        f=santist[dx];
                                        dx=ssee[f].dm[0];
                                        dy=ssee[f].dm[1] ;
                                    }
                                    else {
                                        dx=vrika[0][1] ;
                                        f=kantist[dx];
                                        dx=ksee[f].dm[0];
                                        dy=ksee[f].dm[1] ;
                                    }
                                    
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                }        
                                else { 
                                    normtext_tomy("Αποτελέσματα-Πίνακας Επιλογών",ebutname);
                                    //printf ("Βρέθηκαν %d ονόματα ! \n" , i);
                                    dx = name_show(i,ebutname,&name_sorton,0);
                                    if (dx>=0) {
                                        if (!vrika[dx][0]) {
                                            dy=vrika[dx][1];
                                            f=santist[dy];
                                            dx=ssee[f].dm[0];
                                            dy=ssee[f].dm[1] ;
                                        }
                                        else {
                                            dy=vrika[dx][1];
                                            f=kantist[dy];
                                            dx=ksee[f].dm[0];
                                            dy=ksee[f].dm[1] ; 
                                        }
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                    }
                                    else {continue;}
                                }
                                
                            case 2:     // Δείτε Ονόματα - Αναζητείστε (Α-Μ)
                                
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                Header = "Γραμματοσειρά Καταλόγου Ονομάτων";
                                dbbut[0].butt_elem = sbutton_show ( dbbut[0].mem_butt , dbbut[0].butt_data , dbbut[0].butt_ar , dbbut[0].butt_orio , dbbut[0].butt_name , &dbbut[0].butt_sorton , 0 );
                                dx=dbbut[0].butt_elem;
                                Header = (char *) NULL ;
                                if (dx<0) continue ;
                                if (uyear<2000) {information (0,"Για να υπολογιστεί η ημερομηνία..","..καθορίστε έτος από το 2000 και μετά !"); continue;}
                                mystrcpy_lim(onomax,dbbut[0].butt_data,20);
                                i=0;
                                atona (onomax) ;
                                for (f=0;f<ar_son;f++) {
                                    if (mystrstr(sonoma_a[f],onomax)) {
                                        vrika[i][0]=0;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }

                                for (f=0;f<ar_kon;f++) {
                                    if (mystrstr(konoma_a[f],onomax)) {
                                        vrika[i][0]=1;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }
                                if (!i) continue ; // Μήνυμα εδώ...τίποτε !
                                if (i==1) {
                                    
                                    if (!vrika[0][0]) {
                                        dx=vrika[0][1] ;
                                        f=santist[dx];
                                        dx=ssee[f].dm[0];
                                        dy=ssee[f].dm[1] ;
                                    }
                                    else {
                                        dx=vrika[0][1] ;
                                        f=kantist[dx];
                                        dx=ksee[f].dm[0];
                                        dy=ksee[f].dm[1] ;
                                    }
                                    
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                }        
                                else { 
                                    normtext_tomy("Αποτελέσματα-Πίνακας Επιλογών",ebutname);
                                    //printf ("Βρέθηκαν %d ονόματα ! \n" , i);
                                    dx = name_show(i,ebutname,&name_sorton,0);
                                    if (dx>=0) {
                                        if (!vrika[dx][0]) {
                                            dy=vrika[dx][1];
                                            f=santist[dy];
                                            dx=ssee[f].dm[0];
                                            dy=ssee[f].dm[1] ;
                                        }
                                        else {
                                            dy=vrika[dx][1];
                                            f=kantist[dy];
                                            dx=ksee[f].dm[0];
                                            dy=ksee[f].dm[1] ; 
                                        }
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                    }
                                    else {continue;}
                                }

                            case 3:     // Δείτε Ονόματα - Αναζητείστε (Ν-Ω)
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                Header = "Γραμματοσειρά Καταλόγου Ονομάτων";
                                dbbut[1].butt_elem = sbutton_show ( dbbut[1].mem_butt , dbbut[1].butt_data , dbbut[1].butt_ar , dbbut[1].butt_orio , dbbut[1].butt_name , &dbbut[1].butt_sorton , 0 );
                                dx=dbbut[1].butt_elem;
                                Header = (char *) NULL ;
                                if (dx<0) continue ;
                                if (uyear<2000) {information (0,"Για να υπολογιστεί η ημερομηνία..","..καθορίστε έτος από το 2000 και μετά !"); continue;}
                                mystrcpy_lim(onomax,dbbut[1].butt_data,20);
                                i=0;
                                atona(onomax);
                                for (f=0;f<ar_son;f++) {
                                    if (mystrstr(sonoma_a[f],onomax)) {
                                        vrika[i][0]=0;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }

                                for (f=0;f<ar_kon;f++) {
                                    if (mystrstr(konoma_a[f],onomax)) {
                                        vrika[i][0]=1;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }
                                if (!i) continue ; // Μήνυμα εδώ...τίποτε !
                                if (i==1) {
                                    
                                    if (!vrika[0][0]) {
                                        dx=vrika[0][1] ;
                                        f=santist[dx];
                                        dx=ssee[f].dm[0];
                                        dy=ssee[f].dm[1] ;
                                    }
                                    else {
                                        dx=vrika[0][1] ;
                                        f=kantist[dx];
                                        dx=ksee[f].dm[0];
                                        dy=ksee[f].dm[1] ;
                                    }
                                    
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                }        
                                else { 
                                    normtext_tomy("Αποτελέσματα-Επιλέξατε..",ebutname);
                                    //printf ("Βρέθηκαν %d ονόματα ! \n" , i);
                                    dx = name_show(i,ebutname,&name_sorton,0);
                                    if (dx>=0) {
                                        if (!vrika[dx][0]) {
                                            dy=vrika[dx][1];
                                            f=santist[dy];
                                            dx=ssee[f].dm[0];
                                            dy=ssee[f].dm[1] ;
                                        }
                                        else {
                                            dy=vrika[dx][1];
                                            f=kantist[dy];
                                            dx=ksee[f].dm[0];
                                            dy=ksee[f].dm[1] ; 
                                        }
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                    }
                                    else {continue;}
                                }
                                
                            case 4:     // Εορτολόγιο Έτους
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue;}
                                sprintf (ebutname,"Ε Ο Ρ Τ Ο Λ Ο Γ Ι Ο  %hu",uyear);
                                normtext_tomy (ebutname,0);
                                Header = "Γραμματοσειρά Εορτολογίου";
                                dx=eortes_show(ebutname, &eort_sorton,0 );
                                Header = (char *) NULL ;
                                if (dx>=0) {
                                    if (dx<ar_seo) {
                                        i=ssee[dx].dm[0];
                                        f=ssee[dx].dm[1];
                                    }
                                    else {
                                        i=ksee[dx-ar_seo].dm[0];
                                        f=ksee[dx-ar_seo].dm[1];
                                    }
                                }
                                else {eprosyear=0 ; break ;}

                            //printf("uday : %d , umonth : %d \n" , i, f);
                            eprosyear = uyear;
                            eprosmonth = (unsigned short int) f;
                            eprosday = (unsigned short int) i;
                            break;
                            
                            case 5:     // Αναζήτηση εορτής (ελεύθερη)
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue;}
                                dx=input_dbsearch_text(eortx , -3);
                                if (dx!=1 || eortx[0]==255) continue ;
                                if (eortx[1]==255) { eortx[0]=255; continue;}
                                atona(eortx);
                                i=0;
                                for (f=0;f<ar_seo;f++) {
                                    mystrcpy(eort_at,seort[f]);
                                    atona(eort_at);
                                    if (mystrstr(eort_at,eortx)) {
                                        vrika[i][0]=0;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }

                                for (f=0;f<ar_keo;f++) {
                                    mystrcpy(eort_at,keort[f]);
                                    atona(eort_at);
                                    if (mystrstr(eort_at,eortx)) {
                                        vrika[i][0]=1;
                                        vrika[i][1]=f;
                                        i++;
                                    }
                                }
                                if (!i) // Μήνυμα εδώ...τίποτε !
                                {information (0,"Δεν βρέθηκε τίποτε!",0); continue;}
                                if (i==1) {
                                    
                                    if (!vrika[0][0]) {
                                        f=vrika[0][1] ;
                                        dx=ssee[f].dm[0];
                                        dy=ssee[f].dm[1] ;
                                    }
                                    else {
                                        f=vrika[0][1] ;
                                        dx=ksee[f].dm[0];
                                        dy=ksee[f].dm[1] ;
                                    }
                                    
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                }        
                                else { 
                                    normtext_tomy("Αποτελέσματα-Επιλέξατε..",ebutname);
                                    //printf ("Βρέθηκαν %d ονόματα ! \n" , i);
                                    dx = pieseortes_show(i,ebutname,&eort_sorton,0);
                                    if (dx>=0) {
                                        if (!vrika[dx][0]) {
                                            f=vrika[dx][1];
                                            dx=ssee[f].dm[0];
                                            dy=ssee[f].dm[1] ;
                                        }
                                        else {
                                            f=vrika[dx][1];
                                            dx=ksee[f].dm[0];
                                            dy=ksee[f].dm[1] ; 
                                        }
                                    eprosyear = uyear;
                                    eprosmonth = (unsigned short int) dy;
                                    eprosday = (unsigned short int) dx;
                                    break ;
                                    }
                                    else {continue;}
                                }

                            case 6:     // Χριστούγεννα
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue;}
                                eprosyear = uyear;
                                eprosmonth = 12;
                                eprosday = 25 ;
                                break ;
                                
                            case 7:     // Πάσχα
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue;}
                                eprosyear = uyear;
                                eprosmonth = pasxa_month;
                                eprosday = pasxa_day ;
                                break ;
                                
                            case 8:     // Γιορτή Μητέρας
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue;}
                                gsee.tog=mo_dm;
                                eprosyear = uyear;
                                eprosmonth = gsee.dm[1];
                                eprosday = gsee.dm[0];
                                break ;
                                
                            case 9:     // Γιορτή Πατέρα
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue;}
                                gsee.tog=fa_dm;
                                eprosyear = uyear;
                                eprosmonth = gsee.dm[1];
                                eprosday = gsee.dm[0];
                                break ;
                                
                            case 10:     // Παγκόσμιες-Διεθνείς Ημέρες
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2017) {information (0,"Καθορίστε έτος από το 2017 και μετά !",0);
                                continue;}
                                strcpy (ebutname,"Παγκόσμιες-Διεθνείς (και άλλες) Ημέρες");
                                normtext_tomy (ebutname,0);
                                Header = "Γραμματοσειρά Παγκόσμιων/Διεθνών Ημερών" ;
                                dx=pagkosm_show(ebutname, &pagk_sorton,0 );
                                Header = (char *) NULL ;
                                if (dx>=0) {
                                        gsee.tog=pagk_dm[dx] ;
                                        i=gsee.dm[0];
                                        f=gsee.dm[1];
                                }
                                else {eprosyear=0 ; break ;}

                            //printf("uday : %d , umonth : %d \n" , i, f);
                            eprosyear = uyear;
                            eprosmonth = (unsigned short int) f;
                            eprosday = (unsigned short int) i;
                            break;
                            
                            case 11 : //Προσωπικές Πάγιες Επέτειοι-Υπομνήσεις
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue ; }
                                if (!ar_per) { 
                                    f=pers_inp (0, -1, 1, uday, umonth, uyear );
                                    if (!f) continue ; else ar_per++;}
                                Header = "Γραμματοσειρά Προσωπικών Υπομνήσεων" ;
                                f = butpers_show(&pers_sorton , uday, umonth, uyear );
                                Header = (char *) NULL ;
                                if (f<0) {
                                    
                                    if ( (!ar_per) && (DIAK1) ) {
                                        for (md=1 ; md<=mo[umonth] ; md++){
                                            
                                            if (! only[umonth][md]) { continue ; } 
                                            v1 = md / 7 ;
                                            v2 = md % 7 ;

                                            v = (v2) ? v1 : v1-1 ;
                                            dy = cayt + (v*25) + 25 ;
                                            
                                            v = (!v2) ? 6 : v2-1 ;
                                            dx = caxt + (v*60) ;
                                            
                                        
                                        if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                                        else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                                        for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+14 ; f<=dy+21; f++) _putpixel (i,f);}
                                    }
                                        refresh();
                                }
                                    
                                    rech=1; 
                                    continue ;}
                                gsee.tog = pers[f].when;
                                eprosyear = pers[f].year;
                                eprosmonth = gsee.dm[1] ;
                                eprosday = gsee.dm[0] ;
                                rech=1;
                                break ;
                                
                            case 12 : // Προσθέστε νέα προσωπική Επέτειο-Υπόμνηση
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue ; }
                                if (ar_per==730) {information (0,"Συμπληρώθηκε ο μέγιστος αριθμός!",0); continue ; }
                                if (ar_per<730) f = pers_inp (ar_per, -1 , ar_per+1, uday, umonth, uyear);
                                if (f) { ar_per++; rech=1; }
                                continue ;
                                
                            case 13 :   // Open - Close Notes
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                dhide=1;
                                setcurrentwindow (win_id);
                                mem_arrs=malloc(imagesize(info.left+1, yyt , info.right-1, info.bottom-1));
                                if (!mem_arrs) {information(2-keyb_gr,NULL,NULL);continue;}
                                
                                // Αποκατάσταση inpbox και αρχείου NotesBox.dat
                                inpbox = 1-inpbox;
                                sprintf(file_1,"%s%s",user_path,".EORT_SETTINGS/NotesBox.dat");
                                fp=fopen(file_1,"r+b");
                                if (fp==NULL) {
                                    fp=fopen(file_1,"wb");
                                    fide_fp=fileno(fp);
                                    fwrite (&inpbox,4,1,fp);
                                    fdatasync (fide_fp);
                                    fsync (fide_fp);
                                    fclose(fp);
                                }
                                else {
                                    fide_fp=fileno(fp);
                                    fwrite (&inpbox,4,1,fp);
                                    fdatasync (fide_fp);
                                    fsync (fide_fp);
                                    fclose (fp) ;
                                }
                                
                                
                                getimage(info.left+1, yyt , info.right-1, info.bottom-1, mem_arrs);
                                
                                SDL_HideWindow(bgi_window);
                                
                                if (win_count==1) { // Δημιουργώ ένα παράθυρο ακόμη
                                    win_count++;
                                // NEW WINDOW OPEN
                                    dy = (inpbox) ? 760 : 760-223 ;
                                    Xx=(DM.w-1280)/2;
                                    Yy=(DM.h-dy)/2;
                                    setwinoptions("Ημερολόγιο & Εορτολόγιο - GReortes v.3.3",Xx,Yy,-1);
                                    initwindow (1280,dy);
                                    win_id=getcurrentwindow();
                                    winid5 = win_id ;
                                    sdlwin1 = SDL_GetWindowID(bgi_window);
                                    pran = sdlwin1;
                                    getviewsettings (info_p);
                                    memcpy (info_p5 , info_p , size_info);
                                    memcpy (info_p3 , info_p , size_info);
                                    
                                }
                                else {
                                    win_id = (winwho) ? winid4 : winid5 ;
                                    winwho = 1 - winwho ;
                                    setcurrentwindow (win_id);
                                    sdlwin1 = SDL_GetWindowID(bgi_window);
                                    SDL_ShowWindow(bgi_window);
                                    SDL_RaiseWindow(bgi_window);
                                    pran = sdlwin1;
                                    if (win_id==winid4) { memcpy (info_p , info_p4 , size_info); }
                                    else { memcpy (info_p , info_p5 , size_info); }
                                    memcpy (info_p3 , info_p , size_info);
                                }
                                
                                setblendmode (SDL_BLENDMODE_BLEND);
                                qcls(159,155,116);
                                win1m = win1h = 0 ;

                                xt=(info.left+3) ; yt=(info.top+2) ;
                                if (inpbox) {
                                    inpx=xt; inpy=yt+23 ; inpx1=info.right-17; inpy1=inpy+200;
                                    movext=xt+360;
                                    setcolor(2);
                                    rectangle (movext,yt+1,inpx1-360,yt+22);
                                    _bareacls(movext+1,yt+2,inpx1-361,yt+21,ejobkxr);
                                    
                                    if (!keyb_gr) strcpy (str1024,"Notes") ;
                                    else strcpy (str1024,"Σημειώσεις");
                                    normtext_tomy (str1024,0);
                                    _outmystr_center_col (notosans_16n,str1024,movext,yt+2,inpx1-360,yt+22,bluechxr, ejobkxr);
                                    refresh();
                                }
                                else {
                                    inpy1=yt;
                                }

                                yyt=inpy1+5;
                                xb=xt+539; yb=yyt+499;
                                recfullxt = xt+30 ;
                                leyearxt=xt+30;
                                ledayxt=xt+50;
                                movext=caxt=xt+6 ;
                                inpyearxt=xt+93;
                                //moveyt=yt+4; // Επικεφαλίδα στο yt+4 επίσης!
                                recfullyt=yyt+33;
                                recfullyb=recfullyt+28;
                                leyearyt=riyearyt=recyearyt=mhnyb[0]=recfullyb+8;
                                mhnyb[0]-=4;
                                recyearxt=leyearxt+30;
                                recshmxt=ledayxt+30;
                                recfullxb=xb-150;
                                recyearyb=recyearyt+25;
                                ledayyt=ridayyt=recshmyt=recyearyb+4;
                                recshmyb=recshmyt+25;
                                cayt=recshmyb+9;
                                                                
                                // ΕπανΥπολογισμός cx - cy
                                for (i=1 ; i<8 ; i++ ) { cx[i]=caxt+(i-1)*60; }
                                caxb=caxt+(i-1)*60;
                                for (f=0 ; f<6;f++) { cy[f]=cayt+f*25; }
                                cayb=cayt+f*25;

                                ridayxt=caxb-76;
                                riyearxt=caxb-56;
                                recyearxb=riyearxt-4 ;
                                recshmxb=ridayxt-4 ;
                                inpyearxb=inpyearxt+80;
                                inpmonthxt=inpyearxb+31; inpmonthxb=inpmonthxt+40;
                                inpdayxt=inpmonthxb+29; inpdayxb=inpdayxt+40;
                                inpyearyt = inpmonthyt = inpdayyt = cayb+66;
                                // ENDIAMESA NA GRAFEI KATI....
                                inpyearyb=inpmonthyb=inpdayyb=inpdayyt+25;
                                putokxt=inpdayxb+7; putokyt = inpdayyt-4;
                                // ENDIAMESA NA GRAFEI KATI....
                                adddaysxt=xt+155; adddaysyt=inpyearyb+40;
                                adddaysxb=adddaysxt+120;
                                adddaysyb=adddaysyt+25;
                                addokxt=adddaysxb+7; addokyt=adddaysyt-4 ;
                                //yesxt = xb-90 ; yesyt = adddaysyb+17;
                                
                                flaggrxt=xt+244; flaggryt=adddaysyb+25;
                                sunrise_yt = adddaysyb + 8; 
                                sunset_yt = sunrise_yt + 24 ; 
                                moonphase_yt = sunrise_yt ;
                                lunary = sunrise_yt ;
                                moonri_yt = moonphase_yt+16 ;
                                moonse_yt = moonri_yt + 16 ;

                                eort_recxt=onom_recxt=xb+5; eort_recyt=yyt ;
                                akyroxt = eort_recxt+50 ; 
                                eort_recxb=onom_recxb=info.right-17; eort_recyb=yyt+250;
                                onom_recyt=eort_recyb+2; onom_recyb=yb;
                                stikx = xb - 40 ; stiky = yyt + 6 ;
                                eort_recxt+=3 ; eort_recyt+=29 ; eort_recyb-=3 ; eort_recxb-=3;
                                onom_recxt+=3 ; onom_recyt+=29 ; onom_recyb-=3 ; onom_recxb-=3;
                                vel_xt=eort_recxb+4; vel_yt=eort_recyt; vel_xb=vel_xt+14; vel_yb=onom_recyb;
                                akyroyt = yb+5 ;
                                diak2x = xt + 2 ; diak1x =  diak2x+324 ;
                                diak2y = diak1y =yb+2 ;

                                if (inpbox) {
                                    movext=xt+360;
                                    setcolor(1);
                                    line (inpx,yt+10,movext-1,yt+10);
                                    line (inpx,yt+10,inpx,inpy1);
                                    line (inpx,inpy1,inpx1,inpy1);
                                    line (inpx1,inpy1,inpx1,yt+10);
                                    line (inpx1,yt+10,inpx1-358,yt+10);
                                    
                                    setcolor(2);
                                    line (inpx+1,yt+11,movext-1,yt+11);
                                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                                    
                                    setcolor(1);
                                    line (inpx+2,yt+12,movext-1,yt+12);
                                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                                    
                                    _bareacls (inpx+3,yt+13,movext-1,inpy+3,olobkxr);
                                    _bareacls (inpx1-358,yt+13,inpx1-3,inpy+3,olobkxr);
                                    _bareacls (movext,yt+23,inpx1-358,inpy+3,olobkxr);
                                    _bareacls (inpx+3,inpy,inpx1-3,inpy1-3,olobkxr);

                                    inpx+=3 ; inpy+=3; inpx1-=3; inpy1-=3;

                                    gouv=myfont[notes_font];
                                    _txt_show (notes_str , inp_cur, inpx, inpy ,inpx1 , inpy1 , 60000 , olochxr, notesbkxr, ejobkxr);
                                }
                                kext=recyearxt+((recyearxb-recyearxt)/2);
                                keyt=recfullyb+2;
                                
                                mhnxt=caxb+10;
                                mhnxb=mhnxt+100;
                                for (f=1; f<13 ; f++) {
                                    mhnyt[f]=mhnyb[f-1]+4;
                                    mhnyb[f] = mhnyt[f]+26;
                                }
                                eyext = eort_recxt + 4 ; eyeyt = eort_recyt-23 ;
                                memox = eyext + 50 ; memoy = eyeyt ;
                                putimage(info.left+1, yyt , mem_arrs , 0 );
                                free(mem_arrs);
                                refresh();
                                    
                                continue ;
                                
                            case 14 : // Μηνιαία Αναφορά 
                            
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                            SDL_SetCursor(cursor);
                            ektos=1;

                            if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue ; }
                            
                            dd = startmonth ;
                            
                            //check_startmonth=find_dayname(uyear , umonth , 1);
                            
                            //if (dd != check_startmonth) information (0,"25954-Διαφορετικό startmonth...ψάξτο !!" , 0 ) ;
                            
                            if ( ar_clue ) {
                                
                            // Έλεγχος Recursive - ενημέρωση πίνακα δομής mra
                                
                                c_arma = 0;   mra = mra_1 ;
                                
                                for (f=0 ; f<ar_clue ; f++) {
                                    
                                    switch (rcr[f].freq)
                                    {
                                        case 0 :
                                            
                                            continue ;
                                            
                                        case 1 :
                                            
                                            month_recur_days ( f , uyear , umonth, mo );
                                            break ;
                                            
                                        case 7 :
                                            
                                            month_recur_week ( f , uyear , umonth , startmonth , mo);
                                            break ;
                                            
                                        case 30 :
                                            
                                            month_recur_month_st ( f , uyear , umonth , startmonth , mo);
                                            break ;
                                            
                                        case 31 :
                                            
                                            month_recur_month_w ( f , uyear , umonth , startmonth , mo);
                                            break ;
                                            
                                        case 32 :
                                    
                                        month_recur_month_bima (f , uyear , umonth , mo);
                                        break ;
                                            
                                        case 365 :
                                            
                                            month_recur_year_st (f , uyear , umonth , mo);
                                            break ;
                                            
                                        case 366 :
                                            
                                            month_recur_year_w (f , uyear , umonth , startmonth, mo);
                                            break ;

                                    }
                                }
                                
                            }
                            
                            sprintf (str1kb,"%s%s%s%hu.txt",user_path,eggr_str,omonth[umonth],uyear); 
                            fp=fopen(str1kb,"w");
                            if (fp==NULL) {information(6-keyb_gr,str1kb,NULL); continue ;}
                            fide_fp = fileno (fp) ;
                            if (fide_fp==-1) {information(6-keyb_gr,str1kb,NULL); clearerr(fp); fclose(fp); continue ;}
                            gsee.dm[1]=umonth;
                            sprintf (str1kb,">> GReortes v.3.3 - Μ Η Ν Ι Α Ι Α    Α Ν Α Φ Ο Ρ Α   %s / %hu" , omonth[umonth],uyear );
                            Rlen = real_strlen(str1kb);
                            fprintf (fp,"%s\n",str1kb);
                            fdatasync (fide_fp);
                            fill_char(str1kb,Rlen,"-");
                            fprintf (fp,"%s\n\n",str1kb);
                            fdatasync (fide_fp);

                            for (md=1; md<=mo[umonth] ; md++) {
                                
                                sprintf (str1kb,"- Ημέρα %s , %d-%s%hu",mera[dd], md, omonth[umonth],uyear );
                                Rlen = real_strlen(str1kb); 
                                fprintf (fp,"%s\n",str1kb);
                                fdatasync (fide_fp);
                                fill_char(str1kb,Rlen,"*");
                                fprintf (fp,"%s\n",str1kb);
                                fdatasync (fide_fp);
                                
                                if (uyear>1999) {
                                    sunrise_sunset(uyear,umonth,md);
                                    sprintf (str1kb,"Ανατ. Ηλίου : %02d.%02d , Δύση Ηλίου : %02d.%02d",srise_h,srise_m,sset_h,sset_m);
                                    fprintf (fp,"%s\n",str1kb);
                                    fdatasync (fide_fp);
                                    
                                    moonPhases((int) uyear, (int) umonth, md) ;
                                    fprintf (fp,"%s , ",MoonStr);
                                    fdatasync (fide_fp);
                                    
                                    moonrise_moonset(uyear, umonth , (unsigned short int) md , mo);
                                    if (moon_ord==1) sprintf (str1kb,"%s , %s",moonrise_txt,moonset_txt);
                                    else sprintf (str1kb,"%s , %s",moonset_txt,moonrise_txt);
                                    fprintf (fp,"%s\n",str1kb);
                                    fdatasync (fide_fp);
                                }
                                
                                gsee.dm[0]=md;
                                
                                dx = 0 ;
                                
                                // ELEGXOS HMEROMHNIAS STAUERVN EORTVN
                                
                                
                                a=0;
                                for (f=0;f<ar_seo;f++) {
                                    if (gsee.tog!=ssee[f].tog) continue ;
                                    while (gsee.tog==ssee[f].tog) {
                                        if (!dx) {
                                            dx=1;
                                            fprintf (fp,"%s","->  Εορτές :\n");
                                            fdatasync (fide_fp);
                                        }
                                        vrika[a][0]=0; vrika[a][1]=f ; a++;
                                        mytext_tonorm (seort[f] , big_char,142); 
                                        fprintf (fp,"%s%s",big_char,"\n");
                                        fdatasync (fide_fp);
                                        f++;
                                        if (f==ar_seo) break ;
                                    }
                                    if (f<647) {f=647; continue;}
                                }

                                // ELEGXOS HMEROMHNIAS KINHTVN EORTVN
                                for (f=0;f<ar_keo;f++) {
                                    if (gsee.tog!=ksee[f].tog) continue ;
                                    if (!dx) {
                                            dx=1;
                                            fprintf (fp,"%s","->  Εορτές :\n");
                                            fdatasync (fide_fp);
                                        }
                                    vrika[a][0]=1; vrika[a][1]=f ; a++;
                                    mytext_tonorm (keort[f] , big_char,142); 
                                    fprintf (fp,"%s%s",big_char,"\n");
                                    fdatasync (fide_fp);
                                }
                                
                                if (!a) {
                                    fprintf (fp,"%s","Δεν είναι καταχωρημένη καμμία εορτή!\n");
                                    fdatasync (fide_fp);
                                }
                                
                                dx=0 ;
                                if (uyear>2016) {

                                // Έλεγχος για Παγκόσμιες ημέρες
                                
                                    for (f=0; f<ar_pagk_1 ;f++) {
                                    if (gsee.tog!=pagk_dm[f]) continue ;
                                    if (!dx) {
                                        dx=1;
                                        fprintf (fp,"%s","\n->  Παγκόσμιες-Διεθνείς και άλλες ημέρες :\n");
                                        fdatasync (fide_fp);
                                        }
                                    mytext_tonorm (pagk[f] , big_char,240); 
                                    fprintf (fp,"%s%s",big_char,"\n");
                                    fdatasync (fide_fp);
                                    }
                                }
                                
                                
                                // Μητέρας - Πατέρα
                                
                                if(gsee.tog==mo_dm) {
                                    if (!dx) {
                                        dx=1;
                                        fprintf (fp,"%s","\n->  Παγκόσμιες-Διεθνείς και άλλες ημέρες :\n");
                                        fdatasync (fide_fp);
                                        }
                                    mytext_tonorm (mother , big_char,100); 
                                    fprintf (fp,"%s%s",big_char,"\n");
                                    fdatasync (fide_fp);
                                }
                                
                                if(gsee.tog==fa_dm) {
                                    if (!dx) {
                                        dx=1;
                                        fprintf (fp,"%s","\n->  Παγκόσμιες-Διεθνείς και άλλες ημέρες :\n");
                                        fdatasync (fide_fp);
                                        }
                                    mytext_tonorm (father , big_char,100); 
                                    fprintf (fp,"%s%s",big_char,"\n");
                                    fdatasync (fide_fp);
                                }
                                
                               
                                // Προσωπικές Επέτειοι
                                dx=0;
                                if (uyear>1999) {
                                    for (f=0; f<ar_per ;f++) {
                                        if (gsee.tog!=pers1[f] || uyear<pers[f].year) continue ;
                                        if(!dx) {
                                            sprintf (str1kb , "-> Προσωπικές Υπομνήσεις - Επέτειοι (%d/%hu/%hu)",md,umonth,uyear );
                                            fprintf (fp,"\n%s\n",str1kb);
                                            fdatasync (fide_fp);
                                            Rlen = real_strlen(str1kb); 
                                            fill_char(str1kb,Rlen,"-");
                                            fprintf (fp,"%s\n",str1kb);
                                            fdatasync (fide_fp);
                                            dx=1;
                                        }
                                        mytext_tonorm (pers[f].tex , big_char,150); 
                                        fprintf (fp,"%s%s",big_char,"\n");
                                        fdatasync (fide_fp);
                                    }
                                    
                                    
                                    // Έλεγχος recursive για περιπτώσεις freq : 1 - 366 
                                    
                                    for (i=0; i<c_arma; i++) {
                                        mrs = mra_1 + i ;
                                        if (mrs->date == gsee.tog) {
                                            if(!dx) {
                                                sprintf (str1kb , "-> Προσωπικές Υπομνήσεις - Επέτειοι (%d/%hu/%hu)",md,umonth,uyear );
                                                fprintf (fp,"\n%s\n",str1kb);
                                                fdatasync (fide_fp);
                                                Rlen = real_strlen(str1kb); 
                                                fill_char(str1kb,Rlen,"-");
                                                fprintf (fp,"%s\n",str1kb);
                                                fdatasync (fide_fp);
                                                dx=1;
                                            }
                                            mytext_tonorm (rcr[mrs->dom].keim , big_char,150); 
                                            fprintf (fp,"%s%s",big_char,"\n");
                                            fdatasync (fide_fp);
                                        }
                                    }
                                    
                                }

                                fprintf (fp,"\n");
                                fdatasync (fide_fp);
                                
                                dx=0;

                                // Ονόματα που εορτάζουν...
                                
                                for (f=0 ; f<a ; f++) {
                                    if (!vrika[f][0]) {
                                        k=vrika[f][1];
                                        i=0;
                                        while ( (ase_aa[i] != k) && (i<ar_son) ) i++;
                                        if(i==ar_son) continue;
                                        do {
                                        if(!dx) {
                                            sprintf(str1kb,"-> Ονόματα που εορτάζουν :");
                                            Rlen = real_strlen(str1kb); 
                                            fprintf (fp,"%s\n",str1kb);
                                            fdatasync (fide_fp);
                                            fill_char(str1kb,Rlen,"-");
                                            fprintf (fp,"%s\n",str1kb);
                                            fdatasync (fide_fp);
                                            dx=1;
                                            }
                                            mytext_tonorm (ase_sonoma[i],big_char,50); 
                                            fprintf (fp,"%s  ",big_char);
                                            fdatasync (fide_fp);
                                            i++;
                                            if (i==ar_son) break ;
                                            } while (ase_aa[i]==k) ;
                                    }
                                    else {
                                        i=0;
                                        k=vrika[f][1];
                                        while ( (ake_aa[i] != k) && (i<ar_kon) ) i++;
                                            if(i==ar_kon) continue;
                                        do {
                                            if(!dx) {
                                            sprintf(str1kb,"-> Ονόματα που εορτάζουν :");
                                            Rlen = real_strlen(str1kb); 
                                            fprintf (fp,"%s\n",str1kb);
                                            fdatasync (fide_fp);
                                            fill_char(str1kb,Rlen,"-");
                                            fprintf (fp,"%s\n",str1kb);
                                            fdatasync (fide_fp);
                                            dx=1;
                                            }
                                            mytext_tonorm (ake_konoma[i],big_char,50); 
                                            fprintf (fp,"%s  ",big_char);
                                            fdatasync (fide_fp);
                                            i++;
                                            if (i==ar_kon) break ;
                                            } while (ake_aa[i]==k) ;
                                    }
                                }
                                if (dx) { fprintf (fp,"\n\n"); fdatasync (fide_fp); }
                                dd = (dd==7) ? 1 : dd+1 ;
                            }
                            sprintf (str1kb,"- Τέλος Αναφοράς για το Mήνα %s του έτους %hu -\n" , omonth[umonth],uyear);
                            fprintf (fp,"%s",str1kb);
                            fdatasync (fide_fp);
                            
                            sprintf (str1kb,"%s%s%s%hu.txt",user_path,eggr_str,omonth[umonth],uyear); 
                            md = fsync (fide_fp);
                            if (md==-1) {information(6-keyb_gr,str1kb,NULL); clearerr(fp);fsync(fide_fp);fclose(fp); continue;} 
                            fclose(fp);
                            
                            if ( (ORL) && (syscalls) ) {
                                sprintf (big_char,"Η μηνιαία αναφορά σώθηκε στο αρχείο :\n%s%s%s%hu.txt",user_path,eggr_str,omonth[umonth],uyear); 
                                dx=alert(0,big_char,"Θέλετε να δείτε τώρα την αναφορά ;");
                                if (dx==1) {
                                    
                                    Open_Report_Link(str1kb); 

                                }
                                
                            }
                            else {
                                sprintf (big_char,"%s%s%s%hu.txt",user_path,eggr_str, omonth[umonth],uyear);
                                information(0,"Αναφορά Έτοιμη! Βλ. αρχείο :",big_char);
                            }

                            continue ;
                            
                            case 15 : // Ετήσια Απεικόνιση
                                
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<1924) {information (0,"Καθορίστε έτος από το 1924 και μετά !",0); continue ; }
                                if (DM.w<etdmw || DM.h<etdmh) {
                                    sprintf (str1kb,"Πρέπει να είναι το λιγότερο :\n%hd X %hd pixels!" , etdmw , etdmh);
                                    information (0,"Δεν επαρκεί η ανάλυση της οθόνης!",str1kb);
                                    continue;}
                                
                            {
                                dmetav = 1;
                                if (mem_small) { hide_help(hdhlpxt , hdhlpyt); }
                                SDL_FlushEvent(SDL_MOUSEMOTION) ;
                                if (secwin) {
                                    if (win2m || win2h || pran==sdlwin1) {
                                        //SDL_FlushEvent(SDL_WINDOWEVENT);
                                        win2m = win2h = 0 ;
                                        setcurrentwindow(win_id_2);
                                        memcpy (info_p , info_p2 , size_info);
                                        SDL_ShowWindow(bgi_window);
                                        SDL_RaiseWindow(bgi_window);
                                        pran = sdlwin2;
                                        refresh();
                                        //do {
                                          //  SDL_PollEvent(&sdlev);
                                            //} while (sdlev.type == SDL_WINDOWEVENT) ;
                                            //SDL_FlushEvent(SDL_WINDOWEVENT);
                                    }
                                    
                                }
                                
                                auto unsigned short etxk , etyk , a1 , b1 , vx, vy ;
                                auto int red , green, blue ;
                                auto int locbkxr[3] ;
                                void *mem_clue , *mem_etclue ;
                                
                                
                                // 2nd WINDOW OPEN !!
                                if (!secwin) {
                                    //SDL_FlushEvent(SDL_WINDOWEVENT);

                                secwin=1;
                                Xxt=(DM.w-etdmw)/2; // Θα δούμε αν θα είναι 1280
                                Yyt=(DM.h-etdmh)/2;
                                setwinoptions("Πίνακας Έτους - Greortes v.3.3",Xxt,Yyt,-1);
                                initwindow (etdmw,etdmh);
                                refresh();
                                win_id_2=getcurrentwindow();
                                getviewsettings (info_p2);
                                memcpy (info_p3 , info_p , size_info); 
                                memcpy (info_p , info_p2 , size_info); 
                                sdlwin2 = SDL_GetWindowID(bgi_window);
                                pran = sdlwin2 ;
                                //setcurrentwindow(win_id_2);
                                SDL_RaiseWindow(bgi_window);
                                win2m = win2h = 0 ; 
                                etstikx = info.left + 7 ; etstiky = info.top + 7 ;
                                }
                                
                                et_is_note = 0 ;
                                Diary_q = Diary_u ;
                                locbkxr[0]=olobkxr[0] ; locbkxr[1] = olobkxr[1] ; locbkxr[2] = olobkxr[2] ;
                                qcls(locbkxr[0],locbkxr[1],locbkxr[2]);
                                setcolor (2);
                                rectangle (info.left , info.top , info.right , info.bottom);
                                setcolor (6);
                                rectangle (info.left+1 , info.top+1 , info.right-1 , info.bottom-1);
                                setcolor (2);
                                rectangle (info.left+2 , info.top+2 , info.right-2 , info.bottom-2);
                                refresh ();
                                qyear = uyear ;
                                qmonth = umonth ;
                                qday = uday ;
                                
                                for (f=1; f<13 ; f++) {
                                    etmo[f] = mo[f] ;
                                }
                                
                                if (qyear>1999) {
                                
                                    for (f=0; f<ar_keo; f++) {etksee[f].tog = ksee[f].tog;} 
                                    etmo_dm = mo_dm ; etfa_dm = fa_dm ;
                                }
                                
                                if ( (qyear>1999) && (ar_per) ) { 
                                    ar_per_1 = ar_per ;
                                    for (f=1 ; f<13 ; f++) {
                                        for (i=1 ; i<32 ; i++) {
                                            only_1[f][i]=0;
                                        }
                                    }
                                    
                                    for (f=0 ; f<ar_per_1 ; f++) {
                                        gsee.tog = etpers[f] = pers1[f];
                                        mystrcpy (ettex[f] , pers[f].tex);
                                        etpersyear[f] = pers[f].year;
                                        if (qyear >= etpersyear[f]) {
                                            only_1[gsee.dm[1]][gsee.dm[0]]=1;
                                        }
                                    }
                                } else {ar_per_1=0;}
                                
                                
                                
                                
                                if ( (qyear>1999) && (ar_clue) ) {
                                    
                                    etar_clue = ar_clue ;
                                 
                                // Αντιγραφή - Έλεγχος Recursive - ενημέρωση των only_1 και αποθήκευση στοιχείων στον πίνακα δομής mri
                                    
                                    c_arst=0; mri = mri_1 ;
                                    
                                    mem_clue = (void *) rcr;
                                    mem_etclue = (void *) etrcr;
                                    memcpy (mem_etclue , mem_clue , ( ar_clue * sizeof(struct RECURRENT) ) ) ;
                                    
                                    for (f=0 ; f<etar_clue ; f++) {
                                        
                                        switch (etrcr[f].freq)
                                        {
                                            case 0 :
                                                
                                                continue ;
                                                
                                            case 1 :
                                                
                                                year_recur_days ( f , qyear , only_1);
                                                break ;
                                                
                                            case 7 :
                                                year_recur_week ( f , qyear , only_1 );
                                                break ;
                                                
                                            case 30 :
                                                
                                                year_recur_month_st ( f , qyear , only_1);
                                                break ;
                                                
                                            case 31 :
                                                
                                                year_recur_month_w ( f , qyear , only_1);
                                                break ;
                                                
                                            case 32 :
                                    
                                                year_recur_month_bima (f , qyear , only_1);
                                                break ;
                                                
                                            case 365 :
                                                
                                                year_recur_year_st (f , qyear , only_1);
                                                break ;
                                                
                                            case 366 :
                                                
                                                year_recur_year_w (f , qyear , only_1);
                                                break ;

                                        }
                                    }
                                    
                                } else  etar_clue = 0 ;
                                
                                if (qyear>1999 && Diary_q) {
                                    for (f=1 ; f<13 ; f++) {
                                        for (i=1 ; i<32; i++) {
                                            etDIaryn[f][i] = DIaryn[f][i] ;
                                        }
                                    }
                                }
                                
                                if (qyear>2016) { for (f=0; f<ar_pagk_1; f++) {etpagk_dm[f]= pagk_dm[f] ;} }
                                                                                
                                etcaxt = info.left + 10 ; etcayt = info.top + 75 ;
                                etcaxb = etdmw-13 ; 
                                etxk = 40 ; etyk=40 ; vx = 105 ; vy = 26 ;
                                etcayb = etcayt + (4*150) + (3 * etyk) ;
                                                                
                                if (keyb_gr) sprintf (str1kb,"ΗΜΕΡΟΛΟΓΙΟ ΈΤΟΥΣ %hu",qyear);
                                else sprintf (str1kb,"YEAR CALENDAR %hu",qyear);
                                a1 = (etdmw - 440) / 2 ;
                                b1 = info.top + 9 ;
                                
                                setcolor (0);
                                rectangle (a1 , b1 , a1+440 , b1+34 ) ;
                                setcolor (4);
                                rectangle (a1+1 , b1+1 , a1+439 , b1+34) ;
                                normtext_tomy(str1kb,0);
                                _bareacls(a1+2,b1+2,a1+438,b1+33 , etyelxr);
                                _outmystr_center_col(bookman_22n, str1kb,a1+2,b1+2,a1+438,b1+33,etchxr,etyelxr);
                                if (qyear == etnowyear) {
                                    strcpy (str1kb , "(Τρέχων)");
                                    normtext_tomy(str1kb,0);
                                   _outmystr_col(2, str1kb,a1+376,b1+18,a1+438,redchxr,etyelxr); 
                                }
                                refresh();
                                
                                a=0;
                                for (f=0 ; f<4 ; f++) {
                                    for (i=0; i<3 ; i++) {
                                        a++;
                                        dd = find_dayname(qyear , a , 1);
                                        a1 = etcaxt + (i*420) + (i*etxk) ;
                                        b1 = etcayt + (f*150) + (f*etyk) ;
                                        
                                        _show_month_greg (a1, b1 , qyear , a , dd);
                                        setcolor (0);
                                        a1 = a1+vx ; b1 = b1-vy ;
                                        rectangle (a1,b1,a1+210,b1+22);
                                        normtext_tomy(etmonth[a],str1kb);
                                        _bareacls(a1+1,b1+1,a1+209,b1+21,etbkxr);
                                        etcomo[a][0] = a1+1 ; etcomo[a][1] = b1+1 ; 
                                        _outmystr_center_col(bookman_18n, str1kb,a1+2,b1+2,a1+209,b1+22,etchxr,etbkxr);
                                    }
                                    refresh();
                                }
                                
                                setcolor (2);
                                line (info.left+3 , etcayb+5 , info.right-3 , etcayb+5);
                                setcolor (6);
                                line (info.left+3 , etcayb+6 , info.right-3 , etcayb+6);
                                setcolor (2);
                                line (info.left+3 , etcayb+7 , info.right-3 , etcayb+7);
                                
                                
                                
                                // GIA save eikonas bmp apo info.left - info.top  eos  info.right , etcayb+7 !!
                                
                                // ΝΑ ΦΑΝΕΙ ΤΟ uday...
                                //loctim=time(NULL);
                                //etnowyear = diar->tm_year+1900;
                                    gsee.dm[0] = (char) uday ; gsee.dm[1] = (char) umonth ;
                                    et_enter = gsee.tog;
                                    a1 = umonth / 3 ;
                                    b1 = umonth % 3 ;
                                    
                                    a1 = (b1) ? a1 : a1-1 ;
                                    etky = etcayt + (a1 * 150) + (a1*etyk) + 25 ;
                                    
                                    a1 = umonth % 3 ;
                                    a1 = (a1) ? a1-1 : 2 ;
                                    etkx = etcaxt + (a1*420) + (a1*etxk) ;
                                    
                                    a1 = uday / 7 ;
                                    b1 = uday % 7 ;

                                    b1 = (b1) ? a1 : a1-1 ;
                                    etky = etky + (b1*25) ;
                                    
                                    b1 = uday % 7 ;
                                    
                                    b1 = (!b1) ? 6 : b1-1 ;
                                    etkx = etkx + (b1*60) ;
                                    
                                    alfa = (float) 60 / (float) 255 ;
                                    neg = ((float)1 - alfa);
                                    
                                    for (f=1;f<25;f++) {
                                        for (i=1;i<59;i++) {
                                        ba.lor = getpixel (etkx+i , etky+f);
                                        red = (int) ((alfa * (float) 106) + (neg * (float) ba.rgb[2]));
                                        green =  (int) ((alfa * (float) 202) + (neg * (float) ba.rgb[1]));
                                        blue =  (int) ( (alfa * (float) 82) + (neg * (float) ba.rgb[0]) );
                                        setcolor (COLOR ( red,green,blue) );  
                                        _putpixel (etkx+i,etky+f); 
                                        }
                                    }
                                    
                                    et_udrgb[0]=red; et_udrgb[1]=green; et_udrgb[2]=blue; 
                                    
                                refresh();
                                    
                                // Να φανούν οι ημέρες επετείων
                            /*
                                
                                if (qyear>1999) {
                                    for (f=0; f<ar_per_1 ;f++) {
                                        
                                        if (qyear < etpersyear[f]) continue ;
                                        
                                        gsee.tog = etpers[f];
                                        
                                        a1 = (int) gsee.dm[1] / 3 ;
                                        b1 = (int) gsee.dm[1] % 3 ;
                                        
                                        a1 = (b1) ? a1 : a1-1 ;
                                        etky = etcayt + (a1 * 150) + (a1*etyk) + 25 ;
                                        
                                        a1 = (int) gsee.dm[1] % 3 ;
                                        a1 = (a1) ? a1-1 : 2 ;
                                        etkx = etcaxt + (a1*420) + (a1*etxk) ;
                                        
                                        a1 = (int) gsee.dm[0] / 7 ;
                                        b1 = (int) gsee.dm[0] % 7 ;

                                        b1 = (b1) ? a1 : a1-1 ;
                                        etky = etky + (b1*25) ;
                                        
                                        b1 = (int) gsee.dm[0] % 7 ;
                                        
                                        b1 = (!b1) ? 6 : b1-1 ;
                                        etkx = etkx + (b1*60) ;
                                        
                                        _bareacls (etkx+51,etky+16,etkx+58,etky+23,epbkxr); 
                                    }
                                    refresh();
                                    etshowhide = 1 ;
                                } else etshowhide = 0 ;
                        */
                            
                            // Να φανούν οι ημέρες επετείων
                        
                        etshowhide = 0 ;
                        
                        if (qyear>1999 && ( (ar_per_1) || (etar_clue) ) ) {    
                            for (f=1 ; f<13 ; f++) {
                                for (i=1 ; i<=etmo[f] ; i++){
                                    if (only_1[f][i]) {
                                    
                                    a1 = f / 3 ;
                                    b1 = f % 3 ;
                                    
                                    a1 = (b1) ? a1 : a1-1 ;
                                    etky = etcayt + (a1 * 150) + (a1*etyk) + 25 ;
                                    
                                    a1 = f % 3 ;
                                    a1 = (a1) ? a1-1 : 2 ;
                                    etkx = etcaxt + (a1*420) + (a1*etxk) ;
                                    
                                    a1 = i / 7 ;
                                    b1 = i % 7 ;

                                    b1 = (b1) ? a1 : a1-1 ;
                                    etky = etky + (b1*25) ;
                                    
                                    b1 = i % 7 ;
                                    
                                    b1 = (!b1) ? 6 : b1-1 ;
                                    etkx = etkx + (b1*60) ;
                                    
                                    _bareacls (etkx+51,etky+16,etkx+58,etky+23,epbkxr); 

                                    }
                                }
                            }
                            refresh ();
                            etshowhide = 1 ;
                        } 
                        
                        
                        // Τσεκάρισμα ημερών όπου υπάρχει καταχώρηση ημερολογίου
                        if (qyear>1999 && Diary_q )
                        {
                            etshowhide = 1 ;
                            for (f=1 ; f<13 ; f++) {
                                for (i=1 ; i<=etmo[f] ; i++){
                                    if (etDIaryn[f][i]) {
                                    
                                    a1 = f / 3 ;
                                    b1 = f % 3 ;
                                    
                                    a1 = (b1) ? a1 : a1-1 ;
                                    etky = etcayt + (a1 * 150) + (a1*etyk) + 25 ;
                                    
                                    a1 = f % 3 ;
                                    a1 = (a1) ? a1-1 : 2 ;
                                    etkx = etcaxt + (a1*420) + (a1*etxk) ;
                                    
                                    a1 = i / 7 ;
                                    b1 = i % 7 ;

                                    b1 = (b1) ? a1 : a1-1 ;
                                    etky = etky + (b1*25) ;
                                    
                                    b1 = i % 7 ;
                                    
                                    b1 = (!b1) ? 6 : b1-1 ;
                                    etkx = etkx + (b1*60) ;
                                    
                                    _areacls (etkx+51,etky+3,etkx+58,etky+10,162,57,0); 

                                    }
                                }
                            }
                            refresh ();
                        
                        }
                        
                        
                        
                        //else { etshowhide = 0 ; }
                                
                                // Pinakida ΣΩΣΕ ΦΩΤΟ
                                
                                etfotx = etcaxt ; etfoty = etcayb+13 ;
                                etfotx1 = etfotx + 420 ; etfoty1 = etfoty+20;
                                
                                setcolor(1) ;
                                rectangle (etfotx , etfoty , etfotx1 , etfoty1) ;
                                _bareacls(etfotx+1 , etfoty+1 , etfotx1-1 , etfoty1-1 , etbkxr);
                                _outmystr_center_col(2, sosefoto,etfotx+2 , etfoty+2 , etfotx1-1 , etfoty1-1 ,etchxr,etbkxr);
                                
                                // Πινακίδα Εναλλαγή Επέτοιοι να φαίνονται ή όχι.
                                etmemox = etfotx ; etmemoy=etfoty+22;
                                etmemox1 = etmemox+420 ; etmemoy1 = etmemoy+20 ;
                                setcolor(1) ;
                                rectangle (etmemox , etmemoy , etmemox1 , etmemoy1);
                                
                                if (qyear>1999 && ar_per_1) {
                                _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , etbkxr);
                                _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,etchxr,etbkxr);
                                }
                                else {
                                    _bareacls (etmemox+1 , etmemoy+1 , etmemox1-1 , etmemoy1-1 , genbkxr);
                                    _outmystr_center_col(2, enallagh,etmemox+2 , etmemoy+2 , etmemox1-1 , etmemoy1-1 ,black,genbkxr);
                                }
                                // Πινακίδα Επιλεγμένη Ημερομηνία - Σταθερή , δεν ασχολούμαστε πλέον...
                                
                                etdatex = etcaxb - 250; etdatey = etcayb+13 ;
                                etdatex1 = etdatex + 250 ; etdatey1 = etdatey + 20 ;
                                setcolor(1);
                                rectangle (etdatex,etdatey,etdatex1,etdatey1);
                                _bareacls(etdatex+1 , etdatey+1 , etdatex1-1 , etdatey1-1 , genbkxr);
                                _outmystr_center_col(2, etepilegmen, etdatex+2 , etdatey+2 , etdatex1-1 , etdatey1-1 ,black,genbkxr);
                                
                                // Άδεια πινακίδα
                                etdatey += 22 ; etdatey1 += 22 ;
                                setcolor(1);
                                rectangle (etdatex,etdatey,etdatex1,etdatey1);
                                _bareacls(etdatex+1 , etdatey+1 , etdatex1-1 , etdatey1-1 , etyelxr);
                                
                                // Πινακίδα Μετάβαση στην...
                                etgox = etdatex - 170 ; etgoy = etfoty ;
                                etgox1 = etdatex - 2 ; etgoy1 = etgoy+20;
                                setcolor(1);
                                rectangle (etgox , etgoy , etgox1, etgoy1);
                                _bareacls(etgox+1 , etgoy+1 , etgox1-1, etgoy1-1 , genbkxr);
                                _outmystr_center_col(2, metabst, etgox+2 , etgoy+2 , etgox1-1, etgoy1-1 ,black,genbkxr);
                                
                                
                                // Πινακίδα Ακύρωση Επιλεγμένης Ημερομηνίας
                                
                                etakx = etgox ; etaky = etgoy + 22 ;
                                etakx1 = etgox1 ; etaky1 = etaky + 20;
                                setcolor(1);
                                rectangle (etakx , etaky , etakx1, etaky1);
                                _bareacls(etakx+1 , etaky+1 , etakx1-1, etaky1-1 , genbkxr);
                                _outmystr_center_col(2, akirepil, etakx+2 , etaky+2 , etakx1-1, etaky1-1 ,black, genbkxr);
                                
                                // Στοιχεία Φωτός - Συν/νες
                                
                                etfosx = etcaxt + 440 ; etfosy = etgoy ;
                                
                                /*
                                setcolor(1);
                                rectangle (etfosx , etfosy , etskotx1, etsely+19);
                                etfosx++ ; etfosy ++; etskotx1-- ; 
                                _bareacls(etfosx , etfosy , etskotx1, etsely+18 , olobkxr);
                                etsely++ ;
                                */
                                sprintf (file_1,"%sICD/sunrise_6735.ico",path_name);
                                My_readimagefile (file_1,etfosx,etfosy+8);
                                
                                etfosx+=60 ; etfosx1 = etfosx + 40; etfosy1 = etfosy+17;
                                etskotx = etfosx1 ; 
                                
                                
                                sprintf (file_1,"%sICD/sunset_6735.ico",path_name);
                                My_readimagefile (file_1,etskotx-5,etfosy+8);
                                
                                etskotx += 65 ;
                                etskotx1= etskotx+40; 
                                etskoty = etfosy1 + 12 ; etskoty1 = etskoty+17;
                                
                                etlunarx = etskotx1+75 ; etlunary = etfosy+8 ;
                                
                                etselx = etlunarx + 45 ; etsely = etfosy ;
                                etselrisey = etsely + 16 ; etselsety = etselrisey + 16 ;
                                etsely1 = etselsety + 15; etselx1 = etakx-3 ;
                                // Πινακίδα Κρύψε Παράθυρο
                                
                                etminx = etcaxb -136 ; etminy = 7 ;
                                etminx1 = etminx+136 ; etminy1 = etminy+18 ;
                                setcolor(1);
                                rectangle (etminx , etminy , etminx1 , etminy1 ) ;
                                _bareacls (etminx+1 , etminy+1 , etminx1-1 , etminy1-1 , etbkxr);
                                _outmystr_center_col(2,hidepara,etminx+2,etminy+2,etminx1-1,etminy1-1,etchxr,etbkxr);
                                
                                
                                                     
                                refresh() ;
                                et.k = et1.k = 0;
                                etnote=etphoto=etoption=etsvou=etallag=etwinsv=etgoto=etakir=etdiarnote=0 ;
                                //do {
                                  //  SDL_PollEvent(&sdlev);
                                    //} while (sdlev.type == SDL_WINDOWEVENT) ;
                                //SDL_FlushEvent(SDL_WINDOWEVENT);

                                continue ;
                            }
                            
                            case 16 : // Περιοδικές Υπομνήσεις
                                
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue ; }
                                if (!ar_clue) { 
                                    f=pers_rec_inp (0, -1, uday, umonth, uyear );
                                    if (!f) continue ; else ar_clue++;
                                }
                                    
                                Header = "Γραμματοσειρά Προσωπικών Υπομνήσεων" ;
                                f = pers_rec_show(&pers_sorton , uday, umonth, uyear );
                                Header = (char *) NULL ;
                                
                                if (f<0) {
                                    if ( (!ar_clue) && (DIAK1) ) {
                                        clue[0] = proclue[0] = 0 ;
                        
                                        for (md=1 ; md<=mo[umonth] ; md++) {
                                            if (! only[umonth][md]) { continue ; } 
                                            v1 = md / 7 ;
                                            v2 = md % 7 ;

                                            v = (v2) ? v1 : v1-1 ;
                                            dy = cayt + (v*25) + 25 ;
                                            
                                            v = (!v2) ? 6 : v2-1 ;
                                            dx = caxt + (v*60) ;
                                            
                                        
                                        if (uday != md) { setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2])); }
                                        else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                                        for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+14 ; f<=dy+21; f++) _putpixel (i,f);}
                                    }
                                        refresh();
                                    
                                }
                                    rech=1; 
                                    continue ;
                                    
                            }
                                gsee.dm[0] = rcr[f].enardate;
                                gsee.dm[1] = rcr[f].enarmonth;
                                eprosyear = rcr[f].enaryear;
                                eprosmonth = gsee.dm[1] ;
                                eprosday = gsee.dm[0] ;
                                rech=1;
                                break;
                                
                            case 17 : // Προσθήκη Περιοδικών Υπομνήσεων
                                
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue ; }
                                if (ar_clue==250) {information (0,"Συμπληρώθηκε ο μέγιστος αριθμός!",0); continue ; }
                                if (ar_clue<250) f = pers_rec_inp (ar_clue, -1 , uday, umonth, uyear);
                                if (f) { ar_clue++; rech=1; }
                                continue ;
                                break ;
                                
                            case 18 : // Καταχώρηση Ημερολογίου
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue ; }
                                if ( !Diary ) continue ;
                                
                                if (!Diary_u) {
                                    auto int st ;
                                    sprintf(str1kb,"%s%d",Diary_path,(int) uyear);
                                    st = mkdir(str1kb, 0777);
                                    if (st==-1) {
                                    printf ("Δεν είναι δυνατή η δημιουργία του φακέλλου <%d> μέσα στο %s%s !\n" , (int) uyear, user_path,".EORT_SETTINGS/DIARY/");
                                    } else { 
                                        Diary_u = 1 ;
                                        year_notes = 0 ;
                                        sprintf (diary_filename,"%04d_%02d_%02d", (int) uyear , (int) umonth , (int) uday);
                                    }
                                }
                                
                                if (!Diary_u) continue ;
                                
                                sprintf(str1kb,"%s%d/%s.dry",Diary_path,(int) uyear, diary_filename);
                                
                                if (there_is_note) { // Υπάρχει αρχείο στο δίσκο !
                                    if (strcmp (diary_filename , pre_diary_filename)) {
                                        note_werp = 0 ;
                                        strcpy (pre_diary_filename , diary_filename);
                                    }
                                    
                                    fp=fopen(str1kb,"rb");
                                        if (fp!=NULL) {
                                            i=0;
                                            fread (&what,1,1,fp);
                                            do {
                                                if (what<164 || what==200) {diary_notes[i++]=what ;}
                                                fread(&what,1,1,fp);
                                            }while (what!=255 && i<60000);
                                            diary_notes[i]=255;
                                            fclose(fp);
                                        }
                                        else {
                                            diary_notes[0] = 255 ;
                                            information (0,"Δεν άνοιξε η αρχική καταχώρηση-αρχείο!","Προτείνεται ο έλεγχος του δίσκου..");
                                            there_is_note = 0;
                                            DIaryn[umonth][uday] = 0 ;
                                            if (year_notes) year_notes--;
                                            bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                                        }
                                }
                                else { // Δεν υπάρχει αρχείο στο δίσκο
                                    strcpy (pre_diary_filename , diary_filename);
                                    note_werp = 0 ;
                                    diary_notes[0] = 255 ;
                                }
                                
                                what = 0;
                                
                                trampa=gouv ;
                                bkxr[0]=bkxr[1]=bkxr[2]=255 ; 
                                chxr[0]=chxr[1]=chxr[2]=0;
                                slxr[0]=255;slxr[1]=255;slxr[2]=97;
                                
                                strcpy (submenu[0],"Κλήση ΔΙΑΔΙΚΤΥΑΚΟΥ συνδέσμου με Firefox");
                                strcpy (submenu[1],"Κλήση ΔΙΑΔΙΚΤΥΑΚΟΥ συνδέσμου με Google-Chrome");
                                gouv=myfont[notes_font];
                                if ( (!ixx) && (!iyy) &&  (!ixx1)  && (!iyy1) ) {
                                    if (inpbox) {
                                        ixx=info.left+150; ; iyy=info.top+100 ;  ixx1=info.right-150 ; iyy1=info.bottom-100 ;
                                        }
                                        else {
                                            ixx=info.left+100; ; iyy=info.top+50 ;  ixx1=info.right-100 ; iyy1=info.bottom-50 ;
                                        }
                                    }
                                else {
                                    if (ixx1>info.right-1) ixx1 = info.right-1 ;
                                    if (iyy1>info.bottom-1) iyy1 = info.bottom-1 ;
                                }
                                sprintf (diary_entry,"Καταχώρηση Ημερολογίου της %02d/%02d/%04d", uday, umonth , uyear);
                                metr=diary_input(diary_notes, &ixx, &iyy, &ixx1, &iyy1, 60000, -1,note_werp,diary_entry);
                                while (metr<0) metr=diary_input(diary_notes, &ixx, &iyy, &ixx1, &iyy1, 60000 , -1,0,diary_entry);
                                note_werp = (unsigned short int) metr;                                   
                                
                                for (f=0;f<3;f++) {
                                    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
                                }
                                strcpy (submenu[0],"ΑΝΤΙΓΡΑΦΗ στοιχείων ημέρας στον Clipboard");
                                strcpy (submenu[1],"Αναζήτηση ονόματος (ελεύθερη)");
                                gouv=trampa; 
                                
                                sprintf(str1kb,"%s%d/%s.dry",Diary_path,(int) uyear, diary_filename);
                                
                                if (there_is_note) {
                                    if (diary_notes[0]==255) {
                                        
                                        remove(str1kb);
                                        there_is_note=0;
                                        DIaryn[umonth][uday] = 0 ;
                                        if (year_notes) year_notes--;
                                        pre_diary_filename[0]=255;
                                        bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                                        what = 1;
                                    }
                                    else {
                                        
                                        fp=fopen(str1kb,"r+b");
                                    }
                                }
                                else {
                                    if (diary_notes[0]==255) { pre_diary_filename[0]=255; continue ; }
                                    else { 
                                        there_is_note=1; 
                                        DIaryn[umonth][uday] = 1 ;
                                        year_notes++;
                                        _realputicon(stikx,stiky,mem_stik); refresh();
                                        fp=fopen(str1kb,"wb");
                                    }
                                }
                                
                                if (!what) {
                                    
                                    if (fp!=NULL) {
                                        fide_fp = fileno (fp) ;
                                        i=0;
                                        while (diary_notes[i]!=255 && i<60000) i++;
                                        diary_notes[i]=255;
                                        if (i) {fwrite (diary_notes,1,i+1,fp);}
                                        else {diary_notes[1]=255; fwrite (diary_notes,2,1,fp); }
                                        fdatasync (fide_fp);
                                        fsync(fide_fp);
                                        fclose(fp);
                                        fp=NULL;
                                    }
                                    else {
                                        information (6-keyb_gr,Diary_path,"Προτείνεται ο έλεγχος του δίσκου !!");
                                        there_is_note=0; 
                                        if (year_notes) year_notes--;
                                        DIaryn[umonth][uday] = 0 ;
                                        pre_diary_filename[0]=255;
                                        bareacls(stikx,stiky,stikx+34,stiky+22,ejobkxr);
                                    }
                                }
                                
                                if (DIAK2) {
                                    md = uday ;
                
                                    v1 = md / 7 ;
                                    v2 = md % 7 ;

                                    v = (v2) ? v1 : v1-1 ;
                                    dy = cayt + (v*25) + 25 ;
                                    
                                    v = (!v2) ? 6 : v2-1 ;
                                    dx = caxt + (v*60) ;
                                    
                                    if (DIaryn[umonth][md]) { setcolor (COLOR(162,57,0)); } 
                                    else { setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2])); }    
                                    for (i=dx+51 ; i<=dx+56; i++) {for (f=dy+3 ; f<=dy+10; f++) _putpixel (i,f);}
                                refresh();
                                }
                                    
                                continue ;
                            
                            case 19 :
                            {
                                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                                SDL_SetCursor(cursor);
                                ektos=1;
                                // Αναζήτηση Καταχώρησης Ημερολογίου έτους τάδε
                                if (uyear<2000) {information (0,"Καθορίστε έτος από το 2000 και μετά !",0); continue ; }
                                if ( (!Diary) || (!year_notes) ) continue ;
                                onomax[0]==255 ;
                                dx=input_dbsearch_text(onomax , -6);
                                if (dx!=1 || onomax[0]==255) continue ;
                                if (onomax[1]==255) { onomax[0]=255; continue;}
                                mystrcpy(nelement , onomax) ;
                                atona(onomax);
                                short int ans ;
                                int er , max , counter ;
                                
                                max = year_notes ;
                                counter = 0 ;
                                sprintf (str1024,"Αναζήτηση σε %d καταχωρήσεις",max);
                                er = proodos(  str1024, 0, max ,0) ;
                                v=0;
                                for (f=1 ; f<13 ; f++) {
                                    for (md=1 ; md<=mo[f] ;md++) {
                                        vrika_note[f][md]=0 ;
                                        if (!DIaryn[f][md]) continue ;
                                        if ( (er) && (max>counter) ) { proodos (  0, counter , max ,0) ;}
                                        sprintf(str1kb,"%s%d/%04d_%02d_%02d.dry",Diary_path,(int) uyear, (int) uyear , f , md);
                                        
                                        fp=fopen(str1kb,"rb");
                                        if (fp!=NULL) {
                                            i=0;
                                            fread (&what,1,1,fp);
                                            do {
                                                if (what<164 || what==200) {temp_notes[i++]=what ;}
                                                fread(&what,1,1,fp);
                                            }while (what!=255 && i<60000);
                                            temp_notes[i]=255;
                                            fclose(fp);
                                            atona (temp_notes);
                                            dx = mystrstr (temp_notes , onomax) ;
                                            if (dx) { vrika_note[f][md] = 1 ; v++ ; }
                                        }
                                        else {
                                            proodos(  0, counter , max ,1) ;
                                            er=0 ;
                                            temp_notes[0] = 255 ;
                                            information (0,"Πρόβλημα σε αρχείο!","Προτείνεται ο έλεγχος του δίσκου..");
                                        }
                                        counter++ ;
                                    }
                                }
                                if (er) { proodos(  0, counter , max ,1) ; }
                                if (!v) { information (0,"Δεν βρέθηκε τέτοια εγγραφή!",0); continue ; }
                                ans = find_note(nelement,uyear,mo) ;
                                if (!ans) continue ;
                                gsee.tog = ans ;
                                eprosyear = uyear ;
                                eprosmonth = (unsigned short int) gsee.dm[1];
                                eprosday = (unsigned short int) gsee.dm[0];
                                rech = 0;
                                break ;
                                // Πιθανότατα να χρειαστεί break αν απαιτηθεί μετάβαση σε ημερομηνία
                                //continue ;
                            }
                                
                            case 20 :   // ΕΧΙΤ
                                fyge=1;
                                continue ;
                        }
                        
                        if (!eprosyear) continue;
                        
                        if (eprosmonth==umonth && eprosday==uday && eprosyear==uyear && (!rech) ) continue ;

                        uday=eprosday;

                        greg=1;

                            if (eprosyear%4) b=28;
                            else {
                                if (eprosyear%100) b=29;
                                else {b=(eprosyear%400) ? 28 : 29 ;}
                                }


                        if (eprosmonth==2) {
                            if (eprosday>b) {uday=b ;}
                        }
                        else if (eprosday>mo[eprosmonth]) uday=mo[eprosmonth] ;

                        mo[2]=b;

                        if (uday!=eprosday) {
                            eprosday=uday;
                            sprintf (str1024,"%02u",uday);
                            sprintf (day_t,"%u",uday);
                            normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                            _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                            refresh();
                        }

                                                                        
                        if (eprosyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            uyear=eprosyear;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                        }

                        if (umonth!=eprosmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);

                            umonth=eprosmonth;

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(neohell_22n,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }

                        startmonth=find_dayname(uyear , umonth , 1);


                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}

                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);

                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}

                        strcpy (mera[0],mera[unameday]);

                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, genbkxr);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(calligra_24n,str1024,recfullxt+1 , recfullyt+2 , recfullxb-1 , recfullyb, black , genbkxr);
                        refresh ();

                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;

                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                        continue ;
                    }
                    
                   
                    continue;
                
            break ; // Πέρας mousebuttondown
            
        case SDL_QUIT :
            
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
             fyge=1;
             continue ;
            
     
        case SDL_KEYDOWN:

            if (pran == sdlwin2) {
                    
                    continue ;
                }
        ch_scan=sdlev.key.keysym.scancode;
        //do { SDL_PollEvent(&sdlev) ; } while ( (SDL_PollEvent(&sdlev)) && (sdlev.type == SDL_KEYDOWN) ) ;
	SDL_FlushEvent(SDL_KEYDOWN);
        a=0;
        d=0;
        switch (ch_scan) {
            
            case SDL_SCANCODE_LEFT :
                if (uday==1) continue ;
                a=1;
                break;

            case SDL_SCANCODE_RIGHT :
                
                if (uday==mo[umonth]) continue ;
                a=2;
                break;

            case SDL_SCANCODE_UP :
                
                dx=uday-7;
                if(dx<1) continue ;
                a=3;
                break ;
               
            case SDL_SCANCODE_DOWN :

                if ((uday+7) > mo[umonth]) continue ;
                a=4;
                break ;
                
            case SDL_SCANCODE_HOME :
                
                a=5;
                break ;

            //case SDL_SCANCODE_ESCAPE :
              //  fyge=1;
                //continue ;
        }
        
        
        if (!a) continue ;
        d=a;
        
                
        if (panel) {
            panel=0;
            setrgbcolor(dbaspro);
            rectangle (caxt,cayt,caxb,cayb);
            if (specmonth) {c=(probox<5) ? 0 : 4 ;}
            else c=0;
            if (probox!=-1) {
                a=(probox/7)+1 ; b=probox%7 ;
                if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                if (probox!=uday+c) {
                    setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                    rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                    rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                }
                else {
                    setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                    rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                    rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                }
                box=probox=-1;
            }
            refresh();
        }
        else if (promonbox!=-1) {
                setrgbcolor(dbaspro);
                rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                refresh();
                promonbox=monbox=-1;
            }
            else if (inpyear) {
                inpyear=0;
                setrgbcolor(dbaspro);
                rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                refresh();
            }
            else if (inpmonth) {
                inpmonth=0;
                setrgbcolor(dbaspro);
                rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                refresh();
            }
            else if (inpday) {
                inpday=0;
                setrgbcolor(dbaspro);
                rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                refresh();
            }
            else if (adddays) {
                adddays=0;
                setrgbcolor(dbaspro);
                rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                refresh();
            }
            //else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
            else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
            else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
            else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
            else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
            else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
            else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
            else if (pronow) {
                    pronow=0; 
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                    refresh(); 
                }
            else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (sbou) {
                    sbou=0;
                     inpx-=3 ; inpx1+=3; inpy1+=3;
                    setcolor(2);
                    line (inpx+1,yt+11,movext-1,yt+11);
                    line (inpx+1,yt+11,inpx+1,inpy1-1);
                    line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
                    line (inpx1-1,inpy1-1,inpx1-1,yt+11);
                    line (inpx1-1,yt+11,inpx1-358,yt+11);
                    setcolor(5);
                    line (inpx+2,yt+12,movext-1,yt+12);
                    line (inpx+2,yt+12,inpx+2,inpy1-2);
                    line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
                    line (inpx1-2,inpy1-2,inpx1-2,yt+12);
                    line (inpx1-2,yt+12,inpx1-358,yt+12);
                    refresh();
                    inpx+=3 ; inpx1-=3; inpy1-=3;
                }
            
            if (!ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
            ektos=1;
            }
            
            a=d;
            switch (a) {

                case 1 :
                                
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c-1;
                        if (probox>4 && probox<19) probox=4;
                        
                    }
                    else probox=uday-1;
                    
                    goto LIKE_PROBOX ;

                case 2 :
                    
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c+1;
                        if (probox>4 && probox<19) probox=19;
                        
                    }
                    else probox=uday+1;
                    
                    goto LIKE_PROBOX ;

                case 3 :
                            
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c-7;
                        if (probox>4 && probox<19) probox=4;
                        
                    }
                    else probox=uday-7;
                    
                    goto LIKE_PROBOX ;

                case 4: 

                    if ((uday+7) > mo[umonth]) continue ;
                    if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                    else c=0;
                
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c+7;
                        if (probox>4 && probox<19) probox=19;
                    }
                    else probox=uday+7;
                    
                    goto LIKE_PROBOX ;
                    
                case 5 :
                            
                    goto SHMERIS ;   
            }
            
        
        } // Πέρας switch sdlev.type
        
    } while (!fyge);


FYGE:
	SDL_FlushEvent(SDL_KEYDOWN);
    //do {
      //  SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    // if(mem0) {putimage(xt,yt,mem0,0); refresh();free(mem0);}
    //if(mem_arrs) free(mem_arrs);
    if(mem_ri) free(mem_ri);
    if(mem_le) free(mem_le);
    if(mem_ok) free(mem_ok);
    if(mem_akyro) free(mem_akyro);
    if(mem_flgr) free(mem_flgr); 
    if (memfld) free(memfld);
    if (mem_eye) free(mem_eye) ;
    if (mem_etk) free(mem_etk) ;
    if (mem_stik) free(mem_stik) ;
    if (mem_diakoff) free(mem_diakoff);
    if (mem_diak1on) free(mem_diak1on);
    if (mem_diak2on) free(mem_diak2on);
    if (mem_et800) free(mem_et800);
    if (mem_memo!=NULL) free (mem_memo);
    for (f=0;f<28;f++) {if (mem_lun[f]) free (mem_lun[f]);}
    gouv=trampa;
    for (f=0;f<3;f++) {
        bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
    }
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
    return ;
}

int fastmenu_show(short int plbut, char menu[][120], char *but_name, unsigned short int moux, unsigned short int mouy )
// Βλέπε array submenu...

{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0;
int *mem_int ;
int bkxrepi[3] , chxrepi[3] , bkxrsel[3], chxrsel[3] , bkxrkef[3] , chxrkef[3] , bkxrm[3] , chxrm[3] ;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k  ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int pano, kato , telos ,sort , protyx ;
unsigned short int tyx ,fyge , yicob ,el ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , el_pl, c ;
unsigned char what ;
unsigned int size;
unsigned short int orio;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned short int xt;
int yt1;
unsigned char ektos=1;
unsigned char but[plbut][120];

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[0];
orio=0;

for (f=0 ; f<plbut ; f++) {
    normtext_tomy(menu[f],but[f]);
    i=0;
    while (but[f][i]!=255) i++;
    if (orio<i) orio=i;
}

// Sorting Procedure !!

sort=0;

bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
chxrkef[0]=255 ; chxrkef[1]=0 ; chxrkef[2]=135 ; 

chxrm[0]=chxrm[1]=chxrm[2]=0;
bkxrm[0]=bkxrm[1]=bkxrm[2]=100;

chxrepi[0]=0; chxrepi[1]=0; chxrepi[2]=255;
bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;

chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;

i=orio*myfont_wid[0];
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,(plbut*20+38));
mem0=malloc(size); //250 x ... ( όσο βγει το ύψος...προσοχή λίγο όμως...)
if (!mem0) {information(2-keyb_gr,NULL,NULL);return -1;}
xt=moux ; yt1=mouy ;
while ( (yt1+(plbut*20+38)>info.bottom-1) && (yt1>info.top) ) yt1--;
yt=yt1+20;  yb=yt+(plbut*20+18);
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+19,bkxrkef); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
_areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
setcolor(3);
line (xt+1,yt1+20,xb-1,yt1+20);
setcolor(5);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*20;
yicob = yb-9;


//_outfanis_center_col(0, but_name , xtepl, yt1+2, xtepr);
_outmystr_center_col(notosans_14b, but_name , xtepl, yt1+2, xtepr, yt1+20, chxrkef , bkxrkef);
_bareacls (xtepl,ytepl,xtepr,ytepl+(plbut*20),bkxrm);
//_areacls(xtepl,ytepl+ybarb,xtepr,ybarb+1,30,30,30);

// TELOS EPIKEFALIDAS

// EMFANISH EIKONIDIVN


a=0;k=0; a1=plbut; telos=0 ; 

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
        //_outfanis_col(0, but[a] , xtepl+10 , ytepl+k*20 , xtepr);
        _outmystr_center_col(0, but[a] , xtepl+1, ytepl+k*20, xtepr-1, ytepl+k*20+20, chxrm , bkxrm);
        a++; a1--;k++;
    
}while (a1 && k<plbut);

refresh();
c=a;
kato=--a;
telos=a1;
 
fyge=0;
protyx=tyx=20; elem=el_pl=-1 ;
bima= 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 15 (το πολύ) επιλογών !!
        ektos=0;
        el_pl=-1;
       
     tyx=(my-ytepl)/20;
    
            
        if (tyx>plbut-1) {
            
            if (protyx!=20) {
                _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                el = (sort) ? pano-protyx : pano+protyx;
                //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                refresh();
                protyx=20;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>plbut-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==20) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 15 EPILOGVN
    
    if (protyx!=20) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        el = (sort) ? pano-protyx : pano+protyx;
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);  
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        refresh();
        protyx=20;
                }
                                 
       

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:

       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            {kati=-2; fyge=1; continue;}
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
        if ( mx1<xt || mx1>xb || my1<yt1 || my1>yb ) {kati=-2; fyge=1; continue;}
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( protyx!=20 ) { // Επιλογή κάποιου από τα 15 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel);
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel , bkxrsel);
        refresh(); 
        goto DIPLO_KLIK ;
        //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                    
                if (tyx>=plbut-1 || tyx==20 || protyx==20 ) tyx=0; else tyx=tyx+1;
       
                    
                if (protyx==20) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl= (sort) ? pano-tyx : pano+tyx;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_UP :
                    
                if ( !tyx || tyx==20 || protyx==20) tyx=plbut-1; else tyx-=1;
                        
                if (protyx==20) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                     //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr); 
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :              
                if (elem!=-1) {
                fyge=1;
                kati = elem ;
                }
                else if (el_pl!=1) {
                    kati=el_pl;
                    fyge=1;
                }
               continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
if(mem0) { putimage(xt,yt1,mem0,0); free(mem0) ; } //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
refresh();
gouv=whouv;
return kati ;
}

int eortes_show(char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_fonter=0;
int *mem_int ;
short int *shoitem;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int orio, plbut, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , xtepl2, xtepr2, ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
//Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;

plbut=ar_seo+ar_keo;

unsigned char *but[plbut] ;
unsigned char gbut[plbut][70];
unsigned char krit[plbut];
unsigned char dadm[plbut][18];
short int dasi[plbut];

fnt=eortologio_font;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
key_1=sort_1=65000;
orio=77;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);


for (f=0 ; f<ar_seo ; f++) {
but[f]=seort[f];
mystrcpy(gbut[f],but[f]);
dasi[f]=ssee[f].tog;
sprintf(dadm[f],"%02d %s", ssee[f].dm[0], omonth[ssee[f].dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;
}

for(f=ar_seo; f<ar_seo+ar_keo; f++) {
but[f]=keort[f-ar_seo];
mystrcpy(gbut[f],but[f]);
dasi[f]=ksee[f-ar_seo].tog;
sprintf(dadm[f],"%02d %s", ksee[f-ar_seo].dm[0], omonth[ksee[f-ar_seo].dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;
}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;

if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 

i=orio*2*myfont_wid[fnt]/3;
f=info.right-info.left;
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 

if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-16) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
xtepr2=xb-9; xtepl2=xtepr+3;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 45 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);
refresh();

chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;

_bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
             _outfanis_col(fnt, dadm[ar_dom[a]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
    if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr2 && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
         _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);  
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);   
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+34 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Εναλλαγή Ταξινόμησης", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Resorting", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        if (ektos) {
            ektos=0;
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor); 
        }
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        
        if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        ektos=0;
        }
        
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -3);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; // klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
             _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2 , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr2-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {

        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                    refresh();
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                setcolor(0);
                line (xtepr+1,ytepl,xtepr+1,ybarb);
                line (xtepr+2 , ytepl,xtepr+2,ybarb);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            /*
            if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
            else elem=-1;
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              } 
                              */
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }
            protyx=lines;
            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; } 
            ektos=1;
            if (user_ans<0) continue;
            gouv=myfont[user_ans];
            fnt = user_ans ;
            eortologio_font = fnt ; 
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*2*myfont_wid[fnt]/3;
            f=info.right-info.left;
            fhe=myfont_hei[fnt]+2;
            if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        if (krit[ar_dom[c]]) {
            setrgbcolor (dbyel) ; 
            line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }
        }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
    line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
    line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :

                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; 
                    line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
            line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
            line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
                else elem=-1;
                if (elem!=-1) {
    
                    kati=ar_dom[elem];

                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }

        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);   
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}



void atona (unsigned char *str)
{

register int i;
int b;

    i=0;
    while (str[i]!=255) i++;
    b=i; //strlen (str)

    for (i=0;i<b;i++) {
        if (keyb_gr) {
            switch (str[i]) {

                case 96:
                case 131:
                case 132:
                str[i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                str[i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                str[i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                str[i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                str[i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                str[i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                str[i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                str[i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                str[i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                str[i]=128;
                break;

                case 130:
                str[i]=119;
            }
        }
        if ( (str[i]>68) && (str[i]<95) ) str[i]-=26;
    }
}


int mystrstr (unsigned char *str, unsigned char *deigma)
{
register int f , i ;
unsigned char what ;
int w , by , rby , a ;

 // mystrstr(str,deigma) // Αν υπάρχει το deigma μέσα στο str !!

    i=0;
    while (deigma[i]!=255) i++;
    by=i; //strlen (deigma) (χωρίς το 255)

    i=0;
    do {
        what=str[i];
        f=0; w=by; rby=0;a=i;
        while( (what!=255) && (w) ) {
            if (what==deigma[f++]) {rby++; i++; w--; what=str[i];continue;}
            else break;}
            
            if (rby==by) { i=-1; break ;}
            else i=a+1;
            
    }while (what!=255);
    f = (i==-1) ? 1 : 0;
    return f;
}



int name_show(int plbut, char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_fonter=0;
int *mem_int ;
short int *shoitem;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int orio, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , xtepl2, xtepr2, ybarb,  xfrba, yfrba , xsort , ysort , xteple , xtepre;
unsigned short int key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
//Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;

unsigned char *but[plbut] ;
unsigned char gbut[plbut][20];
unsigned char krit[plbut];
unsigned char dadm[plbut][18];
short int dasi[plbut];
unsigned char gio[plbut][70];

fnt=eortologio_font;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
key_1=sort_1=65000;
orio=96;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0 ; f<plbut ; f++) {
    krit[f]=0;
    if (!vrika[f][0]) {
        i=vrika[f][1] ;
        but[f]=sonoma[i];
        mystrcpy(gbut[f],but[f]);
        key=santist[i];
        mystrcpy(gio[f],seort[key]);
        dasi[f]=ssee[key].tog;
        sprintf(dadm[f],"%02d %s", ssee[key].dm[0], omonth[ssee[key].dm[1]]);
        normtext_tomy(dadm[f],0);
    }
    else {
        i=vrika[f][1] ;
        but[f]=konoma[i];
        mystrcpy(gbut[f],but[f]);
        key=kantist[i];
        mystrcpy(gio[f],keort[key]);
        dasi[f]=ksee[key].tog;
        sprintf(dadm[f],"%02d %s", ksee[key].dm[0], omonth[ksee[key].dm[1]]);
        normtext_tomy(dadm[f],0);
    }
}
/*
for (f=0 ; f<ar_seo ; f++) {
but[f]=seort[f];
mystrcpy(gbut[f],but[f]);
dasi[f]=ssee[f].tog;
sprintf(dadm[f],"%02d %s", ssee[f].dm[0], omonth[ssee[f].dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;
}

for(f=ar_seo; f<ar_seo+ar_keo; f++) {
but[f]=keort[f-ar_seo];
mystrcpy(gbut[f],but[f]);
dasi[f]=ksee[f-ar_seo].tog;
sprintf(dadm[f],"%02d %s", ksee[f-ar_seo].dm[0], omonth[ksee[f-ar_seo].dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;
}
*/

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;

if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
i=orio*2*myfont_wid[fnt]/3;
f=info.right-info.left;
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-16) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
//printf ("xb = %d\n" , xb);
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)

// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);

xtepl=xt+9; 
xtepr = xtepl+ 3*14*myfont_wid[fnt]/4 ;
xteple=xtepr+3;
xtepr2=xb-9;
xtepl2=xtepr2 - 24*myfont_wid[fnt]/4;
xtepre=xtepl2-3;
 
ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 45 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);
//printf ("%s\n" , "areacls") ;
// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);
refresh();

chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;

_bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN


if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);


a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
             _outfanis_col(fnt, dadm[ar_dom[a]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
            _outfanis_col(fnt, gio[ar_dom[a]] , xteple+1 , ytepl+k*fhe , xtepre);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
line (xtepre+1,ytepl,xtepre+1,ytepl+k*fhe+1);
line (xtepre+2 , ytepl,xtepre+2,ytepl+k*fhe+1);
line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
        if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr2 && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
         _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
         _bareacls(xteple, ytepl+tyx*fhe,xtepre,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2, xrep, slxr);
        _outfanis_colxr(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+tyx*fhe , xtepre, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
        
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
        
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls(xteple, ytepl+tyx*fhe,xtepre,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);  
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        _outfanis_colxr(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+tyx*fhe , xtepre , xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);   
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+34 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Εναλλαγή Ταξινόμησης", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Resorting", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -2);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; // klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
             _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2 , xrkl, slkl);
             _outfanis_colxr(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr2-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
            refresh();
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {

        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                    _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
                    refresh();
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                setcolor(0);
                line (xtepr+1,ytepl,xtepr+1,ybarb);
                line (xtepr+2 , ytepl,xtepr+2,ybarb);
                line (xtepre+1,ytepl,xtepre+1,ybarb);
                line (xtepre+2 , ytepl,xtepre+2,ybarb);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
                refresh();
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            /*
            if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
            else elem=-1;
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              } 
                              */
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; 
            xtepr = xtepl+ 3*14*myfont_wid[fnt]/4 ;
            xteple=xtepr+3;
            xtepr2=xb-9;
            xtepl2=xtepr2 - 24*myfont_wid[fnt]/4;
            xtepre=xtepl2-3; 
            
            ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }
            protyx=lines;
            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            gouv=myfont[user_ans];
            fnt = user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*2*myfont_wid[fnt]/3;
            f=info.right-info.left;
            fhe=myfont_hei[fnt]+2;
            if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            
            xtepl=xt+9; 
            xtepr = xtepl+ 3*14*myfont_wid[fnt]/4 ;
            xteple=xtepr+3;
            xtepr2=xb-9;
            xtepl2=xtepr2 - 24*myfont_wid[fnt]/4;
            xtepre=xtepl2-3; 
            
            ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           

        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
            _outfanis_col(fnt, gio[ar_dom[c]] , xteple+1 , ytepl+k*fhe , xtepre);
        if (krit[ar_dom[c]]) {
            setrgbcolor (dbyel) ; 
            line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }
        }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
    line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
    line (xtepre+1,ytepl,xtepre+1,ytepl+k*fhe+1);
    line (xtepre+2 , ytepl,xtepre+2,ytepl+k*fhe+1);
    line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xteple, ytepl+protyx*fhe,xtepre,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, gio[ar_dom[el]] , xteple+1 , ytepl+protyx*fhe , xtepre);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :

                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
                    _outfanis_col(fnt, gio[ar_dom[c]] , xteple+1 , ytepl+k*fhe , xtepre);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; 
                    line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
            line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
            line (xtepre+1,ytepl,xtepre+1,ytepl+k*fhe+1);
            line (xtepre+2 , ytepl,xtepre+2,ytepl+k*fhe+1);
            line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
                else elem=-1;
                if (elem!=-1) {
    
                    kati=ar_dom[elem];

                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }

        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);   
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);
return kati ;
}


int pieseortes_show(int plbut, char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_fonter=0;
int *mem_int ;
short int *shoitem;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int orio, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , xtepl2, xtepr2, ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
//Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;

unsigned char *but[plbut] ;
unsigned char gbut[plbut][70];
unsigned char krit[plbut];
unsigned char dadm[plbut][18];
short int dasi[plbut];

fnt=eortologio_font ;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
key_1=sort_1=65000;
orio=77;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);


for (f=0 ; f<plbut ; f++) {
krit[f]=0;
    if (!vrika[f][0]) {
        i=vrika[f][1];
        but[f]=seort[i];
        mystrcpy(gbut[f],but[f]);
        dasi[f]=ssee[i].tog;
        sprintf(dadm[f],"%02d %s", ssee[i].dm[0], omonth[ssee[i].dm[1]]);
        normtext_tomy(dadm[f],0);
    }
    else {
        i=vrika[f][1];
        but[f]=keort[i];
        mystrcpy(gbut[f],but[f]);
        dasi[f]=ksee[i].tog;
        sprintf(dadm[f],"%02d %s", ksee[i].dm[0], omonth[ksee[i].dm[1]]);
        normtext_tomy(dadm[f],0);
    }
}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;

if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
i=orio*2*myfont_wid[fnt]/3;
f=info.right-info.left;
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-16) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
xtepr2=xb-9; xtepl2=xtepr+3;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 45 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);
refresh();

chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;

_bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
             _outfanis_col(fnt, dadm[ar_dom[a]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
        if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr2 && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
         _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);  
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);   
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+34 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Εναλλαγή Ταξινόμησης", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Resorting", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -3);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; // klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
             _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2 , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr2-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {

        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                    refresh();
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                setcolor(0);
                line (xtepr+1,ytepl,xtepr+1,ybarb);
                line (xtepr+2 , ytepl,xtepr+2,ybarb);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            /*
            if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
            else elem=-1;
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              } 
                              */
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }
            protyx=lines;
            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            gouv=myfont[user_ans];
            fnt = user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*2*myfont_wid[fnt]/3;
            f=info.right-info.left;
            fhe=myfont_hei[fnt]+2;
            if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        if (krit[ar_dom[c]]) {
            setrgbcolor (dbyel) ; 
            line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }
        }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
    line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
    line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :

                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; 
                    line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
            line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
            line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
                else elem=-1;
                if (elem!=-1) {
    
                    kati=ar_dom[elem];

                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }

        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);   
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}


int sbutton_show(void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_ghost =0 , *mem_fonter=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , c ;
unsigned char what ;
unsigned int size;
unsigned char *str , *ghost_str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
//Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;

fnt=ponom_font;
profrba=0;
kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
str=mem_str;
plbut=0;    
key_1=sort_1=65000;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;
unsigned char *gbut[plbut];
unsigned char krit[plbut];

mem_ghost=malloc(ar+1);
if (!mem_ghost)  {information (2-keyb_gr,0,0); goto FYGE; }
ghost_str=mem_ghost;
for (f=0; f<ar; f++) ghost_str[f]=str[f] ;

i=0; a=0; 

for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       gbut[i]=ghost_str+a;
       but[i]=mem_str+a;
       i++;
       a=f+1; 
        }
}

for (f=0;f<plbut;f++) {krit[f]=0;}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=1;
for (f=0;f<plbut;f++) ar_dom[f]=f;
/*
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
*/

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
i=orio*myfont_wid[fnt];
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-35) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 35 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr);
refresh();

// olobkxr[0]= 86 ; olobkxr[1]=77 ; olobkxr[2]=60 ;
// ejobkxr[0]=159 ; ejobkxr[1]= 155; ejobkxr[2]=116;
chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;

_bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
    if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) {continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    /*
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }*/
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);     
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    /*
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }*/
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    
    /*
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ή , εμφάνιση στοιχείων με την αρχική τους σειρά", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting or , show data by their initial order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    */
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -2);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; // klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            refresh();
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            if (keyb_gr) user_ans=alert(0,"Θέλετε να διαγραφεί η λίστα από τη μνήμη ;" ,"Η λίστα δεν διαγράφεται από το δίσκο !! \nΜπορείτε να τη φορτώσετε ξανά όποτε θέλετε."); else user_ans=alert(0,"Do you want the this list to be unloaded?" , "The list remains in the disk !! \n You can reload it any time you want.");
            if (user_ans != 1) continue;
            kati=ar_dom[elem];
            data[0]=255;
            fyge=1;
            // Διαγραφή κάποιου button - Μάλλον return με συγκεκριμένη τιμή
        }
        
        /*
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
*/
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    refresh();
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                refresh();
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            /*
            if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
            else elem=-1;
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              } 
                              */
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }
            protyx=lines;
            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt,Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            ponom_font = user_ans ;
            gouv=myfont[user_ans];
            fnt = user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*myfont_wid[fnt];
            fhe=myfont_hei[fnt]+2;
            if (i <320) width =320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            // bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
        if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :

                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
                else elem=-1;
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                    data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }

        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
  
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if(mem_ghost) free(mem_ghost );
if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return kati ;
}


int pagkosm_show(char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_fonter=0;
int *mem_int ;
short int *shoitem;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int orio, plbut, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , xtepl2, xtepr2, ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
//Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;

plbut=ar_pagk_1;

unsigned char *but[plbut] ;
unsigned char gbut[plbut][122];
unsigned char krit[plbut];
unsigned char dadm[plbut][18];
short int dasi[plbut];

fnt=pagkosm_font;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
key_1=sort_1=65000;
orio=110;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);


for (f=0 ; f<ar_pagk_1 ; f++) {
but[f]=pagk[f];
mystrcpy_lim(gbut[f],but[f],120);
gsee.tog=pagk_dm[f];
dasi[f]=gsee.tog;
sprintf(dadm[f],"%02d %s", gsee.dm[0], omonth[gsee.dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;
}


// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;

if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
i=orio*2*myfont_wid[fnt]/3;
f=info.right-info.left;
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-16) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
xtepr2=xb-9; xtepl2=xtepr+3;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 45 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);
refresh();

chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;

_bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
             _outfanis_col(fnt, dadm[ar_dom[a]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
        if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr2 && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
         _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);  
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);   
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+34 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Εναλλαγή Ταξινόμησης", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Resorting", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -4);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; // klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
             _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2 , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr2-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {

        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                    refresh();
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                setcolor(0);
                line (xtepr+1,ytepl,xtepr+1,ybarb);
                line (xtepr+2 , ytepl,xtepr+2,ybarb);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            /*
            if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
            else elem=-1;
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              } 
                              */
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }
            protyx=lines;
            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            gouv=myfont[user_ans];
            fnt = user_ans ; pagkosm_font = user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*2*myfont_wid[fnt]/3;
            f=info.right-info.left;
            fhe=myfont_hei[fnt]+2;
            if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        if (krit[ar_dom[c]]) {
            setrgbcolor (dbyel) ; 
            line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }
        }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
    line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
    line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :

                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; 
                    line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
            line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
            line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
                else elem=-1;
                if (elem!=-1) {
    
                    kati=ar_dom[elem];

                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }

        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

  SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
  
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return kati ;
}

/*
void _nice_box (int fnt, char *str,int inpx, int inpy, int inpx1, int inpy1, int dist, int *olobkxr, int * chxrepi, int *bkxrepi)

// str : PROSOXH κανονικό string να τελειώνει σε 0 ! Μέγιστο μήκος = 99 !!
// inpx, inpy .... : Συντεταγμένες μεγάλου παραλληλογράμου
// dist : Επιθυμητή απόσταση μικρού παραλληλογράμου από το μεγάλο

{
    
int a;
int cenxl;
int mo , smahei ;
unsigned char str1[100];

        
        
        a=0;
        while (str[a]!='\0') a++;
        smahei = 3 * myfont_wid[fnt]*a / 4;
        if (smahei>(inpx1-inpx)) return ;
        a=(inpx1-inpx-smahei)/2;
        if (a<dist) dist=a;
        
        cenxl=inpx+dist;
        cenxr=inpx1-dist;
        smahei=myfont_hei[fnt]+2;
        mo=smahei/2;
        
        _bareacls (inpx,inpy,inpx1,inpy1,olobkxr) ;
        setcolor(2);
        rectangle (cenxl,inpy,cenxr,inpy+smahei);
        _bareacls(cenxl+1,inpy+1,cenxr-1,inpy+smahei-1,bkxrepi);
        normtext_tomy (str,str1);
        _outmystr_center_col (fnt,str1,cenxl+2,inpy+2,cenxr-2,inpy+smahei,chxrepi, bkxrepi);

        setcolor(5);
        line (inpx,inpy+mo-1,cenxl-1,inpy+mo-1);
        line (inpx,inpy+mo-1,inpx,inpy1);
        line (inpx,inpy1,inpx1,inpy1);
        line (inpx1,inpy1,inpx1,inpy+mo-1);
        line (inpx1,inpy+mo-1,cenxr+1,inpy+mo-1);
        
        setcolor(2);
        line (inpx+1,inpy+mo,cenxl-1,inpy+mo);
        line (inpx+1,inpy+mo,inpx+1,inpy1-1);
        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
        line (inpx1-1,inpy1-1,inpx1-1,inpy+mo);
        line (inpx1-1,inpy+mo,cenxr+1,inpy+mo);
        
        setcolor(5);
        line (inpx+2,inpy+mo+1,cenxl-1,inpy+mo+1);
        line (inpx+2,inpy+mo+1,inpx+2,inpy1-2);
        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
        line (inpx1-2,inpy1-2,inpx1-2,inpy+mo+1);
        line (inpx1-2,inpy+mo+1,cenxr+1,inpy+mo+1);
        
}


int _nice_box_clear (int fnt, int charnumb, int inpx, int inpy, int inpx1, int inpy1, int dist, int *olobkxr, int *bkxrepi)

// charnumb : Πόσοι χαρακτήρες θα χωράνε στο μικρό παραλληλόγραμμο
// inpx, inpy .... : Συντεταγμένες μεγάλου παραλληλογράμου
// dist : Επιθυμητή απόσταση μικρού παραλληλογράμου από το μεγάλο (δεξιά-αριστερά)
// olobkxr : γέμισμα του μεγάλου κουτιού
// bkxrepi : γέμισμα του μικρού κουτιού
// Επιστρέφει το χ του κουτιού ενώ το y=inpy+1

{
    
int a;
int cenxl;
int mo , smahei ;


        

        smahei = 3 * myfont_wid[fnt]*charnumb / 4;
        if (smahei>(inpx1-inpx)) return -1;
        a=(inpx1-inpx-smahei)/2;
        if (a<dist) dist=a;
        
        cenxl=inpx+dist;
        cenxr=inpx1-dist;
        smahei=myfont_hei[fnt]+2;
        mo=smahei/2;
        
        _bareacls (inpx,inpy,inpx1,inpy1,olobkxr) ;
        setcolor(2);
        rectangle (cenxl,inpy,cenxr,inpy+smahei);
        _bareacls(cenxl+1,inpy+1,cenxr-1,inpy+smahei-1,bkxrepi);

        setcolor(5);
        line (inpx,inpy+mo-1,cenxl-1,inpy+mo-1);
        line (inpx,inpy+mo-1,inpx,inpy1);
        line (inpx,inpy1,inpx1,inpy1);
        line (inpx1,inpy1,inpx1,inpy+mo-1);
        line (inpx1,inpy+mo-1,cenxr+1,inpy+mo-1);
        
        setcolor(2);
        line (inpx+1,inpy+mo,cenxl-1,inpy+mo);
        line (inpx+1,inpy+mo,inpx+1,inpy1-1);
        line (inpx+1,inpy1-1,inpx1-1,inpy1-1);
        line (inpx1-1,inpy1-1,inpx1-1,inpy+mo);
        line (inpx1-1,inpy+mo,cenxr+1,inpy+mo);
        
        setcolor(5);
        line (inpx+2,inpy+mo+1,cenxl-1,inpy+mo+1);
        line (inpx+2,inpy+mo+1,inpx+2,inpy1-2);
        line (inpx+2,inpy1-2,inpx1-2,inpy1-2);
        line (inpx1-2,inpy1-2,inpx1-2,inpy+mo+1);
        line (inpx1-2,inpy+mo+1,cenxr+1,inpy+mo+1);
        
        return cenxl ;
}
*/


int mobeortes_show(short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_fonter=0;
int *mem_int ;
short int *shoitem;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int orio, plbut, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , xtepl2, xtepr2, ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
//Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;

plbut=44;

unsigned char *but[plbut] ;
unsigned char gbut[plbut][70];
unsigned char krit[plbut];
unsigned char dadm[plbut][18];
short int dasi[plbut];

unsigned char but_name [100] ;

fnt=mobeort_font;
for (f=0;f<3;f++) {
    bkxr1[f]=bkxr[f] ; chxr1[f]=chxr[f] ; slxr1[f]=slxr[f];
}

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
key_1=sort_1=65000;
orio=77;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for(f=0; f<ar_keo-1; f++) {
but[f]=keort[f];
mystrcpy(gbut[f],but[f]);
dasi[f]=k1see[f].tog;
sprintf(dadm[f],"%02d %s", k1see[f].dm[0], omonth[k1see[f].dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;
}

but[f]=mother ;
mystrcpy(gbut[f],but[f]);
dasi[f]=mo1_dm;
gsee.tog=mo1_dm;
sprintf(dadm[f],"%02d %s", gsee.dm[0], omonth[gsee.dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;

f++;
but[f]=father ;
mystrcpy(gbut[f],but[f]);
dasi[f]=fa1_dm;
gsee.tog=fa1_dm;
sprintf(dadm[f],"%02d %s", gsee.dm[0], omonth[gsee.dm[1]]);
normtext_tomy(dadm[f],0);
krit[f]=0;

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;

if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 
i=orio*2*myfont_wid[fnt]/3;
f=info.right-info.left;
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-16) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
xtepr2=xb-9; xtepl2=xtepr+3;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 45 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
strcpy (but_name , "ΚΙΝΗΤΕΣ ΕΟΡΤΕΣ");
normtext_tomy (but_name,0);
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);
refresh();

chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;

_bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
             _outfanis_col(fnt, dadm[ar_dom[a]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
    if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION); 
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr2 && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
         _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls(xtepl2, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);  
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);   
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+34 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Εναλλαγή Ταξινόμησης", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Resorting", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -3);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; // klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
             _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2 , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr2-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {

        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*2);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f];
    }

// SORTING DATES!!
    pro_sort_shoint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                    refresh();
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                setcolor(0);
                line (xtepr+1,ytepl,xtepr+1,ybarb);
                line (xtepr+2 , ytepl,xtepr+2,ybarb);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                refresh();
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            /*
            if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
            else elem=-1;
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              } 
                              */
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                
                free(mem_bar1);
            }
            protyx=lines;
            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr2,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1 ;
            if (user_ans<0) continue;
            
            gouv=myfont[user_ans];
            fnt = user_ans ; mobeort_font = fnt ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*2*myfont_wid[fnt]/3;
            f=info.right-info.left;
            fhe=myfont_hei[fnt]+2;
            if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-3-24*myfont_wid[fnt]/4; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            xtepr2=xb-9; xtepl2=xtepr+3;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 45 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr2,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr2);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr2,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        if (krit[ar_dom[c]]) {
            setrgbcolor (dbyel) ; 
            line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }
        }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
    line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
    line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls(xtepl2, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :

                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :

                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr2,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                    _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; 
                    line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr2-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line (xtepr+1,ytepl,xtepr+1,ytepl+k*fhe+1);
            line (xtepr+2 , ytepl,xtepr+2,ytepl+k*fhe+1);
            line(xtepl,ytepl+k*fhe+1,xtepr2,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (protyx!=lines) { elem= (sort) ? pano-protyx : pano+protyx; }
                else elem=-1;
                if (elem!=-1) {
    
                    kati=ar_dom[elem];

                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }

        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);  
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}


int butpers_show(short int *sorton , unsigned short int uday, unsigned short int umonth, unsigned short int uyear )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0 , *mem_go=0 ;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 , *mem_fonter=0;
int *mem_int ;
short int delon=1;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepl2, xtepr2, xtepl3, xtepr3 ,xtepr, ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int neaepxt , neaepyt , neaepxb , neaepyb , tropxt , tropyt , tropxb , tropyb ;
unsigned short int plbut , key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , proelem ,c , c1 ;
unsigned char what ;
unsigned int size;
unsigned char *str , *ghost_str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary , neaepcl, tropcl;
Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] , tropchxr[3], tropbkxr[3];
unsigned int *shoitem;
short int infmobxt, infmobyt, cancel=0 , goxt , goyt ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

union {
    unsigned int supdate;
    unsigned short int daye[2];
} dasi [730];

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;
short int orio ;
unsigned char epeteios [30] , tropop [30];
unsigned char but_name[94];
int chxrc[3] , bkxrc[3] , slxrc[3] ;

unsigned char *but[730] ;
unsigned char gbut[730][70];
unsigned char krit[730];
//short int dasi[730];
unsigned char dadm[730][30];
unsigned char nox[730][6];
char nktex[144];
int black[3] ; 

tropchxr[0] = 116 , tropchxr[1] = 255 , tropchxr[2] = 101 ;
tropbkxr[0] = 196 , tropbkxr[1] = 46, tropbkxr[2] = 0;
orio = 87;
strcpy (but_name , "Πίνακας Πάγιων/Ετήσιων Προσωπικών Υπομνήσεων");
normtext_tomy (but_name,0);
strcpy (epeteios , "Νέα Επέτειος");
normtext_tomy (epeteios,0);
strcpy (tropop , "Τροποποίηση");
normtext_tomy (tropop,0);
fnt=personal_font;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];

plbut=ar_per;    
key_1=sort_1=65000;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0;f<plbut;f++) {
    
    krit[f]=0;
    but[f]=pers[f].tex;
    mystrcpy(gbut[f],but[f]);
    gsee.tog=pers[f].when ;
    dasi[f].daye[0]=pers[f].when ;
    dasi[f].daye[1]=pers[f].year ;
    sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , pers[f].year);
    normtext_tomy(dadm[f],0);
    sprintf (nox[f] , "%03d" , f+1) ; 
    normtext_tomy (nox[f],0);
}

// Sorting Procedure !!
ardom_mem=malloc(730*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*4);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f].supdate;
    }

// SORTING DATES!!
    pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 

i=orio*2*myfont_wid[fnt]/3;
f=info.right-info.left;
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 

if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-16) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);

xtepr3=xb-9;
xtepl=xt+9; xtepr = xtepl+9*myfont_wid[fnt]/4;
xtepl2 = xtepr+3;
xtepl3=xtepr3-3*13*myfont_wid[fnt]/4;
xtepr2=xtepl3-3;

ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 35 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;
goxt = xok-80 ; goyt = ysort +14 ;

neaepxt = tropxt= xvice + 60 ; neaepyt = ybarb+8 ;
neaepxb = tropxb= neaepxt+100 ; neaepyb = neaepyt+18; 
tropyt=neaepyb+8; tropyb = tropyt+18;
infmobxt = neaepxb+35 ; infmobyt = neaepyt+13 ;

_areacls (xtepl,ytepl,xtepr3,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr3);
refresh();

/*
chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
slxr[0]=190; slxr[1]=228; slxr[2]=0;
*/

chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;
black[0] = black[1] = black[2] = 0 ;

_bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr3,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 


// Cancel : 94 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/go_5421.ico");
mem_go = icontomem (file_1,255);
if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    
//_bareacls (xtepl,ytepl,xtepr3,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

_realputicon(goxt,goyt,mem_go);

setcolor(1);
rectangle (neaepxt , neaepyt, neaepxb, neaepyb) ;
setcolor(2) ;
rectangle (neaepxt-1 , neaepyt-1, neaepxb+1, neaepyb+1) ;
_bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr);
_outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);

setcolor(1);
rectangle (tropxt , tropyt, tropxb, tropyb) ;
setcolor(2) ;
rectangle (tropxt-1 , tropyt-1, tropxb+1, tropyb+1) ;
_bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr);
_outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        _outfanis_col(fnt, nox[a] , xtepl+1 , ytepl+k*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[a]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[a]] , xtepl3+1 , ytepl+k*fhe , xtepr3);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line (xtepr+2,ytepl,xtepr+2,ytepl+k*fhe+1);
line (xtepr2+2,ytepl,xtepr2+2,ytepl+k*fhe+1);
line(xtepl,ytepl+k*fhe+1,xtepr3,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0; neaepcl=tropcl=0 ;
protyx=tyx=lines; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    //while (SDL_PollEvent(&sdlev)) continue ;
        if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) {continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
     
     
    if (mx>xtepl && mx<xtepr3 && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
     tyx=(my-ytepl)/fhe;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 12 χρώματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
          
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);
          if (mem_small) hide_help (hdhlpxt , hdhlpyt);
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
                //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);       
                refresh();
                protyx=lines;
                ektos=1;
                if (mem_small) hide_help (hdhlpxt , hdhlpyt);
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else {if (mem_small) hide_help (hdhlpxt , hdhlpyt); continue;}
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        i=ar_dom[el];
         //_bareacls(xtepl+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl2+1, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl3+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
         _outfanis_colxr(fnt, nox[el] , xtepl+1 , ytepl+tyx*fhe , xtepr , xrep, slxr);
        _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+tyx*fhe , xtepr3 , xrep, slxr);
        refresh ();
        //_outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr3, xrep, slxr);
        if (pers[i].mob) {
            mytext_tonorm (pers[i].ktex,nktex,140);
            show_help (nktex, infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);
        }
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        if (mem_small) hide_help (hdhlpxt , hdhlpyt);
        el = (sort) ? pano-protyx : pano+protyx;
        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
         
         
        el = (sort) ? pano-tyx : pano+tyx;
        i=ar_dom[el];
        //_bareacls(xtepl+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl2+1, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl3+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
        _outfanis_colxr(fnt, nox[el] , xtepl+1 , ytepl+tyx*fhe , xtepr , xrep, slxr);
        _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+tyx*fhe , xtepr3 , xrep, slxr);
        //_outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr3 , xrep, slxr);     
        refresh();
         if (pers[i].mob) {
             mytext_tonorm (pers[i].ktex,nktex,140);
            show_help (nktex, infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);
        }
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);       
        refresh();
        if (mem_small) hide_help (hdhlpxt , hdhlpyt);
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help(" Εναλλαγή Ταξινόμησης ", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help(" ReSorting ", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0;_bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    if (elem!=-1) show_help (" Μετάβαση..",xok-20 , yok-22, &hdhlpxt , &hdhlpyt);
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>neaepxt && mx<neaepxb && my>neaepyt && my<neaepyb) { // PONTIKI STO NEA EPILOGH
    
        ektos=0;
        if (probar) probar=0;
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (neaepcl) continue ;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        neaepcl=1;
        _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , tropbkxr);
        _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , tropchxr, tropbkxr);
        refresh();
        continue ;
    }
    
    if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    
    if (mx>tropxt && mx<tropxb && my>tropyt && my<tropyb) { // PONTIKI STHN TROPOPOIHSH
    
        ektos=0;
        if (probar) probar=0;
        else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
        
        if (tropcl) continue ;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        tropcl=1;
        _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , tropbkxr);
        _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , tropchxr, tropbkxr);
        refresh();
        continue ;
    }
    
    if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    
    if (mx>goxt && mx<goxt+94 && my>goyt && my<goyt+36) {
        ektos=0;
        if (probar) probar=0;
        
        if (cancel) continue ;
        cancel=1;
        RNputicon(goxt,goyt,mem_go,black);
        continue ;
    }
    
    if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}
    
    

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        
        if (cancel) {
            fyge=1;
            kati=-2;
            continue ;
        }
            
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -5);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) && (!neaepcl) && (!tropcl) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
         if (krit[ar_dom[el]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr3-1, ytepl+protyx*fhe+(fhe-1)); }
            protyx=lines;
            refresh();
            continue ;
        }

        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),slkl);
        _outfanis_colxr(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr ,xrkl, slkl);
        _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2 , xrkl, slkl);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3 , xrkl, slkl);
        //_outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3 , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+1,ytepl+protyx*fhe+(fhe-1),xtepr3-1, ytepl+protyx*fhe+(fhe-1)); }
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
              
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            user_ans=alert(0,"Θέλετε να διαγραφεί η επέτειος ;" ,"Σίγουρα ;");
            if (user_ans != 1) continue;
            i=ar_dom[elem];
            ar_per--; plbut=ar_per;
            key_1=sort_1=65000;
            sparky=0;
            
            if (!plbut) { fyge=1; kati=-3; continue ;}
            
            for (f=i ; f<plbut ; f++) {
                pers[f].mob = pers[f+1].mob;
                pers[f].arkin = pers[f+1].arkin;
                pers[f].when = pers[f+1].when;
                pers1[f] = pers1[f+1];
                pers[f].year = pers[f+1].year;
                pers[f].alarm = pers[f+1].alarm ;
                mystrcpy (pers[f].tex , pers[f+1].tex);
                mystrcpy (pers[f].ktex , pers[f+1].ktex);
                mystrcpy(gbut[f],gbut[f+1]);
                krit[f]=0;
                but[f]=pers[f].tex;
                gsee.tog=pers[f].when ;
                dasi[f].daye[0]=pers[f].when ;
                dasi[f].daye[1]=pers[f].year ;
                sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , pers[f].year);
                normtext_tomy(dadm[f],0);
                //sprintf (nox[f] , "%03d" , f+1) ; 
            }
            
        
            key=*sorton;
            for (f=0;f<plbut;f++) ar_dom[f]=f;
            if (key) {
                item_mem=malloc(plbut*24);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                item=item_mem;
                for (f=0;f<plbut;f++) {
                    bitem[0].big=bitem[1].big=bitem[2].big=0;
                    i=0;by=23;
                    do {
                    what=but[f][i];
                    if (what>163) break;
                    if (keyb_gr){
                            switch (what) {

                                case 96:
                                case 101:
                                case 104:
                                case 107:
                                case 116:
                                case 122:
                                case 129:
                                case 132:
                                case 137:
                                case 140:
                                case 143:
                                case 151:
                                case 157:
                                case 163:
                                what--;
                                break;

                                case 108:
                                case 123:
                                case 144:
                                case 158:
                                what-=2;
                                break;


                                case 109:
                                case 124:
                                what-=3;
                                break;

                                case 130:
                                what=119;

                            }

                    }
                    rby=by%8; low=(2-(by/8));
                    //if (by>7) {low=0;rby=by-8;} else low=1;
                    bitem[low].sma[rby]=what;
                    by-- ; i++;
                    } while (by>=0);
                    item[f].fg=bitem[0].big;
                    item[f].sg=bitem[1].big;
                    item[f].tg=bitem[2].big;
                }

            // SORTING !!
                pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            else {
                item_mem=malloc(plbut*4);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                shoitem=item_mem;
                for (f=0;f<plbut;f++) {
                shoitem[f]=dasi[f].supdate;
                }

            // SORTING DATES!!
                pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            elem=proelem=-1 ; 
            protyx=lines;
            if (pano==plbut) pano--;
            c = pano;
            telos = (sort) ? c+1 : plbut-c ; 
            goto emfan ;
            
        }
        
        else if (tropcl) {
            if (elem==-1) {information(0,"Δεν έχετε επιλέξει κάποια επέτειο !",0); continue; }
            f = ar_dom[elem];
            for (i=0 ; i<3 ; i++) {
                chxrc[i]=chxr[i];
                bkxrc[i]=bkxr[i];
                slxrc[i]=slxr[i];
            }
            dx = pers_inp (-1, f ,elem+1, uday, umonth, uyear );
            for (i=0 ; i<3 ; i++) {
                chxr[i] = chxrc[i] ;
                bkxr[i] = bkxrc[i] ;
                slxr[i] = slxrc[i] ;
            }
            if (!dx) {
                tropcl=0;
                _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();
                continue ; }
            mystrcpy (gbut[f] , but[f]);
            atona (gbut[f]);
            gsee.tog=pers[f].when ;
            dasi[f].daye[0]=pers[f].when ;
            dasi[f].daye[1]=pers[f].year ;
            sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , pers[f].year);
            normtext_tomy(dadm[f],0);
            key_1=sort_1=65000;
            sparky=0;
            // ΑΝΑΤΑΞΙΝΟΜΗΣΗ
            key=*sorton;
            for (f=0;f<plbut;f++) {ar_dom[f]=f;krit[f]=0;}
            if (key) {
                item_mem=malloc(plbut*24);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                item=item_mem;
                for (f=0;f<plbut;f++) {
                    bitem[0].big=bitem[1].big=bitem[2].big=0;
                    i=0;by=23;
                    do {
                    what=but[f][i];
                    if (what>163) break;
                    if (keyb_gr){
                            switch (what) {

                                case 96:
                                case 101:
                                case 104:
                                case 107:
                                case 116:
                                case 122:
                                case 129:
                                case 132:
                                case 137:
                                case 140:
                                case 143:
                                case 151:
                                case 157:
                                case 163:
                                what--;
                                break;

                                case 108:
                                case 123:
                                case 144:
                                case 158:
                                what-=2;
                                break;


                                case 109:
                                case 124:
                                what-=3;
                                break;

                                case 130:
                                what=119;

                            }

                    }
                    rby=by%8; low=(2-(by/8));
                    //if (by>7) {low=0;rby=by-8;} else low=1;
                    bitem[low].sma[rby]=what;
                    by-- ; i++;
                    } while (by>=0);
                    item[f].fg=bitem[0].big;
                    item[f].sg=bitem[1].big;
                    item[f].tg=bitem[2].big;
                }

            // SORTING !!
                pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            else {
                item_mem=malloc(plbut*4);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                shoitem=item_mem;
                for (f=0;f<plbut;f++) {
                shoitem[f]=dasi[f].supdate;
                }

            // SORTING DATES!!
                pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            c=pano ;
            telos = (sort) ? c+1 : plbut-c ; 
            goto emfan ;
        }
        
        else if (neaepcl) {
            if (ar_per==730) continue ;
            for (i=0 ; i<3 ; i++) {
                chxrc[i]=chxr[i];
                bkxrc[i]=bkxr[i];
                slxrc[i]=slxr[i];
            }
            dx = pers_inp (ar_per, -1 ,ar_per+1, uday, umonth, uyear );
            for (i=0 ; i<3 ; i++) {
                chxr[i] = chxrc[i] ;
                bkxr[i] = bkxrc[i] ;
                slxr[i] = slxrc[i] ;
            }
            if (!dx) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();continue ;}
            f=ar_per;
            ar_per++; plbut=ar_per;
         
            but[f]=pers[f].tex;
            mystrcpy (gbut[f] , but[f]);
            atona (gbut[f]);
            gsee.tog=pers[f].when ;
            dasi[f].daye[0]=pers[f].when ;
            dasi[f].daye[1]=pers[f].year ;
            sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , pers[f].year);
            normtext_tomy(dadm[f],0);
            sprintf (nox[f] , "%03d" , f+1) ; 
            normtext_tomy(nox[f],0);
            
            // ΑΝΑΤΑΞΙΝΟΜΗΣΗ
            key=*sorton;
            for (f=0;f<plbut;f++) {ar_dom[f]=f;krit[f]=0;}
            if (key) {
                item_mem=malloc(plbut*24);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                item=item_mem;
                for (f=0;f<plbut;f++) {
                    bitem[0].big=bitem[1].big=bitem[2].big=0;
                    i=0;by=23;
                    do {
                    what=but[f][i];
                    if (what>163) break;
                    if (keyb_gr){
                            switch (what) {

                                case 96:
                                case 101:
                                case 104:
                                case 107:
                                case 116:
                                case 122:
                                case 129:
                                case 132:
                                case 137:
                                case 140:
                                case 143:
                                case 151:
                                case 157:
                                case 163:
                                what--;
                                break;

                                case 108:
                                case 123:
                                case 144:
                                case 158:
                                what-=2;
                                break;


                                case 109:
                                case 124:
                                what-=3;
                                break;

                                case 130:
                                what=119;

                            }

                    }
                    rby=by%8; low=(2-(by/8));
                    //if (by>7) {low=0;rby=by-8;} else low=1;
                    bitem[low].sma[rby]=what;
                    by-- ; i++;
                    } while (by>=0);
                    item[f].fg=bitem[0].big;
                    item[f].sg=bitem[1].big;
                    item[f].tg=bitem[2].big;
                }

            // SORTING !!
                pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            else {
                item_mem=malloc(plbut*4);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                shoitem=item_mem;
                for (f=0;f<plbut;f++) {
                shoitem[f]=dasi[f].supdate;
                }

            // SORTING DATES!!
                pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            c=pano ;
            telos = (sort) ? c+1 : plbut-c ; 
            goto emfan ;
        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            elem=proelem=-1 ; 
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*4);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f].supdate;
    }

// SORTING DATES!!
    pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
                    _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                    _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
                     //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
                    refresh();
                    elem=proelem=-1 ; 
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr3-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
                //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
                refresh();
                elem=proelem=-1 ; 
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    
            }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer);  mem_zer=0; yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer); mem_zer=0;

            xtepr3=xb-9;
            xtepl=xt+9; xtepr = xtepl+9*myfont_wid[fnt]/4;
            xtepl2 = xtepr+3;
            xtepl3=xtepr3-3*13*myfont_wid[fnt]/4;
            xtepr2=xtepl3-3; 
                        
            ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            goxt = xok-80 ; goyt = ysort +14 ;
            
            neaepxt = tropxt= xvice + 60 ; neaepyt = ybarb+8 ;
            neaepxb = tropxb= neaepxt+100 ; neaepyb = neaepyt+18; 
            tropyt=neaepyb+8; tropyb = tropyt+18;
            infmobxt = neaepxb+35 ; infmobyt = neaepyt+13 ;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            neaepyt = ybarb+8 ;
            neaepyb = neaepyt+18; 
            tropyt=neaepyb+8;
            tropyb = tropyt+18;
            infmobyt = neaepyt+13 ;
            goyt = ysort +14 ;
            _areacls (xtepl,ytepl,xtepr3,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr3,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr3);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            
            _bareacls (xtepl,ytepl,xtepr3,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr3,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            Rputicon(goxt,goyt,mem_go,black);
            
            setcolor(1);
            rectangle (neaepxt , neaepyt, neaepxb, neaepyb) ;
            setcolor(2) ;
            rectangle (neaepxt-1 , neaepyt-1, neaepxb+1, neaepyb+1) ;
            _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr);
            _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);

            setcolor(1);
            rectangle (tropxt , tropyt, tropxb, tropyb) ;
            setcolor(2) ;
            rectangle (tropxt-1 , tropyt-1, tropxb+1, tropyb+1) ;
            _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr);
            _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);


            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            gouv=myfont[user_ans];
            fnt = user_ans ; personal_font = fnt ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            
            i=orio*2*myfont_wid[fnt]/3;
            f=info.right-info.left;
            fhe=myfont_hei[fnt]+2;
            if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
            
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            
            xtepr3=xb-9;
            xtepl=xt+9; xtepr = xtepl+9*myfont_wid[fnt]/4;
            xtepl2 = xtepr+3;
            xtepl3=xtepr3-3*13*myfont_wid[fnt]/4;
            xtepr2=xtepl3-3; 
            
            ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19 ;
            goxt = xok-80 ; goyt = ysort +14 ;
            
            neaepxt = tropxt= xvice + 60 ; neaepyt = ybarb+8 ;
            neaepxb = tropxb= neaepxt+100 ; neaepyb = neaepyt+18; 
            tropyt=neaepyb+8; tropyb = tropyt+18;
            infmobxt = neaepxb+35 ; infmobyt = neaepyt+13 ;
            
            _areacls (xtepl,ytepl,xtepr3,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr3);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr3,ytepr,0,0,0);
            refresh();
            
            _puticon (xdel,ydel,mem_del,255);
            
            _puticon(searx,seary,mem_search,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _Rputicon(goxt,goyt,mem_go,black);
            
            setcolor(1);
            rectangle (neaepxt , neaepyt, neaepxb, neaepyb) ;
            setcolor(2) ;
            rectangle (neaepxt-1 , neaepyt-1, neaepxb+1, neaepyb+1) ;
            _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr);
            _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);

            setcolor(1);
            rectangle (tropxt , tropyt, tropxb, tropyb) ;
            setcolor(2) ;
            rectangle (tropxt-1 , tropyt-1, tropxb+1, tropyb+1) ;
            _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr);
            _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           

        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           
        _outfanis_col(fnt, nox[c] , xtepl+1 , ytepl+k*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl3+1 , ytepl+k*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr3);
        if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr3-1, ytepl+k*fhe+(fhe-1)); }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line (xtepr+2,ytepl,xtepr+2,ytepl+k*fhe+1);
    line (xtepr2+2,ytepl,xtepr2+2,ytepl+k*fhe+1);
    line(xtepl,ytepl+k*fhe+1,xtepr3,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                _outfanis_col(fnt, nox[c] , xtepl+1 , ytepl+k*fhe , xtepr);
                _outfanis_col(fnt, but[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
                _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl3+1 , ytepl+k*fhe , xtepr3);
                //_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr3);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr3-1, ytepl+k*fhe+(fhe-1)); }
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line (xtepr+2,ytepl,xtepr+2,ytepl+k*fhe+1);
            line (xtepr2+2,ytepl,xtepr2+2,ytepl+k*fhe+1);
            line(xtepl,ytepl+k*fhe+1,xtepr3,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

  SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
  
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if (mem_go) free(mem_go);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}


int txt_scrollsearch (unsigned char *str, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *Rclik, int *cochxr , int *cobkxr , int *cobkxr2)
{

// Κάνει scroll - show 
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,ar,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_mod , ch_scan , klik=0 ; 
int diaf1,diaf2 ;
short int wrap ,enbar=0 ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue;
void *mem_bar=0;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;

float neg, alfa ;

what=str[0];
if (what==255) { 
    do {
        if (!SDL_PollEvent(&sdlev)) continue ;
        if (sdlev.type==SDL_MOUSEMOTION) {
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx<info.left || my<info.top) continue ;
            if (mx>xr || mx<xl || my<yt || my>yb) {fyge=1; break; }
        }
        continue ;
    } while (!fyge);
return 1 ; 
}    
        
elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

//setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
//rectangle (xl,yt,xr,yb);
xl++ ; yt++ ; xr-- ; yb--;
if (xr+17>info.right)  bar=2;
if (!bar) {mem_bar=malloc((imagesize (xr+6,yt-1,xr+17,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; return (1); }
getimage (xr+6,yt-1,xr+17,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,cobkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        
        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

            /*          
        if (cur) {
            if (pos[ar-1][1]>=ektos || pos[0][1]<yt) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;}
            else wherp=0;
            }
            */
            
        if (cur) {
            i=cur;
            while (pos[i][1]>yt) {
                for (f=0 ; f<=ar ; f++) {pos[f][1]-=bh ;}
            }
            while (pos[i][0]>xl) i--;
            wherp=i;
        }
        else wherp=0;
        
        x1=xl; y1=yt;

            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;

            if (!co.lor) continue;

            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
        

        x=pos[cur][0] ; y=pos[cur][1];
        //a2=a;
        
         // ELEGXOS GIA PLEYRIKH MPARA
        //if (!ar) goto Enarjh ;
        proyt=abs(pos[0][1]-yt) ;
        if (!ar) metektos=0;
        else metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (0,255,0) );  
        rectangle (xr+6,yt-1,xr+17,yb);
        setcolor (COLOR (0,0,0) );  
        for (f=xr+7 ; f<xr+17 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+7 ; f<xr+17 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        

  
Enarjh :
enbar = (bar) ? 17 : 0;
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        //while (SDL_PollEvent(&sdlev) && sdlev.type==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
         if (mx<info.left || my<info.top) continue ;
               
        if (mx>xr+enbar || mx<xl || my<yt || my>yb) {goto stokalo ;}

        continue ;
        
        case SDL_MOUSEWHEEL :
            //while (SDL_PollEvent(&sdlev)) continue ;
            if(sdlev.wheel.y > 0) { // scroll up
                        SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    
                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    //a2=a;
                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
                    SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                   
                    refresh();
                     //a2=a;               
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;
            if (mx<info.left || my<info.top) continue ;
            if (mx>xr+enbar || mx<xl || my<yt || my>yb) {goto stokalo ;}
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) { // MPARA

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            //diaf1=cur+1;
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }

                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar-1][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    
                    refresh();
                     //a2=a;               

                proyt1=abs(pos[0][1]-yt) ;
                if (!ar) metektos1=0;
                else metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+6,yt-1,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+7 ; f<xr+17 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
        }   // END bar !!
        
            {klik=1; goto stokalo ;}                      // END Case buttondown
        }
                                     // END Button Left
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
             { *Rclik=1; klik=0; goto stokalo ;}
        
            
        } // Τελος Button Right
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
            ch_mod=SDL_GetModState();
            
                    switch (ch_scan) { 
                        
        //case SDL_SCANCODE_ESCAPE :  
          //          fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) goto stokalo ;
            
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            
            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
            refresh();
            //a2=a;
            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
    
            if (cur==ar) goto stokalo ;

            if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;

            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }
            
            refresh();
             //a2=a;               
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    //a2=a;
                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :

                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    //a2=a;
                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        if (!ar) metektos=0;
                        else metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (0,255,0) );  
                        rectangle (xr+6,yt-1,xr+17,yb);
                        setcolor (COLOR (0,0,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                if (!ar) metektos1=0;
                else metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+6,yt-1,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+7 ; f<xr+17 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;    
                    
        default :
                    
        goto stokalo ;
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_QUIT :
        goto stokalo ;
        
        case SDL_WINDOWEVENT :
        refresh(); continue;
            
        }                                    // END sdlev type 

        
    } while (!fyge);


stokalo :
if (cur) {
    i=cur;
    while (pos[i][1]>yt) i--;
    if(i) {
        while (pos[i][0]>xl) i--;}

    cur=i;
}

diaf1=cur+1;
if (klik) diaf1=-diaf1;

if (bar==1) putimage (xr+6,yt-1,mem_bar,0);
if (mem_bar) free (mem_bar);
        xr+=5;
        
        if (pos[0][1]<yt) {
            
        setrgbcolor(dbblack);
        line(xr+6,yt-1,xr+6,yt+10);
        line(xr+7,yt-1,xr+7,yt+10);
        line(xr+2,yt+3,xr+6,yt-1);
        line(xr+2,yt+4,xr+6,yt);
        line(xr+2,yt+5,xr+6,yt+1);
        line(xr+11,yt+5,xr+7,yt+1);
        line(xr+11,yt+4,xr+7,yt);
        line(xr+11,yt+3,xr+7,yt-1);
        
        }
        else {_bareacls (xr+2,yt-1,xr+11,yt+10,cobkxr2);}

                
        if (pos[ar-1][1]>=ektos) {
        setrgbcolor(dbblack);
        line(xr+6,yb-10,xr+6,yb);
        line(xr+7,yb-10,xr+7,yb);
        line(xr+2,yb-6,xr+6,yb-2);
        line(xr+2,yb-5,xr+6,yb-1);
        line(xr+2,yb-4,xr+6,yb);
        line(xr+11,yb-6,xr+7,yb-2);
        line(xr+11,yb-5,xr+7,yb-1);
        line(xr+11,yb-4,xr+7,yb);
        }
        else {_bareacls (xr+2,yb-10,xr+11,yb,cobkxr2);}
        
refresh();
return diaf1 ;
}


int txt_scroll_min (unsigned char *str, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *Rclik, int *cochxr , int *cobkxr , int *cobkxr2)
{

// Κάνει scroll - show 
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,ar,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_mod , ch_scan , klik=0 ; 
int diaf1,diaf2 ;
short int wrap ,enbar=0 ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue ;
void *mem_bar=0;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;

float neg, alfa ;

what=str[0];
if (what==255) { 
    do {
        if (!SDL_PollEvent(&sdlev)) continue ;
        if (sdlev.type==SDL_MOUSEMOTION) {
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx<info.left || my<info.top) continue ;
            if (mx>xr || mx<xl || my<yt || my>yb) {fyge=1; break; }
        }
        continue ;
    } while (!fyge);
return 1 ; 
}    
        
elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

//setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
//rectangle (xl,yt,xr,yb);
xl++ ; yt++ ; xr-- ; yb--;
if (xr+17>info.right)  bar=2;
if (!bar) {mem_bar=malloc((imagesize (xr+6,yt-1,xr+17,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; return (1); }
getimage (xr+6,yt-1,xr+17,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,cobkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        
        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

            /*          
        if (cur) {
            if (pos[ar-1][1]>=ektos || pos[0][1]<yt) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;}
            else wherp=0;
            }
            */
            
        if (cur) {
            i=cur;
            while (pos[i][1]>yt) {
                for (f=0 ; f<=ar ; f++) {pos[f][1]-=bh ;}
            }
            while (pos[i][0]>xl) i--;
            wherp=i;
        }
        else wherp=0;
        
        x1=xl; y1=yt;

            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;

            if (!co.lor) continue;

            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
        

        x=pos[cur][0] ; y=pos[cur][1];
        //a2=a;
        
         // ELEGXOS GIA PLEYRIKH MPARA
        //if (!ar) goto Enarjh ;
        proyt=abs(pos[0][1]-yt) ;
        if (!ar) metektos=0;
        else metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (0,255,0) );  
        rectangle (xr+6,yt-1,xr+17,yb);
        setcolor (COLOR (0,0,0) );  
        for (f=xr+7 ; f<xr+17 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+7 ; f<xr+17 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        

  
Enarjh :
enbar = (bar) ? 17 : 0;
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
            
        case SDL_QUIT :
            
            goto stokalo ;
            break ;
        
        case SDL_MOUSEMOTION:
        //while (SDL_PollEvent(&sdlev) && sdlev.type==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
         if (mx<info.left || my<info.top) continue ;
               
        if (mx>xr+enbar || mx<xl || my<yt || my>yb) {goto stokalo ;}

        continue ;
        
        case SDL_MOUSEWHEEL :
            //while (SDL_PollEvent(&sdlev)) continue ;
            if(sdlev.wheel.y > 0) { // scroll up
                    SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    
                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    //a2=a;
                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
                    SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                   
                    refresh();
                     //a2=a;               
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;
            if (mx<info.left || my<info.top) continue ;
            if (mx>xr+enbar || mx<xl || my<yt || my>yb) {goto stokalo ;}
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) { // MPARA

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            //diaf1=cur+1;
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }

                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar-1][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    
                    refresh();
                     //a2=a;               

                proyt1=abs(pos[0][1]-yt) ;
                if (!ar) metektos1=0;
                else metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+6,yt-1,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+7 ; f<xr+17 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
        }   // END bar !!
        
            continue ;                      // END Case buttondown
        }
                                     // END Button Left
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
             *Rclik=1; goto stokalo ;
        
            
        } // Τελος Button Right
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
            ch_mod=SDL_GetModState();
            
                    switch (ch_scan) { 
                        
        //case SDL_SCANCODE_ESCAPE :  
          //          fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) goto stokalo;
            
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;

            // Gia MENA 
            alfa =  ((float)co.rgb[0] / 255) ;
            neg = ((float)1 - alfa);
            red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
            green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
            blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
            refresh();
            //a2=a;
            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
    
            if (cur==ar) goto stokalo;

            if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            

            // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }
            
            refresh();
             //a2=a;               
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    //a2=a;
                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :

                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;

                    // Gia MENA 
alfa =  ((float)co.rgb[0] / 255) ;
neg = ((float)1 - alfa);
red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    //a2=a;
                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        if (!ar) metektos=0;
                        else metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (0,255,0) );  
                        rectangle (xr+6,yt-1,xr+17,yb);
                        setcolor (COLOR (0,0,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                if (!ar) metektos1=0;
                else metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+6,yt-1,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+7 ; f<xr+17 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+7 ; f<xr+17 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;     
                    
                    break ;
                    
                default :
                    
                    goto stokalo ;
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_WINDOWEVENT :
        refresh(); continue;
            
        }                                    // END sdlev type 

        
    } while (!fyge);


stokalo :
if (cur) {
    i=cur;
    while (pos[i][1]>yt) i--;
    if(i) {
        while (pos[i][0]>xl) i--;}

    cur=i;
}

diaf1=cur+1;
// if (klik) diaf1=-diaf1;

if (bar==1) putimage (xr+6,yt-1,mem_bar,0);
if (mem_bar) free (mem_bar);
        xr+=5;
        
        if (pos[0][1]<yt) {
            
        setrgbcolor(dbblack);
        line(xr+6,yt-1,xr+6,yt+10);
        line(xr+7,yt-1,xr+7,yt+10);
        line(xr+2,yt+3,xr+6,yt-1);
        line(xr+2,yt+4,xr+6,yt);
        line(xr+2,yt+5,xr+6,yt+1);
        line(xr+11,yt+5,xr+7,yt+1);
        line(xr+11,yt+4,xr+7,yt);
        line(xr+11,yt+3,xr+7,yt-1);
        
        }
        else {_bareacls (xr+2,yt-1,xr+11,yt+10,cobkxr2);}

                
        if (pos[ar-1][1]>=ektos) {
        setrgbcolor(dbblack);
        line(xr+6,yb-10,xr+6,yb);
        line(xr+7,yb-10,xr+7,yb);
        line(xr+2,yb-6,xr+6,yb-2);
        line(xr+2,yb-5,xr+6,yb-1);
        line(xr+2,yb-4,xr+6,yb);
        line(xr+11,yb-6,xr+7,yb-2);
        line(xr+11,yb-5,xr+7,yb-1);
        line(xr+11,yb-4,xr+7,yb);
        }
        else {_bareacls (xr+2,yb-10,xr+11,yb,cobkxr2);}
        
refresh();
return diaf1 ;
}


FILE * read_pipe( char *popor )
// Πραγματοποιεί μια κλήση σε κάποια εφαρμογή με την popen για να κλέψει την έξοδο της από την stdout.
// Τα ορίσματα εκτέλεσης της εφαρμογής πρέπει να διαβιβαστούν εδώ με έναν char * (popor)
// ΔΕΝ ΚΛΕΒΕΙ ΕΞΟΔΟ !!
// Επιστρέφει τον FILE * του buffer αλλά αφού η συνάρτηση επιστρέψει θα υπολείπεται το pclose...

{
FILE *fp1=NULL;

    fflush (stdout);
    fp1 = popen(popor ,"r");
    if (fp1==NULL) {
        perror("popen error"); 
        if (keyb_gr) information (0,"Αποτυχία κλήσης εφαρμογής!",0);
        else information (0,"Application call failure !" , 0);
        return (NULL);}
    return (fp1);
}


int Start_strstr(char *big, char *sma)
// Τσεκάρει αν το string sma είναι ακριβώς στην αρχή του string big
// Επιστρέφει 1 αν ισχύει αυτό και 0 αν δεν ισχύει.
{
    int lb,ls ;
    register int f;
    
    lb = strlen(big);
    ls = strlen (sma);
    f=0;
    
    while ( (lb) && (ls) ) {
        lb--; ls--;
        if (big[f] != sma[f]) { return (0); }
        f++;
    }
    if (ls) return (0) ;
    return (1);
}


int fileselector( char *popor, char *old , int max)
// Πραγματοποιεί μια κλήση σε κάποια εφαρμογή με την popen για να κλέψει την έξοδο της από την stdout.
// Τα ορίσματα εκτέλεσης της εφαρμογής πρέπει να διαβιβαστούν εδώ με έναν char * (popor)
// Το κείμενο που θα κλαπεί (μέσω piping) από την stdout θα το περάσει στον char πίνακα που δείχνει ο δείκτης old. Ομως...θα περάσει μόνον το τελευταίο string !
// Μέγιστη χωρητικότητα του old είναι το max.

{
register int a;
int status_1 ;
FILE *fp1=NULL;
char new[1512];
char ch;

    fflush (stdout);
    
    fp1 = popen(popor ,"r");
    a=0;
    if (fp1==NULL) {
        perror("popen error"); 
        if (keyb_gr) information (0,"Αποτυχία κλήσης εφαρμογής!",0);
        else information (0,"Application call failure !" , 0);
        return (0);}
    while (fgets(new,1510,fp1)) { 
        if (new[0]=='/') { a=1; break; } 
        if (ferror(fp1)) {clearerr(fp1);break;}
    } 
    status_1 = pclose (fp1);
    refresh();
    if (!a) return (0);
    
    if (status_1==-1) {
        return(0);
    }
    else {
        if (!WIFEXITED(status_1)) return (0);
        if (WIFSIGNALED(status_1)) {
            if (WCOREDUMP(status_1)) return (0);
        }
        if (WIFSTOPPED(status_1)) return (0);
    }
    
    status_1=0;
    for (a=0;a<max;a++) {
        ch=new[a];
        if (ch=='\n') ch='\0';
        old[a] = ch;
        if (ch=='\0') { status_1=1; break; }
    }
    if (!status_1) {old[a]='\0';}
    return (1);
}


int Open_Report_Link(char* filename)
{
    
    int a=0 ;

    if (!access("/usr/bin/xed", F_OK )) {
        orisma[0]="/usr/bin/xed"; orisma[1]="xed";
    }
    else if(!access("/usr/bin/kwrite", F_OK )) {
        orisma[0]="/usr/bin/kwrite"; orisma[1]="kwrite";
    }
    else if(!access("/usr/bin/gedit", F_OK )) {
        orisma[0]="/usr/bin/gedit"; orisma[1]="gedit";
    }
    else if(!access("/usr/bin/geany", F_OK )) {
        orisma[0]="/usr/bin/geany"; orisma[1]="geany";
    }
    else if(!access("/usr/bin/featherpad", F_OK )) {
        orisma[0]="/usr/bin/featherpad"; orisma[1]="featherpad";
    }
    else if(!access("/usr/bin/kate", F_OK )) {
        orisma[0]="/usr/bin/kate"; orisma[1]="kate";
    }
    
    else {return (0);}
        
    // Close file pointers

    
    pid = fork () ;
    
    if (pid<0) {perror("Fork...");a=0; 
        if (keyb_gr) information (0,"Ανεπάρκεια διαθέσιμων πόρων!","Προσπαθήστε πάλι..");
        else  information (0,"Lack of available resources!","Try Again..");
        a=0;
        goto EJOD_KIND ;}
    else if ( !pid ) {
        execl(orisma[0],orisma[1],filename,(char *)NULL); 
        _exit (1); 
        }
    else {waitpid(pid,&status,WNOHANG);}
    
    if (status==-1) {a=0; refresh(); goto EJOD_KIND ;}
    
    refresh();
    a=1;

EJOD_KIND :

    // Open file pointers
    
    return (a) ;
    
}


short int _show_month_greg (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth,unsigned short int stamonth)
{
    register int i,f ;
    unsigned short int xb,yb ;
    unsigned short int a , b ;
    int bluedy,reddy ;
    short int mo[13];
    unsigned short int cx[8] , cy[6] ;
    
    union {
        unsigned int olo;
        unsigned char meros[4];
        unsigned short int mewo[2];
    } story ;
    
    char mera [8][8] , monda [32][3] ;
    
    int bluechxr[3] , redchxr[3] , genchxr[3] ;
    int *piobkxr ;
    int genbkxr[3] , bkxrepi[3] ; 
    
    // 4 Okt 1582 τελευταία ημέρα Ιουλιανού - Πέμπτη !
    // 15 Okt 1582 πρώτη ημέρα Γρηγοριανού - Παρασκευή !
    
    if (!uyear || uyear>2800 || uyear<1600 ) return -1;
    
    genchxr[0]=genchxr[1]=genchxr[2]=67;
    genbkxr[0]=231 ; genbkxr[1]= 227; genbkxr[2]=181;
    bluechxr[0] = 67; bluechxr[1] = 67; bluechxr[2] = 229 ;
    bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
    redchxr[0]=160;redchxr[1]=67; redchxr[2]=67;

    
       
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;
    
        
            
        if (uyear%4) mo[2]=28;
        else {
            if (uyear%100) mo[2]=29;
            else {mo[2]=(uyear%400) ? 28 : 29 ;}
            }
    
        
    if (keyb_gr) {

        strcpy (mera[1],"Κυρ");  strcpy (mera[2],"Δευ"); strcpy (mera[3],"Τρι"); strcpy (mera[4],"Τετ");
        strcpy (mera[5],"Πεμ"); strcpy (mera[6],"Παρ"); strcpy (mera[7],"Σαβ"); }
    else {

        strcpy (mera[1],"Sun");  strcpy (mera[2],"Mon"); strcpy (mera[3],"Tue"); strcpy (mera[4],"Wed");
        strcpy (mera[5],"Thu"); strcpy (mera[6],"Fri"); strcpy (mera[7],"Sat"); }
        
       // Στήλες Σαββατοκύριακου έγχρωμες 
    a=stamonth;
    for (f=1; f<8; f++) {
        if (a==1) reddy=f;
        else if (a==7) bluedy=f;
        a++;
        if (a==8) a=1;
        normtext_tomy (mera[f],0);
    }
    
    for (f=1; f<32; f++) {
        sprintf(monda[f],"%d",f);
        normtext_tomy (monda[f],0);
    }
    
    
    // Υπολογισμός cx - cy
    for (i=1 ; i<8 ; i++ ) { cx[i]=xt+(i-1)*60; }
    xb=xt+(i-1)*60;
    for (f=0 ; f<6;f++) { cy[f]=yt+f*25; }
    yb=yt+f*25;
    
    bareacls (xt,yt,xb,yb,genbkxr);
    
    // ΒΑΣΙΚΗ ΣΧΕΔΙΑΣΗ 
    setrgbcolor(dbaspro);
    rectangle (xt,yt,xb,yb) ;
    
  
        a=0;b=stamonth;
        
        
        for (f=0 ; f<6;f++) {
            setrgbcolor(dbaspro);
            line (cx[1],cy[f],xb,cy[f]);
            for (i=1 ; i<8 ; i++ ) {
                if (!f) {
                    setrgbcolor(dbaspro);
                    line (cx[i],cy[0],cx[i],yb);
                    
                    if (bluedy==i) _outmystr_center_col (neohell_20b,mera[b],cx[i],cy[0],cx[i]+59,cy[1],bluechxr,genbkxr);
                    else if (reddy==i) _outmystr_center_col (neohell_20b,mera[b],cx[i],cy[0],cx[i]+59,cy[1],redchxr,genbkxr);
                    else _outmystr_center_col (neohell_20n,mera[b],cx[i],cy[0],cx[i]+59,cy[1],genchxr,genbkxr);
            
                    b++; if (b==8) b=1 ;
                    continue ;
                    
                }
                
                a++;
                if (a>mo[umonth]) break ;

                piobkxr=genbkxr;
                
                if (i==bluedy) _outmystr_center_col (neohell_20b,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,bluechxr,piobkxr);
                else if (i==reddy) _outmystr_center_col (neohell_20b,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,redchxr,piobkxr);
                else _outmystr_center_col (neohell_20n,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,genchxr,piobkxr);
                
            }
        }
    

    setrgbcolor(dbaspro);
    line (cx[1], yb, xb,yb);
    return (1) ;
}


void _transp_fill (int x, int y, int w , int h, int tred , int tgreen , int tblue , int transp)
{
register int f , i ;
float neg , alfa ;
int red, green , blue ;

union {
unsigned int lor ;
unsigned char rgb[4];
} ba ;

    alfa = (float) transp / (float) 255 ;
    neg = ((float)1 - alfa);

    for (f=0;f<h;f++) {
        for (i=0;i<w;i++) {
        ba.lor = getpixel (x+i , y+f);
        red = (int) ((alfa * (float) tred) + (neg * (float) ba.rgb[2]));
        green = (int) ((alfa * (float) tgreen) + (neg * (float) ba.rgb[1]));
        blue = (int) ( (alfa * (float) tblue) + (neg * (float) ba.rgb[0]));
        setcolor (COLOR ( red,green,blue) );  
        _putpixel (x+i,y+f); 
        }
    }
}

void _outmystr_col_transp(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr,short int transp)
{
register int f,i ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 ;
int b ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co , ba ;

struct fansouv *trampa;
float neg, alfa ;

    trampa=gouv;
    gouv=myfont[font];
    what=str[a];
    while (what<164) {
    if ( x> (xri-gouv[what].wid+1) ) break;
    
    mem_int=gouv[what].where ;
    
       
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue ; 
        

        // Gia MENA 
        b = (int) co.rgb[0] - transp ;
        if (b<0) b=0 ;
        alfa = (float) b / (float) 255 ;
        neg = ((float)1 - alfa);
        ba.lor = getpixel (x+i , y+f);
        red = (int) ( (alfa * (float)xxr[0]) + (neg * (float) ba.rgb[2]) );
        green = (int) ( (alfa * (float)xxr[1]) + (neg * (float) ba.rgb[1]) );
        blue = (int) ( (alfa * (float)xxr[2]) + (neg * (float) ba.rgb[0]) );
            setcolor(COLOR (red,green,blue));
        _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    } 
   gouv=trampa;
}   


int real_strlen(char *normstr) 

{

unsigned short int ch1 ;
int a ;
register int f , i ;
char ch ;

    f=0 ; a=0 ;
    ch=normstr[f];
    while ( ch!='\0') {
        if (ch<0) {
            
            f++ ; ch1= ( (256*ch) + normstr[f] ) ;
            for (i=0 ; i<69 ; i++) {
                if (ch1==unico[i][0]) { a++; break;}
            }
            if (i==69) {a++ ; f--; }
            f++; ch=normstr[f];continue;
        }
        else {
            if (ch=='\n') {a++; f++; ch=normstr[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==souv[i].who) { a++ ; break; }
            }
            if (i==95) {a++ ;}
            f++;ch=normstr[f];
        }
    }
        
    return a;
}

void fill_char(char *str,int len,char *ch)
{
    char ch1;
    register int f;
    
    ch1 = *ch;
    for (f=0 ; f<len ; f++) {
        str[f]=ch1;
    }
    str[f]='\0';
    
}

void sunrise_sunset (unsigned short int year , unsigned short int month , unsigned short int date )

{
    double Y, M , D , D1 , F , J ;
    double G , S , A , J3 ,P2 ,DR , K1 , B5 , L5 , H ;
    double Z0 , T , TT , T0 , L , V , U , W , A5 , D5 , R5 , Z1 ;
    double C , M8 , W8 , Z , A0 , D0 , DA , DD , A2 , D2 , P ;
    double L0 , L2 , H0 , H2 , H1 , V0 , V2 , V1 , B  , E , T3 , H3 , M3 ;
    double H7,N7,D7,AZ ;
    double a[3] , d[3] ;
    double P1 = 3.14159265 ;
    double i1 , i2 ;
    double C0 ;
    register int f;
    short int dd , dd_1 , i ;
    unsigned short int est_start , edt_start , today , euro_est , euro_edt ;
    int diaf ;
    
    union est_edt {
    unsigned short int tog;
    unsigned char dm[2];
    } cur ;
    
    G=1;
    
    // Lat - Log
    /*
    Εισαγάγετε τα βόρεια γεωγραφικά πλάτη θετικά, τα δυτικά γεωγραφικά μήκη αρνητικά. 
    Έχουμε γεωγραφικό πλάτος Φ = 37° 59’ 14” N (βόρειο άρα θετικό ή 38-02)
    Έχουμε γεωγραφικό μήκος λ =  023° 43’ 39” E (ανατολικό γ.μήκος άρα θετικό ή 23-44)
    */
    
    
    B5 =  (double) 38.0 + ((double) 2.0 / 60) ; 
    
    L5 = (double) 23.0 + ((double) 44.0 / 60) ;
    
    /*
    // Να υπολογισθεί ακριβώς το H 
    The Eastern Standard Time (also commonly known as EST) is the method of time used during fall and winter. It starts during the first Sunday of November until the middle of March, more specifically the second Sunday of March. In the second Sunday of March, clocks switch into the Eastern Daylight Time (EDT for short). The Eastern Daylight Time lasts from the second Sunday of March to the first Sunday of November, basically the time method for the seasons of summer – spring.

    Η αλλαγή της ώρας γίνεται σύμφωνα με οδηγία της Ευρωπαϊκής Ένωσης που υποχρεώνει όλα τα κράτη μέλη να την εφαρμόζουν ως νόμο, και πραγματοποιείται την τελευταία Κυριακή του Μαρτίου στις 1 π.μ. ώρα Γκρίνουϊτς (GMT), ενώ τελειώνει την τελευταία Κυριακή του Οκτωβρίου του ίδιου έτους στις 1 π.μ. ώρα Γκρίνουϊτς.
    */
    
                    /*
    
                    // EST Start - 1η Κυριακή Νοεμβρίου
                    
                    dd = find_dayname(year , 11 , 1);
                    cur.dm[1]=11 ;
                    
                    i = (dd==1) ? 1 : 0 ;
                    if (!i) {
                        for (f=2 ; f<10 ; f++) {
                            dd = (dd==7) ? 1 : dd+1 ;
                            if (dd==1) { break; }
                        } 
                    }
                    else f=1;
                    
                    cur.dm[0] = (unsigned char) f ; 
                    est_start = cur.tog;
    
                    // EDT Start = 2η Κυριακή Μαρτίου
                    
                    dd_1 = find_dayname(year , 3 , 1);
                    dd = dd_1;
                    
                    cur.dm[1]=3 ;
                    
                    i = (dd==1) ? 1 : 0 ;
                    for (f=2 ; f<21 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) {i++; if (i==2) break;}
                    }
                    cur.dm[0] = (unsigned char) f ;
                    edt_start = cur.tog;
                    
                    */
                    
                    H = 0 ;
                    cur.dm[0] = (unsigned char) date;
                    cur.dm[1] = (unsigned char) month;
                    today = cur.tog ;
                    
                    /*
                    if ( (today>=edt_start) && (today<est_start) ) H=4 ;
                    else H=5 ;
                   */
                    
                    
                    // Αλλαγή ώρας σε ΘΕΡΙΝΗ στην Ευρώπη : τελευταία Κυριακή Μαρτίου
                    
                    
                    cur.dm[1] = 3;
                    
                    dd = find_dayname(year , 3 , 1);
                    for (f=2 ; f<32 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) { cur.dm[0]= (unsigned char) f; }
                    }
                    
                    euro_edt = cur.tog;
                    
                    // Αλλαγή ώρας σε ΧΕΙΜΕΡΙΝΗ στην Ευρώπη : τελευταία Κυριακή Οκτωβρίου
                    
                    cur.dm[1] = 10;
                    
                    dd = find_dayname(year , 10 , 1);
                    for (f=2 ; f<32 ; f++) {
                       dd = (dd==7) ? 1 : dd+1 ;
                        if (dd==1) { cur.dm[0]= (unsigned char) f; }
                    }
                    
                    euro_est = cur.tog;
                    
                    if (today>=euro_edt && today<euro_est) H = -3; 
                    else H = -2;
                    
                    diaf=0;
                    
                    /*
                    if (today<euro_edt && H==5) diaf=7 ;
                    else if (today<euro_edt && H==4) diaf=6 ;
                    else if (today>=euro_edt && today<euro_est && H==4) diaf=7;
                    else if (today>=euro_edt && today<euro_est && H==5) diaf=8;
                    else if (today>=euro_est && H==4) diaf=6;
                    else diaf=7;
                    */
                    //printf ("H=%d , diaf=%d\n",(int)H , (int) diaf);
                    
    
    Y = (double) year ;
    M = (double) month ;
    D = (double) date ;
    
    // 300
    P2=2*P1 ;
    DR=P1/180 ; K1=15 * DR * (double) 1.0027379 ;
    
    L5=L5/360 ; Z0=H/24 ;
    
    // 1170-1300
    D1 = floor(D) ;
    F = D-D1-(double) 0.5 ;
    i1 = floor ((M+9)/12) ;
    i2 = floor ( (double) 7.0*(i1 + Y)/4 ) ;
    J = -i2 ;
    if (!(M-9)) S=0;
    else { S = (M-9 > 0) ? 1 : -1 ; }
    A = fabs (M-9);
    i1 = floor(A/7);
    J3 = floor(Y+(S*i1));
    i1 = floor (J3/100) + 1 ; 
    J3 = floor (i1*3/4) ;
    J3 = -J3 ;
    i1 = floor ((double) 275.0 * M/9) ;
    J = J + i1 + D1 + G*J3 ;
    J = J + 1721027 + 2.0*G + 367.0*Y ;
    if (F<0) { F=F+1 ; J=J-1 ;}
    
    T=(J-2451545)+F ;
    TT=T/36525+1 ; // TT = centuries
      
    // 410 - 470
    T0=T/36525 ; 
    S=(double)24110.5 + (double) 8640184.813*T0 ;
    S=S+ ( ( (double)86636.6 )*Z0 ) + 86400*L5 ;
    S=S/86400 ; i1=floor (S/86400) ; S = S - i1 ;
    T0=S*360*DR ;
    
    T=T+Z0;
    
    // 910 - 1160
    L = (double) 0.779072 + (((double) 0.00273790931)*T);
    G= (double) 0.993126 + (((double) 0.0027377785)*T) ;
    i1 = floor (L) ; L = L - i1 ; i1 = floor(G) ; G = G - i1 ;
    L=L*P2 ; G=G*P2 ;
    V= (double) 0.39785 * sin(L) ;
    V= V - ((double) 0.01000 * sin(L-G)) ;
    V=V + ((double) 0.00333 * sin(L+G)) ;
    V= V - ((double) 0.00021 * TT * sin(L)) ;
    U= (double) 1 - ((double) 0.03349 * cos(G)) ;
    U= U- ( (double) 0.00014 * cos (2*L) ) ;
    U= U + ((double) 0.00008 * cos (L) );
    W = (double)-0.00010 - ((double) 0.04129 * sin (2*L));
    W= W + ((double) 0.03211 * sin(G));
    W= W + ((double) 0.00104 * sin(2*L-G));
    W=W - ((double) 0.00035 * sin (2*L+G));
    W= W - ((double) 0.00008 * TT * sin (G)) ;
    S = W / sqrt (U-V*V) ;
    A5= L + atan (S/sqrt((double)1-S*S)) ;
    S = V/sqrt(U); 
    D5=atan(S/sqrt((double)1-S*S));
    R5=(double)1.00021*sqrt(U);
    
    a[1] = A5 ; d[1] = D5 ;
    T = T + 1 ;
    
    // 910 - 1160 (2η φορά)
    L = (double) 0.779072 + (((double) 0.00273790931)*T);
    G= (double) 0.993126 + (((double) 0.0027377785)*T) ;
    i1 = floor (L) ; L = L - i1 ; i1 = floor(G) ; G = G - i1 ;
    L=L*P2 ; G=G*P2 ;
    V= (double) 0.39785 * sin(L) ;
    V= V - ((double) 0.01000 * sin(L-G)) ;
    V=V + ((double) 0.00333 * sin(L+G)) ;
    V= V - ((double) 0.00021 * TT * sin(L)) ;
    U= (double) 1 - ((double) 0.03349 * cos(G)) ;
    U= U- ( (double) 0.00014 * cos (2*L) ) ;
    U= U + ((double) 0.00008 * cos (L) );
    W = (double)-0.00010 - ((double) 0.04129 * sin (2*L));
    W= W + ((double) 0.03211 * sin(G));
    W= W + ((double) 0.00104 * sin(2*L-G));
    W=W - ((double) 0.00035 * sin (2*L+G));
    W= W - ((double) 0.00008 * TT * sin (G)) ;
    S = W / sqrt (U-V*V) ;
    A5= L + atan (S/sqrt((double)1-S*S)) ;
    S = V/sqrt(U); 
    D5=atan(S/sqrt((double)1-S*S));
    R5=(double)1.00021*sqrt(U);
    
    a[2] = A5 ; d[2] = D5 ;
    if (a[2]<a[1]) { a[2]=a[2]+P2 ; }
    Z1=DR*(double)90.833 ;
    S = sin(B5*DR) ; C=cos(B5*DR) ;
    Z = cos(Z1); M8=0 ;  W8 = 0 ;
    A0=a[1] ; D0=d[1];
    DA=a[2]-a[1] ;
    DD=d[2]-d[1] ;
    
    for (f=0 ; f<24 ; f++)
    {
        C0 = (double) f ;
        P=(C0+(double) 1.0)/24 ;
        A2=a[1]+P*DA ;
        D2=d[1]+P*DD ;
        
        // 490
        
        L0=T0+C0*K1 ; L2=L0+K1 ;
        H0=L0-A0 ; H2=L2-A2 ;
        H1=(H2+H0)/2; D1=(D2+D0)/2 ;
        if (!f) {
            V0=S*sin(D0)+C*cos(D0)*cos(H0)-Z ;
        }
        V2=S*sin(D2)+C*cos(D2)*cos(H2)-Z ;
        if (!V0) i1=0 ;
        else {i1 = (V0>0) ? 1 : -1 ;}
        
        if (!V2) i2=0 ;
        else {i2 = (V2>0) ? 1 : -1 ;}
        
        if (i1==i2) { 
            A0=A2 ; D0=D2; V0=V2; 
            continue ; 
        }
        
        V1=S*sin(D1)+C*cos(D1)*cos(H1)-Z ;
        A=2*V2-4*V1+2*V0 ; B=4*V1-3*V0-V2 ;
        D= B*B - 4*A*V0 ;
        if (D<0) {
            A0=A2 ; D0=D2; V0=V2; 
            continue ;  
        }
        D=sqrt(D);
        if ((V0<0) && (V2>0)) { M8=1 ; }
        if ((V0>0) && (V2<0)) { W8=1 ; }
        E=(-B+D)/(2*A) ;
        if (E>1 || E<0) E=(-B-D)/(2*A);
        T3=C0+E+(double)1.0/120;
        H3=floor(T3); M3=floor((T3-H3)*60) ;
        // print H3 - M3
        if (M8==1) {
            //sunrise
        //printf ("%d-%d-%d\n",date,month,year);
        H3 = H3 + diaf ; if (H3>=24) H3 = H3 - 24 ;
        srise_h = (int) H3; srise_m = (int) M3;
        //printf ("Sunrise H3 = %d , M3 = %d\n", (int) H3 , (int) M3);
        M8=0;
        }
        if (W8==1) {
            //sunset
            H3 = H3 + diaf ; if (H3>=24) H3 = H3 - 24 ;
            sset_h = (int) H3; sset_m = (int) M3;
            //printf ("Sunset H3 = %d , M3 = %d\n", (int) H3 , (int) M3);
            W8=0;
        }
        
        H7=H0+E*(H2-H0) ;
        N7=-1*cos(D1)*sin(H7) ;
        D7=C*sin(D1)-S*cos(D1)*cos(H7);
        AZ=atan(N7/D7)/DR;
        if (D7<0) AZ=AZ+180 ;
        if (AZ<0) AZ=AZ+360 ;
        if (AZ>360) AZ=AZ-360;
        //print azimuth=AZ
        A0=A2 ; D0=D2; V0=V2;
    }
    /*
    // 820
    if ((!M8) && (!W8)) {
        if (V2<0) {
            // M3 Sun down all day
        }
        else if (V2>0) {
            //M4 Sun up all day
        }
    }
    else {
        if (!M8) {
        //M1 No sunrise this date
        }
        if (!W8) {
            //M2 No sunset this date
        }
    }
    */
    // End
}


//----------------------------------------------------------------------------------------
//                            MOON PHASE CALCULATION
//----------------------------------------------------------------------------------------
int moonPhases(int year, int month, int day)
{
    double jd = julianDat(year, month, day);  // calculate Julian Date
  
    double dr = (double) 3.14159265 / 180.0;
  
    double rd = (double) 1.0 / dr;
  
    unsigned long meeDT = pow(jd - 2382148, 2) / 41048480 / 86400;
  
    double meeT = (jd + (double) meeDT - 2451545.0) / 36525;
  
    unsigned long meeT2 = pow(meeT, 2);
  
    unsigned long meeT3 = pow(meeT, 3);
  
    double meeD = 297.85 + (445267.1115 * meeT) - (0.0016300 * (double) meeT2) + ((double) meeT3 / 545868);
  
    meeD = proper_ang(meeD) * dr;
  
    double meeM1 = 134.96 + (477198.8676 * meeT) + (0.0089970 * (double) meeT2) + ((double) meeT3 / 69699);
  
    meeM1 = proper_ang(meeM1) * dr;
  
    double meeM = 357.53 + (35999.0503 * meeT);
  
    meeM = proper_ang(meeM) * dr;
  
    double elong = meeD * rd + 6.29 * sin(meeM1);
  
    elong = elong - 2.10 * sin(meeM);
  
    elong = elong + 1.27 * sin(2 * meeD - meeM1);
  
    elong = elong + 0.66 * sin(2 * meeD);
  
    elong = proper_ang(elong);
  
    elong = round(elong);
    
    double temp = ((elong + 6.43) / 360.0) * 28.0;
  
    double temp1 = modf(temp,&jd);
    
    moonNum = (int) jd ;
    
    if (moonNum >= 28 )
    {
      moonNum = 0;
    }
    
    switch (moonNum) {
    
    case 0 : 
        if (temp1 > (double) 0.90) strcpy (MoonStr , "Νέα Σελήνη (+)");
        else strcpy (MoonStr , "Νέα Σελήνη");
        break ;
        
    case 7 :
        
        if (temp1 > (double) 0.90) strcpy (MoonStr , "Σελήνη 1 τετ-7ημ.(+)");
        else strcpy (MoonStr , "Σελήνη 1 τετ-7ημ."); 
        break;
        
    case 14:
        if (temp1 > (double) 0.90) strcpy (MoonStr , "Πανσέληνος (+)");
        else strcpy (MoonStr , "Πανσέληνος");
        break;
        
    case 21 :
        
        if (temp1 > (double) 0.90) strcpy (MoonStr , "Σελήνη 3 τετ-21ημ.(+)") ;
        else strcpy (MoonStr , "Σελήνη 3 τετ-21ημ.") ;
        break;
            
    default :
        
        if (temp1 > (double) 0.90) sprintf (MoonStr , "Σελήνη %d ημ.(+)",moonNum) ;
        else sprintf (MoonStr , "Σελήνη %d ημ.",moonNum) ; 
    }
      
    return moonNum;
}

//--------------------------------------------------------------------------------------------
//                                 PROPER ANG
//--------------------------------------------------------------------------------------------
double proper_ang(double big)
{
    double tmp = 0;
  
    if (big > 0)
    {
      tmp = big / 360.0;
      tmp = (tmp - floor(tmp)) * 360.0;
    }
    else
    {
      tmp = ceil(fabs(big / 360.0));
      tmp = big + tmp * 360.0;
    }
  
    return tmp;
}


//----------------------------------------------------------------------------------------
//                            CALCULATE JULIAN DATE
//----------------------------------------------------------------------------------------
double julianDat(int year, int month, int day)
{
  double  zone = -((double) timeZone * 60 / 1440.0);

  if (month <= 2)
  {
    year -= 1;
    month += 12;
  }
  
  double day2 = (double) day + zone + 0.5;
  double A = floor((double) year / 100.0);
  double B = 2 - A + floor(A / 4.0);
  double JD = floor(365.25 * ((double) year + 4716)) + floor(30.6001 * ((double) month + 1)) + day2 + B - 1524.5;

  return JD;
}



//----------------------------------------------------------------------------------------
//                            GET THE MOONPHASE TEXT
//----------------------------------------------------------------------------------------    
void moonPhaseText(int moonNum)
 { 
    
    switch (moonNum) {
        
        case 0 : 
            
            strcpy (MoonStr , "Νέα Σελήνη");
            break ;
            
        case 7 :
            
            sprintf (MoonStr , "Σελήνη %2d ημ. (1o/4o)",moonNum) ; 
            break;
            
        case 14 :
            strcpy (MoonStr , "Πανσέληνος");
            break;
            
        case 21 :
            
            sprintf (MoonStr , "Σελήνη %2d ημ. (3o/4o)",moonNum) ; 
            break;
                
        default :
            
            sprintf (MoonStr , "Σελήνη %2d ημ.",moonNum) ; 

    }

 }
 
 
void moonrise_moonset(unsigned short int year , unsigned short int month , unsigned short int date, short int *mo)
{
    // Προυποθέτω γενική μεταβλητή short int moon_ord και char moonrise_txt[100] - char moonset_txt[100]
double D1, F, i1, i2, J, S, A, J3, G, T, T0 ;
double L, N, V, U, W, A5, R5, Z1 ,H ;
double C, Z, M8, W8, A0, D0 , C0 ,M6 ;
double L0, L2, A2, H0, H2, H1, V0, V2, V1, E, T3, H3, M3, H7, N7, D7, A7 ;
double D5, P, F0, F1, F2, B, D2 ;
register int f;
short int dd , i ;
unsigned short int today, euro_est , euro_edt ;
int diaf ;
int I;
int mr=0 , ms=0 ;
int moonrise_H, moonrise_M , moonset_H , moonset_M ;

union est_edt {
unsigned short int tog;
unsigned char dm[2];
} cur ;


    double Y = (double) year ;
    double Mo = (double) month ;
    double D = (double) date ;

    // 170
    double M[4][4] ;
    double P1=(double) 3.14159265;
    double P2=2*P1 ;
    double R1=P1/180.0 ;
    double K1=(double) 15.0 *R1 * (double) 1.0027379 ;
    
    //  INPUT "LAT, LONG (DEG)";B5,L5
    
    double B5 =  (double) 38.0 + ((double) 2.0 / 60) ; 
    
    double L5 = (double) 23.0 + ((double) 44.0 / 60) ;
    
    // ENTOPISMOS DIAFORAS VRAS
    
    cur.dm[0] = (unsigned char) date;
    cur.dm[1] = (unsigned char) month;
    today = cur.tog ;
    
// Αλλαγή ώρας σε ΘΕΡΙΝΗ στην Ευρώπη : τελευταία Κυριακή Μαρτίου
                    
    cur.dm[1] = 3;
    
    dd = find_dayname(year , 3 , 1);
    for (f=2 ; f<32 ; f++) {
        dd = (dd==7) ? 1 : dd+1 ;
        if (dd==1) { cur.dm[0]= (unsigned char) f; }
    }
    
    euro_edt = cur.tog;
    
// Αλλαγή ώρας σε ΧΕΙΜΕΡΙΝΗ στην Ευρώπη : τελευταία Κυριακή Οκτωβρίου
                    
    cur.dm[1] = 10;
    
    dd = find_dayname(year , 10 , 1);
    for (f=2 ; f<32 ; f++) {
        dd = (dd==7) ? 1 : dd+1 ;
        if (dd==1) { cur.dm[0]= (unsigned char) f; }
    }
    
    euro_est = cur.tog;
    diaf=0;
    
    // INPUT "TIME ZONE (HRS)";H
    
    if (today>=euro_edt && today<euro_est) H = -3; 
    else H = -2;
        
    moon_ord = 0;
    
    L5 = L5/360 ;
    double Z0 = H/24 ;
    
    // 760 - 825 
    G = (double) 1.0 ;
    D1 = floor(D) ;
    F = D-D1-(double) 0.5 ;
    i1 = floor ((double) ((Mo+9)/12)) ;
    i2 = floor ( (double) 7.0*(i1 + Y)/4 ) ;
    J = -i2 ;
    if ((Mo-9)==0) S=0;
    else { S = ((Mo-9) > 0) ? 1 : -1 ; }
    A = fabs (Mo-9);
    i1 = floor(A/7);
    J3 = floor(Y+(S*i1));
    i1 = floor (J3/100) + 1.0 ; 
    J3 = floor (i1*3/4) ;
    J3 = -J3 ;
    i1 = floor ((double)275.0*Mo/9) ;
    J = J + i1 + D1 + G*J3 ;
    J = J + 1721027 + (double) 2.0*G + (double) 367.0*Y ;
    if (F<0) { F=F+1 ; J=J-1 ;}
    
    T=(J-2451545) + F ;
    
    // 245 - 270
    
    T0=T/36525.0 ;
    S=(double) 24110.5+ (double) 8640184.813*T0 ;
    S=S+ (double) 86636.6 * Z0 + (double) 86400.0*L5 ;
    S=S/86400.0 ; S -= floor(S) ;
    T0=S*(double) 360.0*R1 ;
    
    T+=Z0 ;
    
    for (I=1 ; I<4 ; I++) {
        //495-755
    
        L=(double) 0.606434+(double) 0.03660110129*T ;
        M6=(double) 0.374897+(double) 0.03629164709*T ;
        F=(double) 0.259091+(double) 0.03674819520*T ;
        D=(double) 0.827362+(double) 0.03386319198*T;
        N=(double) 0.347343-(double) 0.00014709391*T;
        G=(double) 0.993126+(double) 0.00273777850*T;
        L -= floor(L); M6 -= floor(M6);
        F -= floor(F); D -= floor(D) ;
        N -= floor(N); G -= floor(G) ;
        L=L*P2 ; M6=M6*P2 ; F=F*P2 ;
        D=D*P2 ; N=N*P2 ; G=G*P2 ;
        V=(double) 0.39558*sin(F+N);
        V=V+(double) 0.08200*sin(F);
        V=V+(double) 0.03257*sin(M6-F-N);
        V=V+(double) 0.01092*sin(M6+F+N);
        V=V+(double) 0.00666*sin(M6-F);
        V=V-(double) 0.00644*sin(M6+F-(double) 2.0*D+N);
        V=V-(double) 0.00331*sin(F-(double) 2.0*D+N);
        V=V-(double) 0.00304*sin(F-(double) 2.0*D);
        V=V-(double) 0.00240*sin(M6-F-(double) 2.0*D-N);
        V=V+(double) 0.00226*sin(M6+F);
        V=V-(double) 0.00108*sin(M6+F-(double) 2.0*D);
        V=V-(double) 0.00079*sin(F-N);
        V=V+(double) 0.00078*sin(F+(double) 2.0*D+N);
        U= (double) 1.0 - (double) 0.10828 * cos(M6);
        U=U-(double) 0.01880*cos(M6-(double) 2.0*D);
        U=U-(double) 0.01479*cos((double) 2.0*D);
        U=U+(double) 0.00181*cos((double) 2.0*M6-(double) 2.0*D);
        U=U-(double) 0.00147*cos((double) 2.0*M6);
        U=U-(double) 0.00105*cos((double) 2.0*D-G);
        U=U-(double) 0.00075*cos(M6- (double) 2.0*D + G);
        W=(double) 0.10478*sin(M6);
        W=W-(double) 0.04105*sin((double) 2.0*F + (double) 2.0*N);
        W=W-(double) 0.02130*sin(M6 - (double) 2.0*D);
        W=W-(double) 0.01779*sin((double) 2.0*F + N);
        W=W+(double) 0.01774*sin(N);
        W=W+(double) 0.00987*sin((double) 2.0*D);
        W=W-(double) 0.00338*sin(M6- (double) 2.0*F- (double) 2.0*N);
        W=W-(double) 0.00309*sin(G);
        W=W-(double) 0.00190*sin((double) 2.0*F);
        W=W-(double) 0.00144*sin(M6+N);
        W=W-(double) 0.00144*sin(M6-(double) 2.0*F-N);
        W=W-(double) 0.00113*sin(M6+ (double) 2.0*F + (double) 2*N);
        W=W-(double) 0.00094*sin(M6-(double) 2.0*D+G);
        W=W-(double) 0.00092*sin((double) 2.0 * M6-(double) 2.0*D);
        S=W/sqrt(U-V*V);
        i1 = (double) ((double) 1.0 - S*S);
        A5=L+atan(S/sqrt(i1));
        S=V/sqrt(U); 
        i1 = (double) ((double) 1.0 - S*S);
        D5=atan(S/sqrt(i1));
        R5=(double) 60.40974*sqrt(U);
        
        // end
        M[I][1] = A5;
        M[I][2] = D5;
        M[I][3] = R5;
        T += 0.5 ;
    }
    
    if (M[2][1] <= M[1][1]) { M[2][1] += P2 ;}
    if (M[3][1] <= M[2][1]) { M[3][1] += P2 ;}
    Z1 = R1 * ( (double) 90.567 - (double) 41.685 / M[2][3] ) ;    
    S=sin(B5*R1) ; C=cos(B5*R1);
    Z=cos(Z1) ; M8=0 ; W8=0 ; //PRINT
    A0=M[1][1] ; D0=M[1][2] ;
    
    for (f=0; f<24 ; f++) {
        C0 = (double) f;
        P=(C0+1)/24 ;
        F0=M[1][1];
        F1=M[2][1];
        F2=M[3][1];
        
        // 225 - 240
        
        A=F1-F0; B=F2-F1-A ;
        F=F0 + P*( (double) 2.0*A + B*((double) 2.0*P-(double) 1.0) );
        
        A2 = F ;
        F0=M[1][2];
        F1=M[2][2];
        F2=M[3][2];
        
        // 225 - 240
        
        A=F1-F0; B=F2-F1-A ;
        F=F0 + P*( (double) 2.0*A + B*((double)2.0*P-(double)1.0) );
        
        D2=F;
        
        // 285 - 440
        
        //REM  TEST AN HOUR FOR AN EVENT
        L0=T0+C0*K1; L2=L0+K1 ;
        if (A2<A0) { A2=A2+2*P1 ;}
        H0=L0-A0 ; H2=L2-A2 ;
        H1=(H2+H0)/2.0 ; // REM  HOUR ANGLE
        D1=(D2+D0)/2.0 ; // REM  DEC
        if (!f) {V0=S*sin(D0)+C*cos(D0)*cos(H0)-Z ;}
        V2=S*sin(D2)+C*cos(D2)*cos(H2)-Z ;
        
        if (V0==0) i1=0;
        else { i1 = (V0>0) ? 1 : -1 ; }
        
        if (V2==0) i2=0;
        else { i2 = (V2>0) ? 1 : -1 ; }      
        
        if (i1==i2) {A0=A2; D0=D2; V0=V2; continue ;} 
        
        V1=S*sin(D1)+C*cos(D1)*cos(H1)-Z ;
        A=(double) 2.0*V2-(double) 4.0*V1+(double) 2.0*V0; 
        B=(double) 4.0*V1-(double) 3.0*V0 -V2 ;
        D=B*B-(double) 4.0*A*V0;
        if (D<0) {A0=A2; D0=D2; V0=V2; continue ;}
        
        D=sqrt(D);
        
        if ( (V0<0) && (V2>0) ) M8=1;  // Moon Rise 
            
            
        if ( (V0>0) && (V2<0) ) W8=1; // Moon Set
        
        E=(-B+D)/((double) 2.0*A) ;
        if ( (E > 1.0) || (E<0) ) { E=(-B-D) / ((double)2.0*A) ; }
        i1 = (double) 1.0 / 120.0 ;
        T3= C0 + E + i1 ; // REM ROUND OFF
        H3=floor(T3); M3=floor((T3-H3)*(double) 60.0) ;
        //PRINT UsinG "##:##";H3;M3;
        
        if (M8==1 && (!mr)) {
            if (!moon_ord) moon_ord=1;
            mr=1; 
            
            moonrise_M = (int) M3 ;
            moonrise_H = (int) H3 ;
            if (today==euro_edt || today==euro_est) {
            sprintf(moonrise_txt,"Ανατ.Σελήν. %02d:%02d*", moonrise_H, moonrise_M);
            }
            else sprintf(moonrise_txt,"Ανατ. Σελήν. %02d:%02d", moonrise_H, moonrise_M);
            
        }
        if (W8==1 && (!ms) ) {
            if (!moon_ord) moon_ord=2;
            ms=1;
            moonset_M = (int) M3 ;
            moonset_H = (int) H3 ;

            if (today==euro_edt || today==euro_est) {
            sprintf(moonset_txt,"Δύση Σελήν. %02d:%02d*", moonset_H, moonset_M); }
            else sprintf(moonset_txt,"Δύση Σελήν. %02d:%02d", moonset_H, moonset_M);
        }
             
        /*
        H7=H0+E*(H2-H0) ;
        N7=-cos(D1)*sin(H7) ;
        D7=C*sin(D1)-S*cos(D1)*cos(H7);
        A7=atan(N7/D7)/R1;
        if (D7<0) A7=A7+(double) 180.0 ;
        if (A7<0) A7=A7+(double) 360.0 ;
        else if (A7>360.0) A7=A7-(double) 360.0 ;
        // PRINT UsinG ",  AZ ###.#";A7
        // end
        */
        
        A0=A2; D0=D2; V0=V2;
    }
    
    // 450
    
    if ( (!M8) && (!W8) ) {
        moon_ord=1;
        sprintf(moonrise_txt,"Ανατ.Σελήν. -");
        sprintf(moonset_txt,"Δύση Σελήν. -");
    }
    else {
        if (!M8) { // NO MOONRISE THIS DATE
            
            if (date<mo[month]) { dd=date+1; i=month ; diaf=year; }
            else {
                if (month<12) { i = month + 1 ; diaf=year; }
                else { i = 1 ; diaf = year+1 ;}
                dd = 1 ;
            }
            sec_moonrise_moonset( (unsigned short int) diaf , (unsigned short int) i , (unsigned short int) dd , 1);
        }
        else if (!W8) { //NO MOONSET THIS DATE
            if (date<mo[month]) { dd=date+1; i=month ; diaf=year; }
            else {
                if (month<12) { i = month + 1 ; diaf=year; }
                else { i = 1 ; diaf = year+1 ;}
                dd = 1 ;
            }
            sec_moonrise_moonset( (unsigned short int) diaf , (unsigned short int) i , (unsigned short int) dd , 2);
        }
    }
}

void sec_moonrise_moonset(unsigned short int year , unsigned short int month , unsigned short int date, short int search)
{
   
double D1, F, i1, i2, J, S, A, J3, G, T, T0 ;
double L, N, V, U, W, A5, R5, Z1 ,H ;
double C, Z, M8, W8, A0, D0 , C0 ,M6 ;
double L0, L2, A2, H0, H2, H1, V0, V2, V1, E, T3, H3, M3, H7, N7, D7, A7 ;
double D5, P, F0, F1, F2, B, D2 ;
register int f;
short int dd , i ;
unsigned short int today, euro_est , euro_edt ;
int I;
int moonrise_H, moonrise_M , moonset_H , moonset_M ;

union est_edt {
unsigned short int tog;
unsigned char dm[2];
} cur ;


    double Y = (double) year ;
    double Mo = (double) month ;
    double D = (double) date ;

    // 170
    double M[4][4] ;
    double P1=(double) 3.14159265;
    double P2=2*P1 ;
    double R1=P1/180.0 ;
    double K1=(double) 15.0 *R1 * (double) 1.0027379 ;
    
    //  INPUT "LAT, LONG (DEG)";B5,L5
    
    double B5 =  (double) 38.0 + ((double) 2.0 / 60) ; 
    
    double L5 = (double) 23.0 + ((double) 44.0 / 60) ;
    
    // ENTOPISMOS DIAFORAS VRAS
    
    cur.dm[0] = (unsigned char) date;
    cur.dm[1] = (unsigned char) month;
    today = cur.tog ;
    
// Αλλαγή ώρας σε ΘΕΡΙΝΗ στην Ευρώπη : τελευταία Κυριακή Μαρτίου
                    
    cur.dm[1] = 3;
    
    dd = find_dayname(year , 3 , 1);
    for (f=2 ; f<32 ; f++) {
        dd = (dd==7) ? 1 : dd+1 ;
        if (dd==1) { cur.dm[0]= (unsigned char) f; }
    }
    
    euro_edt = cur.tog;
    
// Αλλαγή ώρας σε ΧΕΙΜΕΡΙΝΗ στην Ευρώπη : τελευταία Κυριακή Οκτωβρίου
                    
    cur.dm[1] = 10;
    
    dd = find_dayname(year , 10 , 1);
    for (f=2 ; f<32 ; f++) {
        dd = (dd==7) ? 1 : dd+1 ;
        if (dd==1) { cur.dm[0]= (unsigned char) f; }
    }
    
    euro_est = cur.tog;
    
    // INPUT "TIME ZONE (HRS)";H
    
    if (today>=euro_edt && today<euro_est) H = -3; 
    else H = -2;
           
    L5 = L5/360 ;
    double Z0 = H/24 ;
    
    // 760 - 825 
    G = (double) 1.0 ;
    D1 = floor(D) ;
    F = D-D1-(double) 0.5 ;
    i1 = floor ((double) ((Mo+9)/12)) ;
    i2 = floor ( (double) 7.0*(i1 + Y)/4 ) ;
    J = -i2 ;
    if ((Mo-9)==0) S=0;
    else { S = ((Mo-9) > 0) ? 1 : -1 ; }
    A = fabs (Mo-9);
    i1 = floor(A/7);
    J3 = floor(Y+(S*i1));
    i1 = floor (J3/100) + 1.0 ; 
    J3 = floor (i1*3/4) ;
    J3 = -J3 ;
    i1 = floor ((double)275.0*Mo/9) ;
    J = J + i1 + D1 + G*J3 ;
    J = J + 1721027 + (double) 2.0*G + (double) 367.0*Y ;
    if (F<0) { F=F+1 ; J=J-1 ;}
    
    T=(J-2451545) + F ;
    
    // 245 - 270
    
    T0=T/36525.0 ;
    S=(double) 24110.5+ (double) 8640184.813*T0 ;
    S=S+ (double) 86636.6 * Z0 + (double) 86400.0*L5 ;
    S=S/86400.0 ; S -= floor(S) ;
    T0=S*(double) 360.0*R1 ;
    
    T+=Z0 ;
    
    for (I=1 ; I<4 ; I++) {
        //495-755
    
        L=(double) 0.606434+(double) 0.03660110129*T ;
        M6=(double) 0.374897+(double) 0.03629164709*T ;
        F=(double) 0.259091+(double) 0.03674819520*T ;
        D=(double) 0.827362+(double) 0.03386319198*T;
        N=(double) 0.347343-(double) 0.00014709391*T;
        G=(double) 0.993126+(double) 0.00273777850*T;
        L -= floor(L); M6 -= floor(M6);
        F -= floor(F); D -= floor(D) ;
        N -= floor(N); G -= floor(G) ;
        L=L*P2 ; M6=M6*P2 ; F=F*P2 ;
        D=D*P2 ; N=N*P2 ; G=G*P2 ;
        V=(double) 0.39558*sin(F+N);
        V=V+(double) 0.08200*sin(F);
        V=V+(double) 0.03257*sin(M6-F-N);
        V=V+(double) 0.01092*sin(M6+F+N);
        V=V+(double) 0.00666*sin(M6-F);
        V=V-(double) 0.00644*sin(M6+F-(double) 2.0*D+N);
        V=V-(double) 0.00331*sin(F-(double) 2.0*D+N);
        V=V-(double) 0.00304*sin(F-(double) 2.0*D);
        V=V-(double) 0.00240*sin(M6-F-(double) 2.0*D-N);
        V=V+(double) 0.00226*sin(M6+F);
        V=V-(double) 0.00108*sin(M6+F-(double) 2.0*D);
        V=V-(double) 0.00079*sin(F-N);
        V=V+(double) 0.00078*sin(F+(double) 2.0*D+N);
        U= (double) 1.0 - (double) 0.10828 * cos(M6);
        U=U-(double) 0.01880*cos(M6-(double) 2.0*D);
        U=U-(double) 0.01479*cos((double) 2.0*D);
        U=U+(double) 0.00181*cos((double) 2.0*M6-(double) 2.0*D);
        U=U-(double) 0.00147*cos((double) 2.0*M6);
        U=U-(double) 0.00105*cos((double) 2.0*D-G);
        U=U-(double) 0.00075*cos(M6- (double) 2.0*D + G);
        W=(double) 0.10478*sin(M6);
        W=W-(double) 0.04105*sin((double) 2.0*F + (double) 2.0*N);
        W=W-(double) 0.02130*sin(M6 - (double) 2.0*D);
        W=W-(double) 0.01779*sin((double) 2.0*F + N);
        W=W+(double) 0.01774*sin(N);
        W=W+(double) 0.00987*sin((double) 2.0*D);
        W=W-(double) 0.00338*sin(M6- (double) 2.0*F- (double) 2.0*N);
        W=W-(double) 0.00309*sin(G);
        W=W-(double) 0.00190*sin((double) 2.0*F);
        W=W-(double) 0.00144*sin(M6+N);
        W=W-(double) 0.00144*sin(M6-(double) 2.0*F-N);
        W=W-(double) 0.00113*sin(M6+ (double) 2.0*F + (double) 2*N);
        W=W-(double) 0.00094*sin(M6-(double) 2.0*D+G);
        W=W-(double) 0.00092*sin((double) 2.0 * M6-(double) 2.0*D);
        S=W/sqrt(U-V*V);
        i1 = (double) ((double) 1.0 - S*S);
        A5=L+atan(S/sqrt(i1));
        S=V/sqrt(U); 
        i1 = (double) ((double) 1.0 - S*S);
        D5=atan(S/sqrt(i1));
        R5=(double) 60.40974*sqrt(U);
        
        // end
        M[I][1] = A5;
        M[I][2] = D5;
        M[I][3] = R5;
        T += 0.5 ;
    }
    
    if (M[2][1] <= M[1][1]) { M[2][1] += P2 ;}
    if (M[3][1] <= M[2][1]) { M[3][1] += P2 ;}
    Z1 = R1 * ( (double) 90.567 - (double) 41.685 / M[2][3] ) ;    
    S=sin(B5*R1) ; C=cos(B5*R1);
    Z=cos(Z1) ; M8=0 ; W8=0 ; //PRINT
    A0=M[1][1] ; D0=M[1][2] ;
    
    for (f=0; f<24 ; f++) {
        C0 = (double) f;
        P=(C0+1)/24 ;
        F0=M[1][1];
        F1=M[2][1];
        F2=M[3][1];
        
        // 225 - 240
        
        A=F1-F0; B=F2-F1-A ;
        F=F0 + P*( (double) 2.0*A + B*((double) 2.0*P-(double) 1.0) );
        
        A2 = F ;
        F0=M[1][2];
        F1=M[2][2];
        F2=M[3][2];
        
        // 225 - 240
        
        A=F1-F0; B=F2-F1-A ;
        F=F0 + P*( (double) 2.0*A + B*((double)2.0*P-(double)1.0) );
        
        D2=F;
        
        // 285 - 440
        
        //REM  TEST AN HOUR FOR AN EVENT
        L0=T0+C0*K1; L2=L0+K1 ;
        if (A2<A0) { A2=A2+2*P1 ;}
        H0=L0-A0 ; H2=L2-A2 ;
        H1=(H2+H0)/2.0 ; // REM  HOUR ANGLE
        D1=(D2+D0)/2.0 ; // REM  DEC
        if (!f) {V0=S*sin(D0)+C*cos(D0)*cos(H0)-Z ;}
        V2=S*sin(D2)+C*cos(D2)*cos(H2)-Z ;
        
        if (V0==0) i1=0;
        else { i1 = (V0>0) ? 1 : -1 ; }
        
        if (V2==0) i2=0;
        else { i2 = (V2>0) ? 1 : -1 ; }      
        
        if (i1==i2) {A0=A2; D0=D2; V0=V2; continue ;} 
        
        V1=S*sin(D1)+C*cos(D1)*cos(H1)-Z ;
        A=(double) 2.0*V2-(double) 4.0*V1+(double) 2.0*V0; 
        B=(double) 4.0*V1-(double) 3.0*V0 -V2 ;
        D=B*B-(double) 4.0*A*V0;
        if (D<0) {A0=A2; D0=D2; V0=V2; continue ;}
        
        D=sqrt(D);
        
        if ( (V0<0) && (V2>0) ) M8=1;  // Moon Rise 
            
            
        if ( (V0>0) && (V2<0) ) W8=1; // Moon Set
        
        E=(-B+D)/((double) 2.0*A) ;
        if ( (E > 1.0) || (E<0) ) { E=(-B-D) / ((double)2.0*A) ; }
        i1 = (double) 1.0 / 120.0 ;
        T3= C0 + E + i1 ; // REM ROUND OFF
        H3=floor(T3); M3=floor((T3-H3)*(double) 60.0) ;
        //PRINT UsinG "##:##";H3;M3;
        
        if (M8==1 && (search==1)) {
            
            search=0; 
            
            if (H3>=0 && H3<=6) sprintf(moonrise_txt,"Βλέπε %02d/%02d/%04d", (int) date, (int) month, (int) year);
            else sprintf(moonrise_txt,"Ανατ. Σελήν. -");
            /*
            moonrise_M = (int) M3 ;
            moonrise_H = (int) H3 ;
            
            if (today==euro_edt || today==euro_est) {
            sprintf(moonrise_txt,"Αν.Σελ.(%02d/%02d)->%02d:%02d*", (int) date, (int) month, moonrise_H, moonrise_M);
            }
            else sprintf(moonrise_txt,"Αν.Σελ.(%02d/%02d)->%02d:%02d", (int) date, (int) month, moonrise_H, moonrise_M);
            */
        }
        
        if (W8==1 && (search==2) ) {
            search = 0;
            
            if (H3>=0 && H3<=6) sprintf(moonset_txt,"Βλέπε %02d/%02d/%04d", (int) date, (int) month, (int) year);
            else sprintf(moonset_txt,"Δύση Σελήν. -");
            /*
            moonset_M = (int) M3 ;
            moonset_H = (int) H3 ;

            
            if (today==euro_edt || today==euro_est) {
            sprintf(moonset_txt,"Δύ.Σελ.(%02d/%02d)->%02d:%02d*", (int) date, (int) month, moonset_H, moonset_M);
            }
            else sprintf(moonset_txt,"Δύ.Σελ.(%02d/%02d)->%02d:%02d", (int) date, (int) month, moonset_H, moonset_M);
            */
        }
             
        /*
        H7=H0+E*(H2-H0) ;
        N7=-cos(D1)*sin(H7) ;
        D7=C*sin(D1)-S*cos(D1)*cos(H7);
        A7=atan(N7/D7)/R1;
        if (D7<0) A7=A7+(double) 180.0 ;
        if (A7<0) A7=A7+(double) 360.0 ;
        else if (A7>360.0) A7=A7-(double) 360.0 ;
        // PRINT UsinG ",  AZ ###.#";A7
        // end
        */
        if (!search) break ;
        A0=A2; D0=D2; V0=V2;
    }
    
        if (!search) return ;
        if ( (!M8) && (search==1) ) {
        sprintf(moonrise_txt,"Ανατ. Σελήν. -");
        }
    
        if ( (!W8) && (search==2) ) {
        sprintf(moonset_txt,"Δύση Σελήν. -");
        }
}


void *pro_pedabafont(int pfont , char *fo_file)
{

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;
short int mw ;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

mw=0 ;
//printf ("%s\n",fo_file);
sprintf(file_1,"%sFonts/%s",path_name,fo_file);
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
myfont[pfont][i].who=elem[i].who;
myfont[pfont][i].wid=elem[i].wid;
myfont[pfont][i].hei=elem[i].hei;
myfont[pfont][i].where=mem1+elem[i].alma;
if (mw < elem[i].wid ) mw = elem[i].wid ;
}

myfont_wid[pfont] = mw ;
myfont_hei[pfont] = myfont[pfont][0].hei ;
//if (myfont[pfont][0].wid > (mw/3 - 1) )  myfont[pfont][0].wid = mw/3 - 1 ;

fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font %s load Problem ! \n", fo_file); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}


int fonts_show(int isxfont, char *header, void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon, int *proxchxr, int *proxbkxr , int *proxslxr)
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3];
int chxrep[3] , bkxrep[3] , bkxryes[3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , pano, kato , telos ,sort ,bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , proelem ,c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby;
Uint8 klik;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
int cls_xro[3] ;
short int hfont , hfontm1 , arbox , mahe ;
char kefali [160] ;
unsigned short int curfx,curfy,curfx1,curfy1 ;
int black[3] , white[3] ;

white[0] = white[1] = white[2] = 255 ;
black[0] = 18 ; black[1] = 33 ; black[2] = 48 ; 
cls_xro[0]=31 ; cls_xro[1]=131 ; cls_xro[2]=170 ; mahe=480 ;
hfont = 40 ; hfontm1=hfont-1 ;

    for (f=0;f<3;f++) {
        chxrep[f]=proxchxr[f];
        bkxrep[f]=proxbkxr[f];
        bkxryes[f]=proxslxr[f];
    }
kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[0];
str=mem_str;
plbut=0;    


for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;

i=0; a=0;
for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       but[i++]=mem_str+a;
       a=f+1; 
        }
}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 

f=0;
for (i=0; i<ttf; i++) {
    if (myfont_wid[i]>f) f=myfont_wid[i];
}
i=orio*f;
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,mahe);
mem0=malloc(size); //width x 550
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; 
if (!yt1) yt1=(info.bottom-info.top-(mahe+1) ) / 2 ;
if (yt1) {
    if (yt1+mahe>info.bottom-5) yt1 = info.bottom - mahe -5  ;
}
yt=yt1+19;  yb=yt1+mahe;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,cls_xro[0],cls_xro[1],cls_xro[2]);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);

arbox = ((mahe-83) / hfont) + 1 ;

xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+arbox*hfont+1;
xok=xb-46 ; yok=ysort = ydel = yb-40;
xdel = xtepl+2 ;  
xfrba = (delon) ? xdel+55 : xdel +2 ; 
yfrba = yb-50 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
curfx = xvice + 20 ; curfy = yfrba ; curfx1 = xok-20 ; curfy1 = yb-9 ;
//_areacls (xtepl,ytepl,xtepr,ytepl+(mahe-85),0,89,0);
//_areacls(xtepl,ytepl+(mahe-83),xtepr,ytepr,0,0,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
if (header!=NULL) {
 normtext_tomy (header , kefali);
 _outfanis_center_col(0, kefali , xtepl, yt1+2, xtepr);
}
else {
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+2, xtepr);
}
refresh();

chxr[0]=255 ; chxr[1]=255; chxr[2]=255;
bkxr[0]=30 ; bkxr[1]=30; bkxr[2]=30;
slxr[0]=0; slxr[1]=60; slxr[2]=0;
_bareacls (xtepl,ytepl,xtepr,ytepl+(mahe-83),bkxr);
//_areacls(xtepl,ytepl+(mahe-82),xtepr,ytepr,0,0,0);
_bareacls(xtepl,ytepl+(mahe-82),xtepr,ytepr,black);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

a=0;k=0; a1=plbut; telos=0 ; sort=0;bar=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;
normtext_tomy (myfont_name[isxfont] , str1024) ;
_outmystr_center_col(isxfont,str1024,curfx ,curfy,curfx1,curfy1,white,black);

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ
        _outmystr_center_col(ar_dom[a], but[ar_dom[a]] , xtepl+1 , ytepl+k*hfont , xtepr-1, ytepl+k*hfont+hfontm1,chxr,bkxr);
        a++; a1--;k++;
    
}while (a1 && k<arbox);


if (plbut<arbox) {
setcolor(0);
line(xtepl,ytepl+k*hfont+1,xtepr,ytepl+k*hfont+1);
}
refresh();



c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=0;
protyx=tyx=arbox; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
        if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός arbox επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
       
     tyx=(my-ytepl)/hfont;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 12 χρώματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>(arbox-1) ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==arbox) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1 , ytepl+tyx*hfont , xtepr-1 , ytepl+tyx*hfont+hfontm1,bkxrep);
        _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+tyx*hfont , xtepr-1, ytepl+tyx*hfont+hfontm1,chxrep,bkxrep);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1 , ytepl+tyx*hfont , xtepr-1 , ytepl+tyx*hfont+hfontm1,bkxrep);
       _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+tyx*hfont , xtepr-1, ytepl+tyx*hfont+hfontm1,chxrep,bkxrep);    
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS arbox EPILOGVN
    
    if (protyx!=arbox && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);      
        refresh();
        protyx=arbox;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ονομάτων γραμματοσειρών ή , όχι", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting Font names or , not", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        if (probar) probar=0;
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
    }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (32-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) {
                if (keyb_gr) information (0,"Διαγραφή γραμματοσειράς από τη Μνήμη !",0); else information (0,"Unload a Font from the Memory!",0);
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=arbox) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) ) { // Επιλογή κάποιου από τα arbox κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
            protyx=arbox;
            refresh();
            continue ;
        }
        //el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxryes);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxrep,bkxryes);
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                elem=proelem=-1 ;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);refresh();
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            if (keyb_gr) user_ans=alert(0,"Θέλετε να διαγραφεί η γραμματοσειρά από τη μνήμη ;" ,"Δεν διαγράφεται από το δίσκο !! \nΜπορείτε να τη φορτώσετε ξανά όποτε θέλετε."); else user_ans=alert(0,"Do you want this font to be unloaded?" , "The font remains in the disk !! \n You can reload it any time you want.");
            if (user_ans != 1) continue;
            kati=ar_dom[elem];
            data[0]=255;
            fyge=1;
            // Διαγραφή κάποιου font - Μάλλον return με συγκεκριμένη τιμή
        }
        
        else if (profrba) {
            
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                elem=proelem=-1 ;
            }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+mahe;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+arbox*hfont+1;
            xok=xb-46 ; yok=ysort = ydel = yb-40;
            xdel = xtepl+2 ; 
            xfrba = (delon) ? xdel+55 : xdel+2 ;
            yfrba = yb-50 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;
            bary1=y1 ; bary2=y2;}
            

            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (probar) {
            
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                 elem=proelem=-1 ;
            }

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*arbox); telos+=hfont;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           

        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*arbox) / plbut )+y1;    
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*arbox) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*arbox) / plbut );}
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+arbox-1)>plbut-1) {
            if ( (plbut-arbox)>=0)  { c=plbut-arbox ; telos=arbox;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-(arbox-1))<0 ) { 
            c=arbox-1; telos=arbox; 
            if (plbut<arbox) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           
        _bareacls(xtepl+1, ytepl+k*hfont,xtepr-1,ytepl+k*hfont+hfontm1,bkxr);
        _outmystr_center_col(ar_dom[c], but[ar_dom[c]] , xtepl+1 , ytepl+k*hfont , xtepr-1, ytepl+k*hfont+hfontm1,chxr,bkxr);
        c+=bima ; telos--; k++;
        
    }while (telos && k<arbox);

    if (plbut<arbox) {
    setcolor(0);
    line(xtepl,ytepl+k*hfont+1,xtepr,ytepl+k*hfont+1);
    
    }
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        //if ((!sort) && (pano==a1)) continue;
        //else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                 elem=proelem=-1 ;
            }    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos+=18;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos+=12;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
            }
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos+=(arbox-1);
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos+=16;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*arbox); telos+=hfont;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ytepl+(mahe-83),bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+(arbox-1))>plbut-1) {
                    if ( (plbut-arbox)>=0)  { c=plbut-arbox ; telos=arbox;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-(arbox-1))<0 ) { 
                    c=(arbox-1); telos=arbox; 
                    if (plbut<arbox) {c=plbut-1; telos=plbut; }}}
                    
            pano=c;
            do {                                           

                _outmystr_center_col(ar_dom[c], but[ar_dom[c]] , xtepl+1 , ytepl+k*hfont , xtepr-1, ytepl+k*hfont+hfontm1,chxr,bkxr);
                c+=bima ; telos--; k++;
                
            }while (telos && k<arbox);

            if (plbut<arbox) {
            setcolor(0);
            line(xtepl,ytepl+k*hfont+1,xtepr,ytepl+k*hfont+1);
            
            }
            refresh();
            kato = (sort) ? c+1 : c-1;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;    
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                    data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);  
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if (mem_front) free(mem_front);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return kati ;
}



int _realputicon (int x1,int y1,void *mem1)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co , ba ;

float alfa , enaejoa , nr , ng , nb ,f1 ;

mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    for (f=0;f<height;f++) {
    
        for(i=0 ; i < width; i++) {
            co.lor= *(mem_int++);
    
            if (co.rgb[3]==255) {  
            setcolor (COLOR ( (int) co.rgb[2],(int) co.rgb[1],(int) co.rgb[0] ) );
            }
            
            else if (!co.rgb[3]) {
                continue;
            }
            
            else {
                ba.lor = getpixel (x1+i , y1+f);
                alfa =  ((float)co.rgb[3] / 255.0) ;
                enaejoa = ((float)1.0 - alfa);
                nr = ( (co.rgb[2] * alfa) + (enaejoa * ba.rgb[2]));
                ng = ( (co.rgb[1] * alfa) + (enaejoa * ba.rgb[1]));
                nb = ( (co.rgb[0] * alfa) + (enaejoa * ba.rgb[0]));
                co.rgb[2] = (unsigned char) nr;
                co.rgb[1] = (unsigned char) ng;
                co.rgb[0] = (unsigned char) nb;
                setcolor (COLOR ( (int) co.rgb[2],(int) co.rgb[1],(int) co.rgb[0] ) );     
            }
    
        _putpixel (x1+i,y1+f);
        
        }
    }
        
    return 1;
}


int pers_inp (short int new, short int old , unsigned short int no, unsigned short int uday, unsigned short int umonth, unsigned short int uyear)

// Το ένα να έχει τιμή >=0 και το άλλο -1 !!
// Eπιστρέφει 0 αν δεν γίνει τίποτε !
{
time_t loctim;
struct tm *diar1;
register int f,i ;
short int inpxt, inpyt , inpxb, inpyb ;
short int kinxt ,kinyt ;
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0=0 , *mem_ni=0 , *mem_go=0 , *mem_yes=0, *mem_arrs =0 ,*mem_zer=0 , *mem_tod=0;
short int xb,yb,r1xt,r1yt,r1xb,r1yb,r2xt,r2yt,r2xb,r2yb,bo1xt,bo1yt,bo1xb,bo1yb,bo2xt,bo2yt,bo2xb,bo2yb ;
short int r3xt,r3yt,r3xb,r3yb,r4xt,r4yt,r4xb,r4yb,bo3xt,bo3yt,bo3xb,bo3yb,bo4xt,bo4yt,bo4xb,bo4yb ;
short int r5xt,r5yt,r5xb,r5yb,bo5xt,bo5yt,bo5xb,bo5yb ;
short int todxt, todyt , today=0;
unsigned char what ;
short int yesxt,yesyt,yesxb,yesyb,goxt,goyt,goxb,goyb,arrsxt,arrsyt,dist ;
short int re1=0 , re2=0, re3=0, re4=0 , re5=0 ;
int mx,my,mx1, my1, xt1, yt1, xb1, yb1, fyge=0 , dx ;
unsigned int size ;
unsigned short int ch_scan ;
int choxr_r[3] , choxr_b[3], chobkxr[3] , boxbkxr[3] , boxchxr[3], boxslxr[3], chxrepi[3], bkxrepi[3] ;
int kinchxr[3], kinbkxr[3] , chochxr[3] ;
//unsigned char mystr[1024];
short int loop=1 , ektos=1 , yes=0, cancel=0 , bo1=0 , bo2=0 , marrs=0, inptex=0;
//int inpbkxr[3] , inpchxr[3] , inpslxr[3];
unsigned char mystr1[60], mystr2[60], mystr3[60], mystr4[60] , mystr5[80], dayt[6], montht[6] , yeart[10] ;
short int iday=0, imonth=0 , iyear = 0;
short int mo[13] ;
short int opro[8]; 
char menu_pro[8][120] ;
char keim_pro[50];
short int almx , almy, almx1, almy1 , proeid=0 ;
unsigned char epilogeas [30] ;

struct myepet myg ;

static short int xt,yt ;
static short int fiti;
static short int mobsorton;
short int k,aa,dd,s,pasxa,pasxa_month,pasxa_day ,y ;
int inp_ret;
char *Head1 ;

unsigned short int panel_year , panel_month , panel_day , panel_nameday ;


 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
strcpy (menu_pro[0] , "Χωρίς Προειδοποίηση");
strcpy (menu_pro[1] , "24 ωρών");
strcpy (menu_pro[2] , "48 ωρών");
strcpy (menu_pro[3] , "Τριών ημερών");
strcpy (menu_pro[4] , "Τεσσάρων Ημερών");
strcpy (menu_pro[5] , "Πέντε Ημερών");
strcpy (menu_pro[6] , "Έξι ημερών");
strcpy (menu_pro[7] , "Επτά ημερών");

for (f=0;f<8;f++) { opro[f]=1; }

strcpy (epilogeas,"Ρυθμίστε..");
normtext_tomy (epilogeas,0);

size=imagesize(0,0,999,419);
mem0=malloc(size);
if (!mem0) {information (2-keyb_gr,0,0); goto FYGE;}

chxr[0]=255 ; chxr[1]=255; chxr[2]=255;
bkxr[0]=68 ; bkxr[1]=70; bkxr[2]=71;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
chxrepi[0]=0; chxrepi[1]=0; chxrepi[2]=255;
bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
boxchxr[0]=boxchxr[1]=0 ; boxchxr[2]=255;
boxslxr[0]=255; boxslxr[1]=110; boxslxr[2]=234; 
kinbkxr[0]=kinbkxr[1]=kinbkxr[2]=100;
kinchxr[0]=kinchxr[1]=kinchxr[2]=0 ;
chochxr[0]=0 ; chochxr[1]=0 ; chochxr[2]=200 ; 
montht[0]=255;
dayt[0]=255;
yeart[0]=255;

if (!fiti) {
xt=(info.right-info.left-999) / 2 ; yt=(info.bottom-info.top-419) / 2 ;}
fiti=1;
while ( (xt+999)>info.right-2 ) xt--;
if (yt<info.top) yt=(info.bottom-info.top-419) / 2 ;
while (yt+419 > info.bottom-2) yt--;
xb=xt+999;
yb=yt+419;
getimage(xt,yt,xb,yb,mem0);

mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
mo[4]=mo[6]=mo[9]=mo[11]=30;
mo[2]=28;

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (!mem_arrs) {information(2-keyb_gr,file_1,NULL); goto FYGE;} 


// Yes : 54 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/Yel_ok_39.ico");
mem_yes= icontomem (file_1,255);
if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

// Cancel : 94 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/go_40.ico");
mem_go = icontomem (file_1,255);
if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }


// Ένδειξη "νι-οκ" μέσα σε κουτί 35 Χ 35
strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ni= icontomem (file_1,255);
if (mem_ni==NULL) {information(2-keyb_gr,file_1,NULL); goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_tod = icontomem (file_1,255);
if (mem_tod==NULL) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }


chobkxr[0]=159; chobkxr[1]=155;  chobkxr[2]=116;
choxr_r[0]=0; choxr_r[1]=0;  choxr_r[2]=0;
choxr_b[0]=255; choxr_b[1]=255;  choxr_b[2]=255;
boxbkxr[0]=160 ; boxbkxr[1]=160 ; boxbkxr[2]=0 ; 
whouv=gouv;



_bareacls(xt,yt,xb,yb,chobkxr);
setrgbcolor (dbred) ;
rectangle (xt,yt,xb,yb);
rectangle (xt+1,yt+1,xb-1,yb-1);
setrgbcolor (dbaspro) ;
rectangle (xt+2,yt+2,xb-2,yb-2);
rectangle (xt+3,yt+3,xb-3,yb-3);
setrgbcolor (dbblack) ;
rectangle (xt+4,yt+4,xb-4,yb-4);
rectangle (xt+5,yt+5,xb-5,yb-5);
setrgbcolor (dbyel) ;
rectangle (xt+6,yt+6,xb-6,yb-6);
refresh();

//EPIKEFALIDA

if (new>=0) sprintf (str1024,"Προσθήκη Νέας Ετήσιας Υπόμνησης (No %03d)" , no );
else sprintf (str1024,"Επεξεργασία Υπόμνησης (No %03d)" , no );
normtext_tomy (str1024,0);
_outmystr_center_col(bookman_20n, str1024 , xt+8, yt+7, xb-8, yt+34, chochxr , chobkxr);
i=0;f=0;
gouv=myfont[1];
what=str1024[i];
while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
i= (xb-xt-f+1) / 2 ;
setcolor(4);
line (xt+i, yt+34, xb-i, yt+34);

refresh();
//f=3*70*myfont_wid[4]/4;
i= (xb-xt-950+1) / 2 ;
inpxt=xt+i; inpxb=xb-i;

//inpxt = (short int) _nice_box_clear (4, 70, xt+10, yt+32, xb-8, yb-50, 80,chobkxr,bkxr);
dist = i ; // μετά από μετακίνηση inpxt=xt+dist , inpxb=xb-dist
inpyt = yt+45;
inpyb= inpyt+myfont_hei[notosans_20n]+2;

setcolor(2);
rectangle (inpxt,inpyt,inpxb,inpyb);
rectangle (inpxt-1,inpyt-1,inpxb+1,inpyb+1);
_bareacls (inpxt+1,inpyt+1,inpxb-1,inpyb-1,bkxr);

inpxt=xt+dist , inpxb=xb-dist;
//inpyt = yt+45;
//inpyb= inpyt+myfont_hei[4]+2;
arrsxt = xt+9 ; arrsyt = yt+8 ;
r1xt=xt+14; r1yt=inpyb+20; r1xb=r1xt+600; r1yb=r1yt+40;
r2xt=r1xt; r2yt=r1yb+10; r2xb=r1xb; r2yb=r2yt+40;

r3xt=r1xt; r3yt=r2yb+30; r3xb=r1xb; r3yb=r3yt+40;
r4xt=r1xt; r4yt=r3yb+10; r4xb=r1xb; r4yb=r4yt+40;
r5xt=r1xt; r5yt=r4yb+10; r5xb=r1xb; r5yb=r5yt+40;

bo1xt=r1xb+25; bo1yt=r1yt; bo1xb=bo1xt+40; bo1yb=bo1yt+40;
bo2xt=bo1xt; bo2yt=r2yt; bo2xb=bo2xt+40; bo2yb=bo2yt+40;
bo3xt=bo1xt; bo3yt=r3yt; bo3xb=bo3xt+40; bo3yb=bo3yt+40;
bo4xt=bo1xt; bo4yt=r4yt; bo4xb=bo4xt+40; bo4yb=bo4yt+40;
bo5xt=bo1xt; bo5yt=r5yt; bo5xb=bo5xt+60; bo5yb=bo5yt+40;
almx = bo5xb+20 ; almx1=almx+247;
almy = bo5yt ; almy1 = almy+40 ;

kinxt=bo2xt-100 ; kinyt=bo2yb+6; 

yesxt=xb-85; yesyt=yb-45; yesxb=yesxt+54; yesyb=yesyt+36;
goxt=r1xt+50; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;
todxt = goxb+320 ; todyt = goyt-7 ;

strcpy (mystr1,"Με βάση σταθερή ημερομηνία :");
strcpy (mystr2,"Με βάση κινητή εορτή : ");
strcpy (mystr4,"Μήνας (1-12) : ");
strcpy (mystr3,"Ημερομηνία (1-31) : ");
strcpy (mystr5,"Έτος από το οποίο και μετά θα ισχύει :");
normtext_tomy (mystr1,0);
normtext_tomy (mystr2,0);
normtext_tomy (mystr3,0);
normtext_tomy (mystr4,0);
normtext_tomy (mystr5,0);

refresh();

setrgbcolor (dbblack) ;
rectangle (bo1xt,bo1yt,bo1xb,bo1yb);
rectangle (bo1xt+1,bo1yt+1,bo1xb-1,bo1yb-1);

rectangle (bo2xt,bo2yt,bo2xb,bo2yb);
rectangle (bo2xt+1,bo2yt+1,bo2xb-1,bo2yb-1);

rectangle (bo3xt,bo3yt,bo3xb,bo3yb);
rectangle (bo3xt+1,bo3yt+1,bo3xb-1,bo3yb-1);

rectangle (bo4xt,bo4yt,bo4xb,bo4yb);
rectangle (bo4xt+1,bo4yt+1,bo4xb-1,bo4yb-1);

rectangle (bo5xt,bo5yt,bo5xb,bo5yb);
rectangle (bo5xt+1,bo5yt+1,bo5xb-1,bo5yb-1);

rectangle (almx,almy,almx1,almy1);
rectangle (almx+1,almy+1,almx1-1,almy1-1);

_bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
_bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
_bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
_bareacls (bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxbkxr);
_bareacls (almx+2,almy+2,almx1-2,almy1-2, boxbkxr);

_outmystr_col (neohell_22n, mystr1 , r1xt+12 , r1yt+10 , r1xb-1 ,choxr_b, chobkxr);
_outmystr_col (neohell_22n, mystr2 , r2xt+12 , r2yt+10 , r2xb-1 ,choxr_b, chobkxr);
_outmystr_col (neohell_22n, mystr3 , r3xt+12 , r3yt+10 , r3xb-1 , choxr_b, chobkxr);
_outmystr_col (neohell_22n, mystr4 , r4xt+12 , r4yt+10 , r4xb-1 , choxr_b, chobkxr);
_outmystr_col (neohell_22n, mystr5 , r5xt+12 , r5yt+10 , r5xb-1 , choxr_b, chobkxr);


if (old>=0) {
    mystrcpy (myg.tex , pers[old].tex );
    mystrcpy (myg.ktex , pers[old].ktex );
    _outmystr_center_col (notosans_20n, myg.tex , inpxt, inpyt, inpxb, inpyb, chxr, bkxr) ;
    myg.mob = pers[old].mob;
    myg.arkin = pers[old].arkin;
    myg.when = pers[old].when ;
    myg.alarm = pers[old].alarm ;
    iyear = pers[old].year ;
    
    if (!pers[old].mob) {
        _puticon(bo1xt+3,bo1yt+3,mem_ni,255);
        gsee.tog = pers[old].when;
        iyear = pers[old].year ;
        iday=gsee.dm[0]; imonth=gsee.dm[1];
        sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
        sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
        sprintf(yeart,"%04d",iyear); normtext_tomy(yeart,0);
        _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
        _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
        _outmystr_center_col(5, yeart, bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxchxr,boxbkxr);
        myg.ktex[0]=255;
        bo2=0 ; bo1=1 ;
    }
    else {

    _puticon(bo2xt+3,bo2yt+3,mem_ni,255);
    gsee.tog = pers[old].when;
    iday=gsee.dm[0]; imonth=gsee.dm[1];
    iyear = pers[old].year ;
    sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
    sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
    sprintf(yeart,"%04d",iyear); normtext_tomy(yeart,0);
    _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
    _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
    _outmystr_center_col(5, yeart, bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxchxr,boxbkxr);
    bo2=1 ; bo1=0 ;
    }
     normtext_tomy (menu_pro[myg.alarm] , keim_pro);
    _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
}
else {
//_puticon(bo1xt+3,bo1yt+3,mem_ni,255);

myg.tex[0]=255;
myg.ktex[0]=255;
myg.alarm = 0;
iday=imonth=0;
iyear=uyear;
sprintf(yeart,"%04d",iyear); normtext_tomy(yeart,0);
_bareacls (bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxbkxr);
_outmystr_center_col(5, yeart, bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxchxr,boxbkxr);
refresh();
bo1=0; bo2=0 ;
normtext_tomy (menu_pro[myg.alarm] , keim_pro);
_outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
}

_puticon(yesxt,yesyt,mem_yes,255);
_puticon(goxt,goyt,mem_go,255);
_puticon(arrsxt,arrsyt,mem_arrs,255);
_puticon(todxt,todyt,mem_tod,255);
refresh();

cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 

do {

if (!SDL_PollEvent(&sdlev)) continue;
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        //while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
            if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
        dx=0;
        if (mx>bo1xt && mx<bo1xb && my>bo1yt && my<bo1yb) dx=1;
        else if (mx>r1xt && mx<r1xb && my>r1yt && my<r1yb) dx=1; 
        
        if (dx) {
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (re2) {re2=0; setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); rectangle (r2xt, r2yt , r2xb ,r2yb) ; _outmystr_col (neohell_22n, mystr2 , r2xt+12 , r2yt+10 , r2xb-1 ,choxr_b, chobkxr); hide_help(hdhlpxt , hdhlpyt); refresh();}
            else if (re3) {re3=0; setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); rectangle (r3xt, r3yt , r3xb ,r3yb) ;_outmystr_col (neohell_22n, mystr3 , r3xt+12 , r3yt+10 , r3xb-1 ,choxr_b, chobkxr);  refresh();}
            else if (re4) {re4=0; setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); rectangle (r4xt, r4yt , r4xb ,r4yb) ; _outmystr_col (neohell_22n, mystr4 , r4xt+12 , r4yt+10 , r4xb-1 ,choxr_b, chobkxr); refresh();}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1);refresh ();}
            else if (re5) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re5=0; rectangle (r5xt, r5yt , r5xb ,r5yb) ; _outmystr_col (neohell_22n, mystr5 , r5xt+12 , r5yt+10 , r5xb-1 ,choxr_b, chobkxr); refresh();}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (proeid) {
            proeid=0; 
            setcolor(0);
            rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
            _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
            _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
            refresh();
            }

            
            if (re1) continue ;
            re1=1;
            setcolor(1);
            rectangle (r1xt, r1yt , r1xb ,r1yb) ;
            _outmystr_col (neohell_22n, mystr1 , r1xt+12 , r1yt+10 , r1xb-1 ,choxr_r, chobkxr);
            refresh();
            continue ;
        }
        
        if (re1) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re1=0; rectangle (r1xt, r1yt , r1xb ,r1yb) ; _outmystr_col (neohell_22n, mystr1 , r1xt+12 , r1yt+10 , r1xb-1 ,choxr_b, chobkxr); refresh();}
        
        
        dx=0;
        
        if (mx>bo2xt && mx<bo2xb && my>bo2yt && my<bo2yb) dx=1;
        else if (mx>r2xt && mx<r2xb && my>r2yt && my<r2yb) dx=1;
        
        if (dx) {
        
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (re3) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re3=0; rectangle (r3xt, r3yt , r3xb ,r3yb) ; _outmystr_col (neohell_22n, mystr3 , r3xt+12 , r3yt+10 , r3xb-1 ,choxr_b, chobkxr); refresh();}
            else if (re4) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re4=0; rectangle (r4xt, r4yt , r4xb ,r4yb) ; _outmystr_col (neohell_22n, mystr4 , r4xt+12 , r4yt+10 , r4xb-1 ,choxr_b, chobkxr); refresh();}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1); refresh ();}
            else if (re5) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re5=0; rectangle (r5xt, r5yt , r5xb ,r5yb) ; _outmystr_col (neohell_22n, mystr5 , r5xt+12 , r5yt+10 , r5xb-1 ,choxr_b, chobkxr); refresh();}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (proeid) {
            proeid=0; 
            setcolor(0);
            rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
            _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
            _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
            refresh();
            }

            
            if (re2) continue ;
            re2=1;
            setcolor(1);
            rectangle (r2xt, r2yt , r2xb ,r2yb) ;  
            _outmystr_col (neohell_22n, mystr2 , r2xt+12 , r2yt+10 , r2xb-1 ,choxr_r, chobkxr);
            if ((iday) && (imonth) && (myg.mob) && (myg.ktex[0]!=255)) {
            mytext_tonorm (myg.ktex , str1024, 140);
            show_help(str1024, kinxt, kinyt , &hdhlpxt , &hdhlpyt) ;}
            refresh();
            continue ;
        }

        if (re2) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re2=0; rectangle (r2xt, r2yt , r2xb ,r2yb) ; _outmystr_col (neohell_22n, mystr2 , r2xt+12 , r2yt+10 , r2xb-1 ,choxr_b, chobkxr); hide_help(hdhlpxt , hdhlpyt); refresh();}

        dx=0 ;
        
        if (mx>bo3xt && mx<bo3xb && my>bo3yt && my<bo3yb) dx=1 ;
        else if (mx>r3xt && mx<r3xb && my>r3yt && my<r3yb) dx=1;
        
        
        if (dx) {
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (re4) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re4=0; rectangle (r4xt, r4yt , r4xb ,r4yb) ; _outmystr_col (neohell_22n, mystr4 , r4xt+12 , r4yt+10 , r4xb-1 ,choxr_b, chobkxr); refresh();}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1); refresh ();}
            else if (re5) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re5=0; rectangle (r5xt, r5yt , r5xb ,r5yb) ; _outmystr_col (neohell_22n, mystr5 , r5xt+12 , r5yt+10 , r5xb-1 ,choxr_b, chobkxr); refresh();}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (proeid) {
            proeid=0; 
            setcolor(0);
            rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
            _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
            _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
            refresh();
            }

            
            if (re3) continue ;
            re3=1;
            setcolor(1);
            rectangle (r3xt, r3yt , r3xb ,r3yb) ;  
            _outmystr_col (neohell_22n, mystr3 , r3xt+12 , r3yt+10 , r3xb-1 ,choxr_r, chobkxr);
            refresh();
            continue ;
        }

        if (re3) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re3=0; rectangle (r3xt, r3yt , r3xb ,r3yb) ; _outmystr_col (neohell_22n, mystr3 , r3xt+12 , r3yt+10 , r3xb-1 ,choxr_b, chobkxr); refresh();}

        dx=0;
        
        if (mx>bo4xt && mx<bo4xb && my>bo4yt && my<bo4yb) dx=1;
        else if (mx>r4xt && mx<r4xb && my>r4yt && my<r4yb) dx=1;
        
        if (dx) {
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1); refresh ();}
            else if (re5) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re5=0; rectangle (r5xt, r5yt , r5xb ,r5yb) ; _outmystr_col (neohell_22n, mystr5 , r5xt+12 , r5yt+10 , r5xb-1 ,choxr_b, chobkxr); refresh();}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (proeid) {
            proeid=0; 
            setcolor(0);
            rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
            _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
            _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
            refresh();
            }

            
            if (re4) continue ;
            re4=1;
            setcolor(1);
            rectangle (r4xt, r4yt , r4xb ,r4yb) ;  
            _outmystr_col (neohell_22n, mystr4 , r4xt+12 , r4yt+10 , r4xb-1 ,choxr_r, chobkxr);
            refresh();
            continue ;
        }

        if (re4) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re4=0; rectangle (r4xt, r4yt , r4xb ,r4yb) ; _outmystr_col (neohell_22n, mystr4 , r4xt+12 , r4yt+10 , r4xb-1 ,choxr_b, chobkxr); refresh();}
        

        dx=0;
        
        if (mx>bo5xt && mx<bo5xb && my>bo5yt && my<bo5yb) dx=1;
        else if (mx>r5xt && mx<r5xb && my>r5yt && my<r5yb) dx=1;
        
        if (dx) {
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1); refresh ();}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (proeid) {
            proeid=0; 
            setcolor(0);
            rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
            _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
            _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
            refresh();
            }

            
            if (re5) continue ;
            re5=1;
            setcolor(1);
            rectangle (r5xt, r5yt , r5xb ,r5yb) ;  
            _outmystr_col (neohell_22n, mystr5 , r5xt+12 , r5yt+10 , r5xb-1 ,choxr_r, chobkxr);
            refresh();
            continue ;
        }

        if (re5) {setcolor(COLOR(chobkxr[0],chobkxr[1],chobkxr[2])); re5=0; rectangle (r5xt, r5yt , r5xb ,r5yb) ; _outmystr_col (neohell_22n, mystr5 , r5xt+12 , r5yt+10 , r5xb-1 ,choxr_b, chobkxr); refresh();}
        
        if (mx>almx && mx<almx1 && my>almy && my<almy1) {
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1); refresh ();}
            
            if (proeid) continue ;
            proeid=1;
            setcolor(1);
            rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
            _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,bkxrepi);
            _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, kinchxr, chobkxr);
            refresh();
            continue ;
        }
        
        if (proeid) {
            proeid=0; 
            setcolor(0);
            rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
            _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
            _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
            refresh();
            }
        
        if (mx>inpxt && mx<inpxb && my>inpyt && my<inpyb) {

            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            
            if (inptex) continue ;
            inptex=1;
            setcolor(1);
            rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1);
            refresh();
            continue ;
        }
        
        if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1); refresh ();}
        
        if (mx>yesxt && mx<yesxb && my>yesyt && my<yesyb) {
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            
            if (yes) continue ;
            yes=1;
            putNOTicon(yesxt,yesyt,mem_yes);
            continue ;
        }
        
        if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
        
        
        if (mx>goxt && mx<goxb && my>goyt && my<goyb) {
            
            if (ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ektos=0;
            }
            
            if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (today) {
            today=0;
            puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
            
            if (cancel) continue ;
            cancel=1;
            putNOTicon(goxt,goyt,mem_go);
            continue ;
        }
        
        
        if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
      
    if (mx>arrsxt && mx<arrsxt+18 && my>arrsyt && my<arrsyt+18) {
        
        if (ektos) {
            
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ektos=0;
        }
        
        if (today) {
        today=0;
        puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        marrs=1;
        putNOTicon(arrsxt,arrsyt,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", arrsxt, arrsyt+18 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", arrsxt, arrsyt+18 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        

    if (mx>todxt && mx<todxt+35 && my>todyt && my<todyt+35) { // Today...
        
        if (ektos) {
            
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ektos=0;
        }
        
        if (!today) {
        today=1;
        putNOTicon(todxt,todyt,mem_tod);
        show_help("Αυτόματη ρύθμιση ΣΤΑΘΕΡΗΣ ημερομηνίας..", todxt+45, todyt+16 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (today) {
        today=0;
        puticon(todxt,todyt,mem_tod,255);hide_help(hdhlpxt , hdhlpyt);}
        
        
    // ΤΕΛΟΣ ΤΑ ΠΙΘΑΝΑ ΣΗΜΕΙΑ !!
        if (!ektos) {
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        ektos=1;
        }
        
        break ; // break of SDL_MOUSEMOTION
        
        case SDL_MOUSEBUTTONDOWN:
        
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx1 = sdlev.button.x ; my1= sdlev.button.y ;
            if ( (abs (mx1-mx) > 40) || (abs (my1-my) > 40) ) {
                SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
                continue ;
            }
            
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            
            if (proeid) {
                proeid=0;
                dx=fastmenu_show_opt(8, opro, menu_pro, epilogeas , almx-2, almy-200);
                ektos=1;
                if (dx<0) {
                setcolor(0);
                rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
                _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
                _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
                refresh();
                continue ;
                }
                myg.alarm = (short int) dx ;
                normtext_tomy(menu_pro[myg.alarm] , keim_pro);
                setcolor(0);
                rectangle (almx,almy,almx1,almy1); rectangle(almx+1,almy+1,almx1-1,almy1-1); 
                _bareacls (almx+2,almy+2,almx1-2,almy1-2 ,boxbkxr);
                _outmystr_center_col (neohell_20n, keim_pro , almx+3 , almy+3 , almx1-3 , almy1-3, choxr_b, boxbkxr);
                refresh();
                continue ;
            }
            
            if (marrs) {
            
            xt1=xt;
            yt1=yt;
            xb1=xb;
            yb1=yb;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); continue ;}

            getimage(xt,yt,xb,yb,mem_zer);
            putimage(xt,yt,mem0,0); 
            
            getimage (xt1,yt1,xb1,yb1,mem0);
            
            xt=xt1 ; yt=yt1; xb=xb1; yb=yb1;
            putimage (xt,yt,mem_zer,0);
            free(mem_zer) ; mem_zer=0;
            
            inpxt=xt+dist , inpxb=xb-dist;
            inpyt = yt+45;
            inpyb= inpyt+myfont_hei[notosans_20n]+2;
            arrsxt = xt+9 ; arrsyt = yt+8 ;
            r1xt=xt+14; r1yt=inpyb+20; r1xb=r1xt+600; r1yb=r1yt+40;
            r2xt=r1xt; r2yt=r1yb+10; r2xb=r1xb; r2yb=r2yt+40;
            
            r3xt=r1xt; r3yt=r2yb+30; r3xb=r1xb; r3yb=r3yt+40;
            r4xt=r1xt; r4yt=r3yb+10; r4xb=r1xb; r4yb=r4yt+40;
            r5xt=r1xt; r5yt=r4yb+10; r5xb=r1xb; r5yb=r5yt+40;
            
            bo1xt=r1xb+25; bo1yt=r1yt; bo1xb=bo1xt+40; bo1yb=bo1yt+40;
            bo2xt=bo1xt; bo2yt=r2yt; bo2xb=bo2xt+40; bo2yb=bo2yt+40;
            bo3xt=bo1xt; bo3yt=r3yt; bo3xb=bo3xt+40; bo3yb=bo3yt+40;
            bo4xt=bo1xt; bo4yt=r4yt; bo4xb=bo4xt+40; bo4yb=bo4yt+40;
            bo5xt=bo1xt; bo5yt=r5yt; bo5xb=bo5xt+60; bo5yb=bo5yt+40;
            kinxt=bo2xt-100 ; kinyt=bo2yb+6; 
            almx = bo5xb+20 ; almx1=almx+247;
            almy = bo5yt ; almy1 = almy+40 ;

            yesxt=xb-85; yesyt=yb-45; yesxb=yesxt+54; yesyb=yesyt+36;
            goxt=r1xt+50; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;
            todxt = goxb+320 ; todyt = goyt-7 ;
            refresh();
            continue ;
            }
            
            if (re1) {    // Σταθερή Ημερομηνία (Ναι ή Ακύρωση )
                if (bo1) {
                    bo1=0;
                    iday=imonth=0;
                    _bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
                    //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    dayt[0]=255; montht[0]=255;
                    refresh();
                    continue;
                }
                else if (bo2) {
                    bo2=0;
                    iday=imonth=0;
                    dayt[0]=255; montht[0]=255;
                    _bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    
                }
            
            bo1=1;
            _puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            iday=uday; imonth=umonth; 
            
            if (!iyear) {
                iyear=uyear ;
                sprintf(yeart,"%04d",iyear); normtext_tomy(yeart,0);
                _bareacls (bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxbkxr);
                _outmystr_center_col(5, yeart, bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxchxr,boxbkxr);
            }
            sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
            sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
            
            _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
            _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
            _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
            _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
            refresh();
            myg.ktex[0]=255;
            myg.mob=0 ;
            myg.arkin=0;
            gsee.dm[0]=iday ; 
            gsee.dm[1]=imonth ;
            myg.when= gsee.tog;
            continue ;
            }
        
        
            if (re2) {
                if (bo1) {
                    bo1=0;
                    iday=imonth=0;
                    _bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
                    //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    dayt[0]=255; montht[0]=255;
                }
                else if (bo2) {
                    bo2=0;
                    iday=imonth=0;
                    dayt[0]=255; montht[0]=255;
                    _bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    myg.ktex[0]=255;
                    refresh();
                    myg.mob=0;
                    continue;
                }
            if (!iyear) {
                iyear=uyear ;
                sprintf(yeart,"%04d",iyear); normtext_tomy(yeart,0);
                _bareacls (bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxbkxr);
                _outmystr_center_col(5, yeart, bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxchxr,boxbkxr);
            }
            bo2=1;
            _puticon(bo2xt+3,bo2yt+3,mem_ni,255);
            refresh();
            continue ;
            }
            
            if (re3) { // Κουτί Ημέρας
DAY_BOX :
                if (bo1) {
                    bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,bkxr);
                    gouv=myfont[5];
                    inp_ret=num_input(dayt,bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,2,0);
                    iday=(unsigned short int) convert_str (2,dayt);
                    if (!iday ) dayt[0]=255; 
                    if (imonth) {
                        if (iday>mo[imonth]) iday=mo[imonth] ;
                    }
                    else if (iday>31) iday=31 ;
                    
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    if (iday) {
                    sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
                   _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
                   }
                   myg.mob=0 ;
                   myg.arkin=0;
                   myg.ktex[0]=255;
                   //myg.mom=0; myg.fat=0 ;
                   gsee.dm[0]=iday ; gsee.dm[1]=imonth ;
                   myg.when= gsee.tog;
                   refresh();
                   if (inp_ret==-9) { goto MONTH_BOX ; }
                   continue ;
                }
                if (bo2) {
                    
                    // YPOLOGISMOI KINHTVN EORTVN ME BASH PASXA
                    
                    k=iyear/100 - iyear/400 - 2 ;
                    aa = iyear%19 ;
                    dd=(19*aa+16)%30;
                    s=iyear/4;
                    y=(iyear+s+dd+6)%7;  // (y : 0-6 - Κυριακή = 0 , Δευτέρα =1 ...)
                    pasxa_day = dd+k-4-y ;  // April
                    if (pasxa_day>30) {
                        gsee.dm[1]=pasxa_month=5;
                        pasxa_day-=30;
                        gsee.dm[0]=pasxa_day;
                        pasxa=gsee.tog;
                    }
                    else {
                        gsee.dm[1]=pasxa_month=4;
                        gsee.dm[0]=pasxa_day;
                        pasxa=gsee.tog;
                    }
                                    
                    // Φτιάξιμο κινητών εορτών με βάση ΠΑΣΧΑ
                    
                    for (f=0; f<38; f++) {
                        k1see[f].tog=pasxa;
                        if (an_pasx[f]<0) {
                            for (i=-an_pasx[f] ; i>0 ; i--) {
                                if (k1see[f].dm[0]==1) {
                                    k1see[f].dm[1]--;
                                    k1see[f].dm[0] = mo [k1see[f].dm[1]];
                                }
                                else k1see[f].dm[0]--;
                            }
                        }
                        else {
                            for (i=0; i<an_pasx[f]; i++) {
                                if (k1see[f].dm[0]==mo[ k1see[f].dm[1] ]) {
                                    k1see[f].dm[1]++;
                                    k1see[f].dm[0] = 1;
                                }
                                else k1see[f].dm[0]++;
                            }
                            
                        }
                    }
                    // Αγ. Γεωργίου - 23 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 23 Απρ αλλιώς ΠΑΣΧΑ+1  !
                    f=38;
                    if (pasxa_day>=23 || pasxa_month==5) {
                            k1see[f].tog=pasxa;
                            if (k1see[f].dm[0]==30) {
                                k1see[f].dm[1]++;
                                k1see[f].dm[0] = 1;
                        }
                        else  k1see[f].dm[0]++;
                    }
                    else { k1see[f].dm[0]=23 ; k1see[f].dm[1]=4 ;}
                    
                    // Κυριακή Προπατόρων - 11 Δεκ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 11 Δεκ
                    f=39;
                    k1see[f].dm[1]=12 ;
                    dd = find_dayname(iyear , 12 , 1);
                    for (i=2 ; i<12 ; i++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                    }
                    if (dd!=1) {
                    for (i=12 ; i<25; i++) { 
                        dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { k1see[f].dm[0]=i ; break ; }
                    }}
                    else {k1see[f].dm[0]=11 ;}
                    
                    
                    // Αγία Χλόη - 13 Φεβ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 13 Φεβ
                f=40;
                k1see[f].dm[1]=2 ;
                dd = find_dayname(iyear , 2 , 1);
                for (i=2 ; i<14; i++) { dd = (dd==7) ? 1 : dd+1 ; }
                if (dd!=1) {
                for (i=14 ; i<25; i++) { 
                    dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { k1see[f].dm[0]=i ; break ; }
                }}
                else {k1see[f].dm[0]=13 ;}
                    // Αγίου Μάρκου 25 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 25 Απρ αλλιώς ΠΑΣΧΑ+2  ;
                    f=41;
                    if (pasxa_day>=23 || pasxa_month==5) {
                            k1see[f].tog=pasxa;
                            if (k1see[f].dm[0]==29) {
                                k1see[f].dm[1]++;
                                k1see[f].dm[0] = 1;
                        }
                        else  k1see[f].dm[0]+=2;
                    }
                    else { k1see[f].dm[0]=25 ; k1see[f].dm[1]=4 ;}
                    
                    
                    // Μητέρας
                    
                    dd = find_dayname(iyear , 5 , 1);
                    i = (dd==1) ? 1 : 0; 
                    for (f=2 ; f<16 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if(dd==1) {i++; if(i==2) break;}
                    }
                    gsee.dm[0]=f; gsee.dm[1]=5; mo1_dm=gsee.tog;
                    
                    // Πατέρα
                    
                    dd = find_dayname(iyear , 6 , 1);
                    i = (dd==1) ? 1 : 0; 
                    for (f=2 ; f<24 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if(dd==1) {i++; if(i==3) break;}
                    }
                    gsee.dm[0]=f; gsee.dm[1]=6; fa1_dm=gsee.tog;
                    Head1 = Header ;
                    Header = "Γραμματοσειρά Κινητών Εορτών";
                    dx = mobeortes_show(&mobsorton,0);
                    Header = Head1 ;
                    if (dx<0) continue;
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    
                    myg.year = iyear;
                    
                    if (dx<ar_keo-1) {
                        myg.mob=1;
                        myg.arkin=dx;
                        mystrcpy (myg.ktex,keort[dx]);
                        //myg.mom=0; myg.fat=0 ;
                        myg.when=k1see[dx].tog;
                        iday = k1see[dx].dm[0];
                        imonth = k1see[dx].dm[1];
                    }
                    else if (dx==ar_keo-1) {
                        myg.mob=2;
                        myg.arkin=0;
                        //myg.mom=1 ; myg.fat=0;
                        mystrcpy (myg.ktex,mother);
                        myg.when = mo1_dm;
                        gsee.tog = mo1_dm ;
                        iday = gsee.dm[0];
                        imonth = gsee.dm[1]; 
                    }
                    else {
                        myg.mob=3;
                        myg.arkin=0;
                        //myg.mom=0 ; myg.fat=1;
                        mystrcpy (myg.ktex,father);
                        myg.when = fa1_dm;
                        gsee.tog = fa1_dm ;
                        iday = gsee.dm[0];
                        imonth = gsee.dm[1];
                    }
                    
                    sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
                    sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
                    _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
                    _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
                    
                    refresh();
                    continue ;
                }
                else {
                    sprintf (str1024," Επιλέξατε προηγουμένως Σταθερή ημερομηνία ή Κινητή Εορτή ");
                    show_help (str1024,bo3xt,bo3yb+5, &hdhlpxt , &hdhlpyt) ;
                    continue ;
                }
                
            }
        
            if (re4) { // Κουτί Mήνα
MONTH_BOX :
                if (bo1) {
                    bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,bkxr);
                    gouv=myfont[5];
                    inp_ret=num_input(montht,bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,2,0);
                    imonth=(unsigned short int) convert_str (2,montht);
                    if (!imonth ) montht[0]=255; 
                    if (imonth >12) imonth=12;
                    if ( (iday) && (imonth) && (iday>mo[imonth]) ) {
                        iday = mo[imonth];
                        sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
                        _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                        _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
                    }
                    
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    if (imonth) {
                    sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
                   _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
                   }
                   myg.mob=0 ;
                   myg.arkin=0;
                   myg.ktex[0]=255;
                   //myg.mom=0; myg.fat=0 ;
                   gsee.dm[0]=iday ; gsee.dm[1]=imonth ;
                   myg.when= gsee.tog;
                   refresh();
                   if (inp_ret==-9) goto YEAR_BOX ;
                   continue ;
                }
                               
                if (bo2) {
                    // YPOLOGISMOI KINHTVN EORTVN ME BASH PASXA
                    
                    k=iyear/100 - iyear/400 - 2 ;
                    aa = iyear%19 ;
                    dd=(19*aa+16)%30;
                    s=iyear/4;
                    y=(iyear+s+dd+6)%7;  // (y : 0-6 - Κυριακή = 0 , Δευτέρα =1 ...)
                    pasxa_day = dd+k-4-y ;  // April
                    if (pasxa_day>30) {
                        gsee.dm[1]=pasxa_month=5;
                        pasxa_day-=30;
                        gsee.dm[0]=pasxa_day;
                        pasxa=gsee.tog;
                    }
                    else {
                        gsee.dm[1]=pasxa_month=4;
                        gsee.dm[0]=pasxa_day;
                        pasxa=gsee.tog;
                    }
                                    
                    // Φτιάξιμο κινητών εορτών με βάση ΠΑΣΧΑ
                    
                    for (f=0; f<38; f++) {
                        k1see[f].tog=pasxa;
                        if (an_pasx[f]<0) {
                            for (i=-an_pasx[f] ; i>0 ; i--) {
                                if (k1see[f].dm[0]==1) {
                                    k1see[f].dm[1]--;
                                    k1see[f].dm[0] = mo [k1see[f].dm[1]];
                                }
                                else k1see[f].dm[0]--;
                            }
                        }
                        else {
                            for (i=0; i<an_pasx[f]; i++) {
                                if (k1see[f].dm[0]==mo[ k1see[f].dm[1] ]) {
                                    k1see[f].dm[1]++;
                                    k1see[f].dm[0] = 1;
                                }
                                else k1see[f].dm[0]++;
                            }
                            
                        }
                    }
                    // Αγ. Γεωργίου - 23 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 23 Απρ αλλιώς ΠΑΣΧΑ+1  !
                    f=38;
                    if (pasxa_day>=23 || pasxa_month==5) {
                            k1see[f].tog=pasxa;
                            if (k1see[f].dm[0]==30) {
                                k1see[f].dm[1]++;
                                k1see[f].dm[0] = 1;
                        }
                        else  k1see[f].dm[0]++;
                    }
                    else { k1see[f].dm[0]=23 ; k1see[f].dm[1]=4 ;}
                    
                    // Κυριακή Προπατόρων - 11 Δεκ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 11 Δεκ
                    f=39;
                    k1see[f].dm[1]=12 ;
                    dd = find_dayname(iyear , 12 , 1);
                    for (i=2 ; i<12 ; i++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                    }
                    if (dd!=1) {
                    for (i=12 ; i<25; i++) { 
                        dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { k1see[f].dm[0]=i ; break ; }
                    }}
                    else {k1see[f].dm[0]=11 ;}
                    
                    
                    // Αγία Χλόη - 13 Φεβ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 13 Φεβ
                f=40;
                k1see[f].dm[1]=2 ;
                dd = find_dayname(iyear , 2 , 1);
                for (i=2 ; i<14; i++) { dd = (dd==7) ? 1 : dd+1 ; }
                if (dd!=1) {
                for (i=14 ; i<25; i++) { 
                    dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { k1see[f].dm[0]=i ; break ; }
                }}
                else {k1see[f].dm[0]=13 ;}
                    // Αγίου Μάρκου 25 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 25 Απρ αλλιώς ΠΑΣΧΑ+2  ;
                    f=41;
                    if (pasxa_day>=23 || pasxa_month==5) {
                            k1see[f].tog=pasxa;
                            if (k1see[f].dm[0]==29) {
                                k1see[f].dm[1]++;
                                k1see[f].dm[0] = 1;
                        }
                        else  k1see[f].dm[0]+=2;
                    }
                    else { k1see[f].dm[0]=25 ; k1see[f].dm[1]=4 ;}
                    
                    // Μητέρας
                    
                    dd = find_dayname(iyear , 5 , 1);
                    i = (dd==1) ? 1 : 0; 
                    for (f=2 ; f<16 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if(dd==1) {i++; if(i==2) break;}
                    }
                    gsee.dm[0]=f; gsee.dm[1]=5; mo1_dm=gsee.tog;
                    
                    // Πατέρα
                    
                    dd = find_dayname(iyear , 6 , 1);
                    i = (dd==1) ? 1 : 0; 
                    for (f=2 ; f<24 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if(dd==1) {i++; if(i==3) break;}
                    }
                    gsee.dm[0]=f; gsee.dm[1]=6; fa1_dm=gsee.tog;
                    
                    dx = mobeortes_show(&mobsorton,0);
                    if (dx<0) continue;
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    
                    myg.year = iyear;
                    
                    if (dx<ar_keo-1) {
                        myg.mob=1;
                        myg.arkin=dx;
                        mystrcpy (myg.ktex,keort[dx]);
                        //myg.mom=0; myg.fat=0 ;
                        myg.when=k1see[dx].tog;
                        iday = k1see[dx].dm[0];
                        imonth = k1see[dx].dm[1];
                    }
                    else if (dx==ar_keo-1) {
                        myg.mob=2;
                        myg.arkin=0;
                        //myg.mom=1 ; myg.fat=0;
                        mystrcpy (myg.ktex,mother);
                        myg.when = mo1_dm;
                        gsee.tog = mo1_dm ;
                        iday = gsee.dm[0];
                        imonth = gsee.dm[1]; 
                    }
                    else {
                        myg.mob=3;
                        myg.arkin=0;
                        //myg.mom=0 ; myg.fat=1;
                        mystrcpy (myg.ktex,father);
                        myg.when = fa1_dm;
                        gsee.tog = fa1_dm ;
                        iday = gsee.dm[0];
                        imonth = gsee.dm[1];
                    }
                    
                    sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
                    sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
                    _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
                    _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
                    
                    refresh();
                    continue ;
                }
                else {
                    sprintf (str1024," Επιλέξατε προηγουμένως Σταθερή ημερομηνία ή Κινητή Εορτή ");
                    show_help (str1024,bo4xt,bo4yb+5, &hdhlpxt , &hdhlpyt) ;
                    continue ;
                }
            }
            
            if (re5) { // Κουτί Έτους
YEAR_BOX :
                bareacls (bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,bkxr);
                gouv=myfont[5];
                inp_ret=num_input(yeart,bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,4,0);
                iyear=(unsigned short int) convert_str (4,yeart);
                if (!iyear ) iyear=uyear; 
                if (iyear >2500) iyear=2500;
                if (iyear<2000) iyear=2000;
                bareacls (bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxbkxr);
                
                sprintf(yeart,"%04d",iyear); normtext_tomy(yeart,0);
                _outmystr_center_col(5, yeart, bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxchxr,boxbkxr);
                
                myg.year=iyear;
                
                if (bo2 && iday && imonth) {
                    
                    // YPOLOGISMOI KINHTVN EORTVN ME BASH PASXA
                    
                    k=iyear/100 - iyear/400 - 2 ;
                    aa = iyear%19 ;
                    dd=(19*aa+16)%30;
                    s=iyear/4;
                    y=(iyear+s+dd+6)%7;  // (y : 0-6 - Κυριακή = 0 , Δευτέρα =1 ...)
                    pasxa_day = dd+k-4-y ;  // April
                    if (pasxa_day>30) {
                        gsee.dm[1]=pasxa_month=5;
                        pasxa_day-=30;
                        gsee.dm[0]=pasxa_day;
                        pasxa=gsee.tog;
                    }
                    else {
                        gsee.dm[1]=pasxa_month=4;
                        gsee.dm[0]=pasxa_day;
                        pasxa=gsee.tog;
                    }
                                    
                    // Φτιάξιμο κινητών εορτών με βάση ΠΑΣΧΑ
                    
                    for (f=0; f<38; f++) {
                        k1see[f].tog=pasxa;
                        if (an_pasx[f]<0) {
                            for (i=-an_pasx[f] ; i>0 ; i--) {
                                if (k1see[f].dm[0]==1) {
                                    k1see[f].dm[1]--;
                                    k1see[f].dm[0] = mo [k1see[f].dm[1]];
                                }
                                else k1see[f].dm[0]--;
                            }
                        }
                        else {
                            for (i=0; i<an_pasx[f]; i++) {
                                if (k1see[f].dm[0]==mo[ k1see[f].dm[1] ]) {
                                    k1see[f].dm[1]++;
                                    k1see[f].dm[0] = 1;
                                }
                                else k1see[f].dm[0]++;
                            }
                            
                        }
                    }
                    // Αγ. Γεωργίου - 23 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 23 Απρ αλλιώς ΠΑΣΧΑ+1  !
                    f=38;
                    if (pasxa_day>=23 || pasxa_month==5) {
                            k1see[f].tog=pasxa;
                            if (k1see[f].dm[0]==30) {
                                k1see[f].dm[1]++;
                                k1see[f].dm[0] = 1;
                        }
                        else  k1see[f].dm[0]++;
                    }
                    else { k1see[f].dm[0]=23 ; k1see[f].dm[1]=4 ;}
                    
                    // Κυριακή Προπατόρων - 11 Δεκ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 11 Δεκ
                    f=39;
                    k1see[f].dm[1]=12 ;
                    dd = find_dayname(iyear , 12 , 1);
                    for (i=2 ; i<12 ; i++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                    }
                    if (dd!=1) {
                    for (i=12 ; i<25; i++) { 
                        dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { k1see[f].dm[0]=i ; break ; }
                    }}
                    else {k1see[f].dm[0]=11 ;}
                        
                    
                    // Αγία Χλόη - 13 Φεβ αν είναι Κυριακή αλλιώς την πρώτη Κυριακή μετά τις 13 Φεβ
                f=40;
                k1see[f].dm[1]=2 ;
                dd = find_dayname(iyear , 2 , 1);
                for (i=2 ; i<14; i++) { dd = (dd==7) ? 1 : dd+1 ; }
                if (dd!=1) {
                for (i=14 ; i<25; i++) { 
                    dd = (dd==7) ? 1 : dd+1 ; 
                    if (dd==1) { k1see[f].dm[0]=i ; break ; }
                }}
                else {k1see[f].dm[0]=13 ;}
                    // Αγίου Μάρκου 25 Απρ αν το ΠΑΣΧΑ πέφτει πριν τις 25 Απρ αλλιώς ΠΑΣΧΑ+2  ;
                    f=41;
                    if (pasxa_day>=23 || pasxa_month==5) {
                            k1see[f].tog=pasxa;
                            if (k1see[f].dm[0]==29) {
                                k1see[f].dm[1]++;
                                k1see[f].dm[0] = 1;
                        }
                        else  k1see[f].dm[0]+=2;
                    }
                    else { k1see[f].dm[0]=25 ; k1see[f].dm[1]=4 ;}
                    
                    // Μητέρας
                    
                    dd = find_dayname(iyear , 5 , 1);
                    i = (dd==1) ? 1 : 0; 
                    for (f=2 ; f<16 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if(dd==1) {i++; if(i==2) break;}
                    }
                    gsee.dm[0]=f; gsee.dm[1]=5; mo1_dm=gsee.tog;
                    
                    // Πατέρα
                    
                    dd = find_dayname(iyear , 6 , 1);
                    i = (dd==1) ? 1 : 0; 
                    for (f=2 ; f<24 ; f++) {
                        dd = (dd==7) ? 1 : dd+1 ;
                        if(dd==1) {i++; if(i==3) break;}
                    }
                    gsee.dm[0]=f; gsee.dm[1]=6; fa1_dm=gsee.tog;
                
                    dx = myg.arkin; 
                    
                    _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                    _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                    
                                        
                    if (myg.mob==1) {
                        myg.when=k1see[dx].tog;
                        iday = k1see[dx].dm[0];
                        imonth = k1see[dx].dm[1];
                    }
                    else if (myg.mob==2) {

                        myg.when = mo1_dm;
                        gsee.tog = mo1_dm ;
                        iday = gsee.dm[0];
                        imonth = gsee.dm[1]; 
                    }
                    else if (myg.mob==3) {
                        myg.when = fa1_dm;
                        gsee.tog = fa1_dm ;
                        iday = gsee.dm[0];
                        imonth = gsee.dm[1];
                    }
                    else {refresh(); continue;}
                    
                    sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
                    sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
                    _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
                    _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
                    refresh();
                    continue ;
                }
                
                refresh ();
                if (inp_ret==-9) goto DAY_BOX;
                continue ;
            }
            
            if (today) {    // Σταθερή Ημερομηνία SHMERA 
                // Κλήση της mini χρονομηχανής
                panel_year = uyear ; panel_month = umonth ; panel_day = uday ; panel_nameday = 0;
                today = 0 ;
                puticon(todxt,todyt,mem_tod,255);
                hide_help(hdhlpxt , hdhlpyt);
                ektos=1;
                i=mini_calendar(&panel_year, &panel_month, &panel_day,&panel_nameday);
                if (!i) continue ;
                if (!panel_year) continue ;
                iday= panel_day;
                imonth = panel_month;
                iyear = panel_year;

                bo1=1; bo2=0;
                sprintf(dayt,"%02d",iday); normtext_tomy(dayt,0);
                sprintf(montht,"%02d",imonth); normtext_tomy(montht,0);
                sprintf(yeart,"%04d",iyear); normtext_tomy(yeart,0);
                _bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
                _puticon(bo1xt+3,bo1yt+3,mem_ni,255);
                _bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
                _bareacls (bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxbkxr);
                _bareacls (bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxbkxr);
                _bareacls (bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxbkxr);
                _outmystr_center_col(5, dayt, bo3xt+2,bo3yt+2,bo3xb-2,bo3yb-2,boxchxr,boxbkxr);
                _outmystr_center_col(5, montht, bo4xt+2,bo4yt+2,bo4xb-2,bo4yb-2,boxchxr,boxbkxr);
                _outmystr_center_col(5, yeart, bo5xt+2,bo5yt+2,bo5xb-2,bo5yb-2,boxchxr,boxbkxr);
                myg.ktex[0]=255;
                myg.mob=0 ;
                myg.arkin=0;
                gsee.dm[0]=iday ; 
                gsee.dm[1]=imonth ;
                myg.when= gsee.tog;
                myg.year=iyear;
                refresh ();
                continue ;
                }
            
            if (inptex) {
                bareacls (inpxt+1,inpyt+1,inpxb-1,inpyb-1,bkxr);
                gouv=myfont[notosans_20n];
                text_input(myg.tex,inpxt+1,inpyt+1,inpxb-1,inpyb-1,69);
                _bareacls (inpxt+1,inpyt+1,inpxb-1,inpyb-1,bkxr);
                if (myg.tex[0]!=255) _outmystr_center_col (notosans_20n, myg.tex , inpxt+1, inpyt+1, inpxb-1, inpyb-1, chxr, bkxr) ;
                refresh();
                continue ;
            }
            
            if (yes) {
                if ( (iday) && (imonth) && (iyear) && (myg.tex[0] != 255) ) fyge=1 ;
                else fyge=0;
                if (fyge) {
                    i = (old>=0) ? old : new ; 
                    pers[i].mob = myg.mob;
                    pers[i].arkin = myg.arkin;
                    gsee.dm[0]=iday ; gsee.dm[1]=imonth;
                    pers[i].when = gsee.tog;
                    if (!pers[i].mob) pers1[i] = pers[i].when ;
                    pers[i].year = iyear ;
                    pers[i].alarm = myg.alarm ;
                    mystrcpy_lim (pers[i].tex , myg.tex ,70);
                    mystrcpy_lim (pers[i].ktex , myg.ktex ,70);
                }
                loop=0;
                break ;
            }
            
            if (cancel) {
                fyge=0;
                loop=0;
                break ;
            }
            
        }
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            continue ;
        }
        break ;
        
        case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            ch_scan=sdlev.key.keysym.scancode;
                        
            switch (ch_scan) { 
                        
                case SDL_SCANCODE_ESCAPE :  
                   
                    fyge=0;
                    loop=0;
                    break ;
                    
                case SDL_SCANCODE_RETURN :
                
                if ( (iday) && (imonth) && (iyear) && (myg.tex[0] != 255) ) fyge=1 ;
                else fyge=0;
                if (fyge) {
                    i = (old>=0) ? old : new ; 
                    pers[i].mob = myg.mob;
                    pers[i].arkin = myg.arkin;
                    gsee.dm[0]=iday ; gsee.dm[1]=imonth;
                    pers[i].when = gsee.tog;
                    if (!pers[i].mob) pers1[i] = pers[i].when ;
                    pers[i].year = iyear ;
                    pers[i].alarm = myg.alarm;
                    mystrcpy_lim (pers[i].tex , myg.tex ,70);
                    mystrcpy_lim (pers[i].ktex , myg.ktex ,70);
                }
                loop=0;
                break ;
                
            }
            
        break ;

        case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

        refresh(); 
        continue;
    }
        
} while (loop);

FYGE:

if (mem0) {
    fidicls(xt,yt,xb,yb,55,84,112); 
    putimage (xt,yt,mem0,0);
    refresh();
    free (mem0) ;
}
if (mem_ni) free (mem_ni);
if (mem_go) free (mem_go);
if (mem_yes) free(mem_yes);
if (mem_tod) free(mem_tod);
if (mem_arrs) free(mem_arrs);
if (mem_zer) free (mem_zer) ;

gouv=whouv;
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
return fyge;
}

void My_readimagefile(char *filename, int x, int y)
{
    void * memic = icontomem(filename,255);
    _realputicon (x,y,memic);
    refresh();
}


int alert (int id,char *seleo,char *seleo1)
{
SDL_Cursor* cursor;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start ,wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int size , wid, hei , S ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
int *mem_int;
union {
    unsigned int ltimi ;
    unsigned char rgb[4];
} fa ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;
char file_10 [1024];
float neg, alfa ;
int pev;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chrxr[0]=255;chrxr[1]=10;chrxr[2]=20;
size=imagesize(0,0,399,299);
mem0=malloc(size);
if (!mem0) {printf ("Alert Function - Out of memory !! \n"); return 0;}
x=(info.right-info.left-399) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+399,y+299,mem0);
xp=x;
y1=y+219;
x+=92;
strcpy (file_10,path_name);
strcat (file_10,"ICD/notif_1.ico");
mem_alert=icontomem (file_10,255);
if (! mem_alert) goto DENSEPAIRNEI ;
strcpy (file_10,path_name);
strcat (file_10,"ICD/Alert_sub_1.ico");
mem_menu= icontomem (file_10,255);
if (! mem_menu) goto DENSEPAIRNEI ;

setcolor(14);
rectangle(xp,y,xp+399,y+299);
rectangle(xp+5,y+5,xp+394,y+294);
_areacls (xp+1,y+1,xp+398,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+395,y+5,xp+398,y+298,255,165,0);
_areacls (xp+5,y+295,xp+394,y+298,255,165,0);
cbkxr[0]=159 ; cbkxr[1]=155; cbkxr[2]=116;
_areacls (xp+6,y+6,xp+393,y+293,cbkxr[0],cbkxr[1],cbkxr[2]);

//_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
_realputicon(x,y1,mem_menu);
//x+=18;y1+=7;
chrxr[0]=0;chrxr[1]=0;chrxr[2]=0;

if (!keyb_gr) {
//outnoto_col(xp+155,y+10,"A L E R T",0,chrxr,cbkxr);
//outnoto_col(xp+156,y+10,"A L E R T",0,chrxr,cbkxr);
normtext_tomy ("A L E R T",file_10);
_outmystr_col(bookman_20n,file_10,  xp+156, y+10, xp+380, chrxr, cbkxr);
setcolor (2);
line (xp+145,y+33,xp+265,y+33);
line (xp+150,y+35,xp+260,y+35);
refresh();
}
else {

//outnoto_col(xp+145,y+10,"P R O S O X H",1,chrxr,cbkxr);
//outnoto_col(xp+146,y+10,"P R O S O X H",1,chrxr,cbkxr);
    normtext_tomy ("Π Ρ Ο Σ Ο Χ Η",file_10);
_outmystr_col(bookman_20n,file_10,  xp+156, y+10, xp+380, chrxr, cbkxr);
setcolor (2);
line (xp+135,y+33,xp+320,y+33);
line (xp+140,y+35,xp+315,y+35);
refresh();    
}
xr=xp+392;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! Μπορώ μέχρι και y4+80 (seleo1) (2 γραμμές) .
i=0;f=0;

do {
    what=sfalma[i];
    if (what==255) break ;
    if (what==10) {
        i++; what=sfalma[i]; 
        if (what==10) {
            i++; f++;
            if (f==id) {i+=2;break;}
        }}
       i++;
    } while (what !=255);
    
    
    if (f==id) {
        //chrxr[0]=120;chrxr[1]=181;chrxr[2]=117;
        xc=x2;yc=y2;
        a=i;
        what=sfalma[a];
        
        do {
            if (what==200) { 
                 yc+=16;
                 if (yc>=ymy) break;
                 xc=(yc>=y4) ? x4 : x2 ;
                 a++; what=sfalma[a]; continue;}
                 
        if ((xc+souv[what].wid) > xr) {
            yc+=16;
            if (yc>=ymy) break;
            xc=(yc>=y4) ? x4 : x2 ;}
            
        mem_int1=souv[what].where ;
        for(f=0; f<souv[what].hei ; f++) {
        for(i=0;i<souv[what].wid;i++) {
        co.lor = *mem_int1++;
        if (!co.lor) continue;
        
        // Gia MENA 
        alfa =  ((float)co.rgb[0] / 255) ;
        neg = ((float)1 - alfa);
        red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
        green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
        blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
        
        setcolor(COLOR (red,green,blue));
        _putpixel(xc+i , yc+f);}}
        xc+=souv[what].wid;
        a++; what=sfalma[a];
        } while (what!=40);  // 41 αντιστοιχεί στον χαρακτήρα : '|'  
    }
    
    chrxr[0]=0;chrxr[1]=0;chrxr[2]=0;

    if (!id) ymy=y4 ;
    xc=x4; yc=ymy;
    
    if (seleo!=NULL) {
        size=strlen(seleo);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Alert Function - Out of memory !! \n"); free(mem0); return 0;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==souv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo[f];}}
            
            str[a]=255;
            
           
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                                
                // Gia MENA 
                alfa =  ((float)co.rgb[0] / 255) ;
                neg = ((float)1 - alfa);
                red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
                green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
                blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
                
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
                yc+=16;xc=x4;
    }
    
    if (yc<=y4+80) {
        if (seleo1!=NULL)  {
        size=strlen(seleo1);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Alert Function - Out of memory !! \n"); free(mem0); return 0;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo1[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo1[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo1[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo1[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo1[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==nouv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo1[f];}}
            
            str[a]=255;
                        
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                
                // Gia MENA 
                alfa =  ((float)co.rgb[0] / 255) ;
                neg = ((float)1 - alfa);
                red = (int) ( (alfa * (float)chrxr[0]) + (neg * (float) cbkxr[0]) );
                green = (int) ( (alfa * (float)chrxr[1]) + (neg * (float) cbkxr[1]) );
                blue = (int) ( (alfa * (float)chrxr[2]) + (neg * (float) cbkxr[2]) );
                
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
    }}
    
refresh();
mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;
fa.rgb[3]=255; fa.rgb[0]=fa.rgb[1]=fa.rgb[2]=204;      
S = fa.ltimi ;

        do {
        pev = SDL_PollEvent(&sdlev);
        if (!pev) continue ;
        if (sdlev.type==SDL_WINDOWEVENT) {
            //SDL_FlushEvent(SDL_WINDOWEVENT);
            refresh(); 
            continue;}
        if (sdlev.type==SDL_MOUSEMOTION) {
            if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) {continue ;}
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
        }
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : SDL_FlushEvent(SDL_KEYDOWN); continue;
            }}
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά

        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (180,180,0) ); // ΚΙΤΡΙΝΟ
        mem_efedr1 = mem_menu+ 8 + (x0*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
           fa.ltimi=*mem_int++ ;
           //if ( fa.rgb[3]!=0 && fa.rgb[0]==fa.rgb[1] && fa.rgb[1]==fa.rgb[2] ) printf ("fa.rgb[0]= %d , fa.rgb[3] = %d\n", (int) fa.rgb[0] , (int) fa.rgb[3]) ;
        if (!fa.ltimi) continue;
        if (fa.ltimi!=S) continue ; 
        setcolor ( COLOR (180,180,0) ); 
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (204,204,204) ) ; 
        mem_efedr1 = mem_menu+8+ (x3*wid_box*4) ;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
            fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (180,180,0) );
        mem_efedr1 = mem_menu+8+ (x0*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
            fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (204,204,204) ) ; 
        mem_efedr1 = mem_menu+8+(x3*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
         fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();} 
        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk==1){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,255,255) ) ; 
        mem_efedr1 = mem_menu+8+ (x3*wid_box*4);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid_box-1;i++) {
            fa.ltimi=*mem_int++ ;
        if (!fa.ltimi) continue;
        if (fa.ltimi != S) continue ;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); 
        SDL_Delay(200);
        }
        
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

fidicls(xp, y,xp+399,y+299, 65,80,225);  
DENSEPAIRNEI :
putimage(xp,y,mem0,0);
refresh();
free(mem0);
if (mem_menu) free(mem_menu);
if (mem_alert) free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return((int)kyk);
}


short int _mini_show_month (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth, unsigned short int uday, unsigned short int stamonth)

{
    register int i,f ;
    unsigned short int xb,yb ;
    unsigned short int a , b ;
    int bluedy,reddy ;
    short int mo[13];
    unsigned short int cx[8] , cy[6] ;
    
    union {
        unsigned int olo;
        unsigned char meros[4];
        unsigned short int mewo[2];
    } story ;
    
    char mera [8][8] , monda [32][3] ;
    
    int bluechxr[3] , redchxr[3] , genchxr[3] ;
    int *piobkxr ;
    int genbkxr[3] , bkxrepi[3] ; 
    short int bw , bh ;
    
    bw=32 ; bh = 18 ;
    
    // 4 Okt 1582 τελευταία ημέρα Ιουλιανού - Πέμπτη !
    // 15 Okt 1582 πρώτη ημέρα Γρηγοριανού - Παρασκευή !
    
    if (!uyear || uyear>2500 || uyear<1600 ) return -1;
    
    genchxr[0]=genchxr[1]=genchxr[2]=67;
    genbkxr[0]=231 ; genbkxr[1]= 227; genbkxr[2]=181;
    bluechxr[0] = 67; bluechxr[1] = 67; bluechxr[2] = 229 ;
    bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
    redchxr[0]=160;redchxr[1]=67; redchxr[2]=67;

    
       
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;
    
        
            
        if (uyear%4) mo[2]=28;
        else {
            if (uyear%100) mo[2]=29;
            else {mo[2]=(uyear%400) ? 28 : 29 ;}
            }
    
        
    if (keyb_gr) {

        strcpy (mera[1],"Κυρ");  strcpy (mera[2],"Δευ"); strcpy (mera[3],"Τρι"); strcpy (mera[4],"Τετ");
        strcpy (mera[5],"Πεμ"); strcpy (mera[6],"Παρ"); strcpy (mera[7],"Σαβ"); }
    else {

        strcpy (mera[1],"Sun");  strcpy (mera[2],"Mon"); strcpy (mera[3],"Tue"); strcpy (mera[4],"Wed");
        strcpy (mera[5],"Thu"); strcpy (mera[6],"Fri"); strcpy (mera[7],"Sat"); }
        
       // Στήλες Σαββατοκύριακου έγχρωμες 
    a=stamonth;
    for (f=1; f<8; f++) {
        if (a==1) reddy=f;
        else if (a==7) bluedy=f;
        a++;
        if (a==8) a=1;
        normtext_tomy (mera[f],0);
    }
    
    for (f=1; f<32; f++) {
        sprintf(monda[f],"%d",f);
        normtext_tomy (monda[f],0);
    }
    
    
    // Υπολογισμός cx - cy
    for (i=1 ; i<8 ; i++ ) { cx[i]=xt+(i-1)*bw; }
    xb=xt+(i-1)*bw;
    for (f=0 ; f<6;f++) { cy[f]=yt+f*bh; }
    yb=yt+f*bh;
    
    bareacls (xt,yt,xb,yb,genbkxr);
    
    // ΒΑΣΙΚΗ ΣΧΕΔΙΑΣΗ 
    setrgbcolor(dbaspro);
    rectangle (xt,yt,xb,yb) ;
    
  
        a=0;b=stamonth;
        
        
        for (f=0 ; f<6;f++) {
            setrgbcolor(dbaspro);
            line (cx[1],cy[f],xb,cy[f]);
            for (i=1 ; i<8 ; i++ ) {
                if (!f) {
                    setrgbcolor(dbaspro);
                    line (cx[i],cy[0],cx[i],yb);
                    
                    if (bluedy==i) _outmystr_center_col (notosans_14n,mera[b],cx[i],cy[0],cx[i]+bw-1,cy[1],bluechxr,genbkxr);
                    else if (reddy==i) _outmystr_center_col (notosans_14n,mera[b],cx[i],cy[0],cx[i]+bw-1,cy[1],redchxr,genbkxr);
                    else _outmystr_center_col (notosans_14n,mera[b],cx[i],cy[0],cx[i]+bw-1,cy[1],genchxr,genbkxr);
            
                    b++; if (b==8) b=1 ;
                    continue ;
                    
                }
                
                a++;
                if (a>mo[umonth]) break ;

                if (a==uday) {
                    piobkxr = bkxrepi ;
                    _bareacls (cx[i]+1, cy[f]+1, cx[i]+bw-1, cy[f]+bh-1, piobkxr) ; 
                }
                else {piobkxr=genbkxr;}
                
                if (i==bluedy) _outmystr_center_col (notosans_14n,monda[a],cx[i],cy[f],cx[i]+bw-1,cy[f]+bh,bluechxr,piobkxr);
                else if (i==reddy) _outmystr_center_col (notosans_14n,monda[a],cx[i],cy[f],cx[i]+bw-1,cy[f]+bh,redchxr,piobkxr);
                else _outmystr_center_col (notosans_14n,monda[a],cx[i],cy[f],cx[i]+bw-1,cy[f]+bh,genchxr,piobkxr);
                
            }
        }
    

    setrgbcolor(dbaspro);
    line (cx[1], yb, xb,yb);
    return (0) ;
}


void Rputicon (int x1,int y1,void *mem1 , int *bkxr)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;

float alfa , enaejoa , nr , ng , nb  ;

mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    

    for (f=0;f<height;f++) {
    
        for(i=0 ; i < width; i++) {
            co.lor= *(mem_int++);
    
            if (co.rgb[3]==255) {  
            setcolor (COLOR ( (int) co.rgb[2],(int) co.rgb[1],(int) co.rgb[0] ) );
            }
            
            else if (!co.rgb[3]) {
                continue;
            }
            
            else {
                alfa =  ((float)co.rgb[3] / 255.0) ;
                enaejoa = ((float)1.0 - alfa);
                nr = ( (co.rgb[2] * alfa) + (enaejoa * bkxr[0]) );
                ng = ( (co.rgb[1] * alfa) + (enaejoa * bkxr[1]) );
                nb = ( (co.rgb[0] * alfa) + (enaejoa * bkxr[2]) );
                co.rgb[2] = (unsigned char) nr;
                co.rgb[1] = (unsigned char) ng;
                co.rgb[0] = (unsigned char) nb;
                setcolor (COLOR ( (int) co.rgb[2],(int) co.rgb[1],(int) co.rgb[0] ) );     
            }
    
        _putpixel (x1+i,y1+f);
        
        }
    }
        
    refresh(); 
}



void RNputicon (int x1,int y1,void *mem1 , int *bkxr)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;

float alfa , enaejoa , nr , ng , nb ;

unsigned char ed , en, ue ;

mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    

    for (f=0;f<height;f++) {
        
        for(i=0 ; i < width; i++) {
            
            co.lor= *(mem_int++);
    
            if (co.rgb[3]==255) {  
                ed = ~co.rgb[2]; en = ~co.rgb[1] ; ue = ~co.rgb[0];
                setcolor (COLOR ( (int) ed ,(int) en,(int) ue) );
            }
            
            else if (!co.rgb[3]) {
                continue;
            }
            
            else {
                ed = ~co.rgb[2]; en = ~co.rgb[1] ; ue = ~co.rgb[0];
                //setcolor (COLOR ( (int) bkxr[0], (int) bkxr[1], (int) bkxr[2] ) );
                //_putpixel (x1+i,y1+f);
                alfa =  ((float)co.rgb[3] / 255.0) ;
                enaejoa = ((float)1.0 - alfa);
                nr = ( (ed * alfa) + (enaejoa * bkxr[0]) );
                ng = ( (en * alfa) + (enaejoa * bkxr[1]) );
                nb = ( (ue * alfa) + (enaejoa * bkxr[2]) );
                ed = (unsigned char) nr;
                en = (unsigned char) ng;
                ue = (unsigned char) nb;
                setcolor (COLOR ( (int) ed,(int) en,(int) ue ) );     
            }
    
        _putpixel (x1+i,y1+f);
        
        }
    }
    refresh();    
}


void _Rputicon (int x1,int y1,void *mem1 , int *bkxr)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;

float alfa , enaejoa , nr , ng , nb  ;

mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    

    for (f=0;f<height;f++) {
    
        for(i=0 ; i < width; i++) {
            co.lor= *(mem_int++);
    
            if (co.rgb[3]==255) {  
            setcolor (COLOR ( (int) co.rgb[2],(int) co.rgb[1],(int) co.rgb[0] ) );
            }
            
            else if (!co.rgb[3]) {
                continue;
            }
            
            else {
                alfa =  ((float)co.rgb[3] / 255.0) ;
                enaejoa = ((float)1.0 - alfa);
                nr = ( (co.rgb[2] * alfa) + (enaejoa * bkxr[0]) );
                ng = ( (co.rgb[1] * alfa) + (enaejoa * bkxr[1]) );
                nb = ( (co.rgb[0] * alfa) + (enaejoa * bkxr[2]) );
                co.rgb[2] = (unsigned char) nr;
                co.rgb[1] = (unsigned char) ng;
                co.rgb[0] = (unsigned char) nb;
                setcolor (COLOR ( (int) co.rgb[2],(int) co.rgb[1],(int) co.rgb[0] ) );     
            }
    
        _putpixel (x1+i,y1+f);
        
        }
    }
        
}



void _RNputicon (int x1,int y1,void *mem1 , int *bkxr)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;

float alfa , enaejoa , nr , ng , nb ;

unsigned char ed , en, ue ;

mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    

    for (f=0;f<height;f++) {
        
        for(i=0 ; i < width; i++) {
            
            co.lor= *(mem_int++);
    
            if (co.rgb[3]==255) {  
                ed = ~co.rgb[2]; en = ~co.rgb[1] ; ue = ~co.rgb[0];
                setcolor (COLOR ( (int) ed ,(int) en,(int) ue) );
            }
            
            else if (!co.rgb[3]) {
                continue;
            }
            
            else {
                ed = ~co.rgb[2]; en = ~co.rgb[1] ; ue = ~co.rgb[0];
                //setcolor (COLOR ( (int) bkxr[0], (int) bkxr[1], (int) bkxr[2] ) );
                //_putpixel (x1+i,y1+f);
                alfa =  ((float)co.rgb[3] / 255.0) ;
                enaejoa = ((float)1.0 - alfa);
                nr = ( (ed * alfa) + (enaejoa * bkxr[0]) );
                ng = ( (en * alfa) + (enaejoa * bkxr[1]) );
                nb = ( (ue * alfa) + (enaejoa * bkxr[2]) );
                ed = (unsigned char) nr;
                en = (unsigned char) ng;
                ue = (unsigned char) nb;
                setcolor (COLOR ( (int) ed,(int) en,(int) ue ) );     
            }
    
        _putpixel (x1+i,y1+f);
        
        }
    }
}

int mini_calendar(unsigned short int *panel_year, unsigned short int *panel_month, unsigned short int *panel_day , unsigned short int *panel_nameday)
//Με απλά λόγια, μετά τις 15 Φεβρουαρίου 1923 «εξαφανίστηκαν» 13 ημέρες και ακολούθησε η 1η Μαρτίου 1923.

{

struct tm *diar;
time_t loctim;
SDL_Cursor* cursor;
struct fansouv *trampa;
register int i,f ;
void *mem0=0 , *mem_arrs=0 , *mem_ri=0 , *mem_le=0, *mem_ok=0 , *mem_yes=0, *mem_akyro=0 , *mem_sync=0 ,*mem_move;
char month [13][12] , mera [8][20]  , monda [32][4] ;
unsigned short int caxt , cayt , caxb, cayb , mhnxt, mhnxb ;
short int mhnyt[13] , mhnyb[13] ;
int xb, yb , xt1, yt1 ,mx, my, dx, dy ;
unsigned short int unameday , uday, umonth , uyear , a , b, d, startmonth, nowday, nowyear, nownameday, nowmonth;
int bluedy , reddy ;
unsigned short int cx[8] , cy[6] ;
short int mo[13];
int bluechxr[3] , redchxr[3] , genchxr[3] , bkxrkef[3] , chxrkef[3] , olobkxr[3] ,olochxr [3] ,chxrsel[3], bkxrsel[3] , gkrichxr[3], black[3] ;
int *piobkxr ;
int genbkxr[3] , bkxrepi[3] ; 
unsigned short int movext , moveyt , leyearxt, leyearyt, riyearxt, riyearyt, ledayxt, ledayyt, ridayxt, ridayyt ;
unsigned short int recyearxt, recyearyt , recyearxb, recyearyb ,syncxt, syncyt ;
unsigned short int recshmxt,recshmyt,recshmxb, recshmyb , recfullxt, recfullyt, recfullxb, recfullyb ;
unsigned short int inpyearxt, inpyearyt , inpyearxb, inpyearyb , inpmonthxt, inpmonthyt, inpmonthxb, inpmonthyb ;
unsigned short int inpdayxt, inpdayyt, inpdayxb, inpdayyb , adddaysxt, adddaysyt, adddaysxb, adddaysyb ;
unsigned short int yesxt, yesyt , akyroxt, akyroyt , addokxt, addokyt, putokxt, putokyt ;
unsigned short int marrs=0 , putok=0 , addok=0, finyes=0, akyro=0, inpyear=0, inpmonth=0, inpday=0 ;
unsigned short int panel=0 , leyear=0, leday=0, riyear=0, riday=0 ,adddays=0 , sync=0 ;
unsigned int size , arx_grh, uolo , first_xam, last_xam, arx_diary, tel_diary , arx_2000;
short int ektos=1 , fyge=0 , profyge=0 , box=-1, probox=-1 , monbox=-1, promonbox=-1 , syncyes=0 ;
short int nowon=1 , pronow=0 , specmonth=0 , greg=1 , c ;

unsigned char year_t[10] , month_t[6], day_t[6] , addday_t[12];
unsigned short int prosyear=0, prosmonth=0, prosday=0 ,greday=40, grenameday, gremonth,greyear;
int prosadd=0;
//unsigned char *flddate=0;
//void *memfld=0;
unsigned int gre_xam_1 , gre_xam_t;
short int bw , bh ;

union {
    unsigned int olo;
    unsigned char meros[4];
    unsigned short int mewo[2];
} story ;

static int xt,yt ;
short int imw , imh ;
int etosbkxr[3] , axnochxr[3], ejobkxr[3] , cyan[3];
int bkxr2[3] , chxr2[3] , slxr2[3] ;
unsigned short int ch_scan ;
short int motn ;

    imw=307 ; imh=365;
    bw=32 ; bh = 18 ;
    

    size=imagesize(0,0,imw,imh);
    mem0=malloc(size);
    if (!mem0) {information (2-keyb_gr,0,0);return 0;}
    trampa=gouv;
    for(f=0 ; f<3 ; f++) {
        bkxr2[f]=bkxr[f] ; chxr2[f]=chxr[f] ; slxr2[f]=slxr[f];
    }
    
    year_t[0]=255; month_t[0]=255; day_t[0]=255;addday_t[0]=255;
    
    story.olo=0;
    story.meros[0]=15;
    story.meros[1]=10;
    story.mewo[1]=1582;
    arx_grh=story.olo ;
    
    
    story.olo=0;
    story.meros[0]=5;
    story.meros[1]=10;
    story.mewo[1]=1582;
    first_xam=story.olo ;
        
    story.olo=0;
    story.meros[0]=14;
    story.meros[1]=10;
    story.mewo[1]=1582;
    last_xam=story.olo ;
    
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=1;
    story.mewo[1]=1;
    arx_diary=story.olo ;
    
    story.olo=0;
    story.meros[0]=31;
    story.meros[1]=12;
    story.mewo[1]=2500;
    tel_diary=story.olo ;
    
    story.olo=0;
    story.meros[0]=16;
    story.meros[1]=2;
    story.mewo[1]=1923;
    gre_xam_1=story.olo ;
    
    story.olo=0;
    story.meros[0]=28;
    story.meros[1]=2;
    story.mewo[1]=1923;
    gre_xam_t=story.olo ;
    
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=1;
    story.mewo[1]=2000;
    arx_2000 = story.olo ;
    
    //xt=(unsigned short int) info.left+3 ; yt= (unsigned short int) info.top+3 ;
    if (!xt && !yt) {
    xt=(info.right-info.left-imw) / 2 ; yt=(info.bottom-info.top-imh) / 2 ;}
    else {
        if (xt+imw>info.right-1) xt = info.right-imw-1 ;
        if (yt+imh>info.bottom-1) yt = info.bottom-imh-1;
    }
    xb=xt+imw; yb=yt+imh;
    getimage(xt,yt,xt+imw,yt+imh,mem0);

    axnochxr[0] = 86 ; axnochxr[1] = 110 ; axnochxr[2] = 136 ;


    etosbkxr[0] = 156 ; etosbkxr[1] = 157 ; etosbkxr[2] = 159 ;
    //ejobkxr[0]=159 ; ejobkxr[1]= 155; ejobkxr[2]=116;

    bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
    chxrkef[0]=0 ; chxrkef[1]=0 ; chxrkef[2]=200 ;
    bluechxr[0] = 67; bluechxr[1] = 67; bluechxr[2] = 229 ;
    bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;

    redchxr[0]=160;redchxr[1]=67; redchxr[2]=67;
    genchxr[0]=genchxr[1]=genchxr[2]=67;
    genbkxr[0]=231 ; genbkxr[1]= 227; genbkxr[2]=181;
    
    // olobkxr[0]= 139 ; olobkxr[1]=135 ; olobkxr[2]=96 ;
    olobkxr[0]= 86 ; olobkxr[1]=77 ; olobkxr[2]=60 ;
    olochxr[0]=olochxr[1]=olochxr[2]=255;
    ejobkxr[0]=159 ; ejobkxr[1]= 155; ejobkxr[2]=116;

    chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
    bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;
    gkrichxr[0]=25; gkrichxr[1]=90; gkrichxr[2]=15;
    black[0]=black[1]=black[2]=0;
    cyan[0]=0; cyan[1]=197; cyan[2]=202 ; 
    
    if (keyb_gr) {
        strcpy (month[1],"Ιαν."); strcpy (month[2],"Φεβ."); strcpy (month[3],"Μαρ."); strcpy (month[4],"Απρ.");
        strcpy (month[5],"Μάι."); strcpy (month[6],"Ιούν."); strcpy (month[7],"Ιούλ."); strcpy (month[8],"Αύγ.");
        strcpy (month[9],"Σεπ."); strcpy (month[10],"Οκτ."); strcpy (month[11],"Νοε."); strcpy (month[12],"Δεκ.");

        strcpy (mera[1],"Κυριακή");  strcpy (mera[2],"Δευτέρα"); strcpy (mera[3],"Τρίτη"); strcpy (mera[4],"Τετάρτη");
        strcpy (mera[5],"Πέμπτη"); strcpy (mera[6],"Παρασκευή"); strcpy (mera[7],"Σάββατο"); }
    else {
        strcpy (month[1],"Jan."); strcpy (month[2],"Feb."); strcpy (month[3],"Mar."); strcpy (month[4],"Apr.");
        strcpy (month[5],"Mai"); strcpy (month[6],"Jun"); strcpy (month[7],"July"); strcpy (month[8],"Aug.");
        strcpy (month[9],"Sep."); strcpy (month[10],"Oct."); strcpy (month[11],"Nov."); strcpy (month[12],"Dec.");

        strcpy (mera[1],"Sunday");  strcpy (mera[2],"Monday"); strcpy (mera[3],"Tuesday"); strcpy (mera[4],"Wednesday");
        strcpy (mera[5],"Thursday"); strcpy (mera[6],"Friday"); strcpy (mera[7],"Saturday"); }
        
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;
    
    for (f=1; f<32; f++) {
        sprintf(monda[f],"%d",f);
        normtext_tomy (monda[f],0);
    }
    
    
    // ΣΥΝΤΕΤΑΓΜΕΝΕΣ
    //recfullxt = xt+25 ;
    leyearxt=recfullxt=xt+30;
    ledayxt=xt+50;
    movext=caxt=xt+6 ;
    inpyearxt=xt+25;
    moveyt=yt+4; // Επικεφαλίδα στο yt+4 επίσης!
    //recfullyt=yt+33;
    recfullyt=yt+4;
    recfullyb=recfullyt+20;
    leyearyt=riyearyt=recyearyt=mhnyb[0]=recfullyb+8;
    mhnyb[0]-=1;
    recyearxt=leyearxt+25;
    recshmxt=ledayxt+25;
    //recfullxb=xb-15;
    recyearyb=recyearyt+20;
    ledayyt=ridayyt=recshmyt=recyearyb+4;
    recshmyb=recshmyt+20;
    cayt=recshmyb+9;
    
    // Υπολογισμός cx - cy
    for (i=1 ; i<8 ; i++ ) { cx[i]=caxt+(i-1)*bw; }
    caxb=caxt+(i-1)*bw;
    for (f=0 ; f<6;f++) { cy[f]=cayt+f*bh; }
    cayb=cayt+f*bh;

    ridayxt=caxb-76;
    riyearxt=caxb-56;
    recfullxb = riyearxt+20;
    recyearxb=riyearxt-4 ;
    recshmxb=ridayxt-4 ;
    inpyearxb=inpyearxt+60;
    inpmonthxt=inpyearxb+21; inpmonthxb=inpmonthxt+30;
    inpdayxt=inpmonthxb+18; inpdayxb=inpdayxt+30;
    inpyearyt = inpmonthyt = inpdayyt = cayb+40;
    // ENDIAMESA NA GRAFEI KATI....
    inpyearyb=inpmonthyb=inpdayyb=inpdayyt+20;
    putokxt=inpdayxb+7; putokyt = inpdayyt-4;
    // ENDIAMESA NA GRAFEI KATI....
    adddaysxt=xt+70; adddaysyt=inpyearyb+40;
    adddaysxb=adddaysxt+90;
    adddaysyb=adddaysyt+20;
    addokxt=adddaysxb+7; addokyt=adddaysyt-4 ;
    yesxt = xb-50 ; yesyt = adddaysyb+17;
    akyroxt = xt+15; akyroyt = adddaysyb+17;
    syncxt = xt+150 ; syncyt = akyroyt;
    
    
    // RECTANGLES
    setcolor(5);
    rectangle (xt,yt,xb,yb);
    setcolor(2);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setcolor(5);
    rectangle (xt+2,yt+2,xb-2,yb-2);
    //setcolor(5);
    //line (xt+3,yt+29,xb-3,yt+29) ; // Γραμμή Επικεφαλίδας
    //_bareacls (xt+4 , yt+3 , xb-4 , yt+28, bkxrkef);
    //if (keyb_gr) strcpy (str1024,"Η Μ Ε Ρ Ο Λ Ο Γ Ι Ο") ;
    //else strcpy (str1024,"C A L E N D A R");
    //normtext_tomy (str1024,0);
    //_outmystr_center_col (6,str1024,xt+4,yt+4,xb-4,yt+29,chxrkef, bkxrkef);
    
    // ΓΕΜΙΣΜΑ ΚΑΤΩ ΑΠΟ ΕΠΙΚΕΦΑΛΙΔΑ ΟΛΟ ΤΟ ΧΩΡΟ
    _bareacls(xt+3,yt+3,xb-3,yb-3,olobkxr);
    // ΠΛΗΡΗΣ ΗΜΕΡΟΜΗΝΙΑ
    setcolor(3);
    rectangle (recfullxt , recfullyt , recfullxb , recfullyb);
    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1 , bkxrepi);
    
    //kext=recyearxt+((recyearxb-recyearxt)/2);
    //keyt=recfullyb+2;
    /*
    setrgbcolor(dbred);
    while(keyt<recyearyt){
        line(recyearxt,recyearyt,kext,keyt);
        line(kext,keyt,recyearxb,recyearyt);
        keyt++;
    }
    refresh();
    */
    // ΗΜΕΡΟΜΗΝΙΑ ΣΥΣΤΗΜΑΤΟΣ
    loctim=time(NULL);
    diar=localtime(&loctim);
    unameday=diar->tm_wday+1;
    uday= diar->tm_mday;
    umonth = diar->tm_mon+1;
    uyear = diar->tm_year+1900;
    strcpy (mera[0],mera[unameday]);
    
    
   
    if (uyear%4) mo[2]=28;
    else {
        if (uyear%100) mo[2]=29;
        else {mo[2]=(uyear%400) ? 28 : 29 ;}
    }
    
   
    startmonth=unameday+1;
    if (startmonth==8) startmonth=1;
    for (f=uday ; f>0 ; f--){
        startmonth--;
        if (!startmonth) startmonth=7;
    }

    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
    normtext_tomy(str1024,0);
    _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
    
    // ΕΤΟΣ - ΣΗΜΕΡΑ
    setrgbcolor(dbred);
    rectangle (recyearxt-1,recyearyt-1,recyearxb+1,recyearyb+1);
    setrgbcolor(dbaspro);
    rectangle (recyearxt,recyearyt,recyearxb,recyearyb);
    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
    sprintf (str1024,"%04u",uyear);
    normtext_tomy(str1024,0);
    _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
    
    setrgbcolor(dbaspro);
    rectangle (recshmxt,recshmyt,recshmxb,recshmyb);
    _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
    if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
    else strcpy(str1024,"TODAY");
    normtext_tomy(str1024,0);
    _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
    
    refresh() ;
    
    // ΠΑΝΕΛ
    _mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
    
        a=startmonth;
    for (f=1; f<8; f++) {
        if (a==1) reddy=f;
        else if (a==7) bluedy=f;
        a++;
        if (a==8) a=1;
    }
    
    // ΜΕΤΑΒΑΣΗ
    setrgbcolor(dbaspro);
    rectangle (caxt,cayb+5,caxb,inpyearyb+4);
    if (keyb_gr) strcpy(str1024,"ΑΝΑΖΗΤΗΣΗ");
    else strcpy(str1024,"GO TO");
    normtext_tomy(str1024,0);
    _outmystr_center_col(bookman_14n,str1024,caxt+20,cayb+3,caxb-20,cayb+22,cyan,olobkxr);
    
    setcolor (COLOR((int) bluechxr[0],(int) bluechxr[1],(int) bluechxr[2]+20 ));
    line (caxt+50,cayb+19,caxb-50,cayb+19);
    if (keyb_gr) strcpy(str1024,"Έτος");
    else strcpy(str1024,"Year");
    normtext_tomy(str1024,0);
    _outmystr_center_col(neohell_13b,str1024,inpyearxt,cayb+20,inpyearxb,cayb+40,olochxr,olobkxr);
    if (keyb_gr) strcpy(str1024,"Μήνας");
    else strcpy(str1024,"Month");
    normtext_tomy(str1024,0);
    _outmystr_center_col(neohell_13b,str1024,inpmonthxt-10 ,cayb+20,inpmonthxb+10 ,cayb+40,olochxr,olobkxr);
    if (keyb_gr) strcpy(str1024,"Ημέρα");
    else strcpy(str1024,"Day");
    normtext_tomy(str1024,0);
    _outmystr_center_col(neohell_13b,str1024,inpdayxt-15,cayb+20,inpdayxb+15,cayb+40,olochxr,olobkxr);
    
    
    //if (keyb_gr) strcpy(str1024,"ΕΤΟΣ      ΜΗΝΑΣ  ΗΜΕΡΑ");
    //else strcpy(str1024,"YEAR      MONTH  DAY");
    //normtext_tomy(str1024,0);
    //_outmystr_center_col(bookman_16n,str1024,caxt+6,cayb+33,caxb-6,cayb+58,olochxr,olobkxr);
    //line (inpyearxt+10,inpyearyt-12,inpdayxb+13,inpyearyt-12);
    //line (inpyearxt+10,inpyearyt-11,inpdayxb+13,inpyearyt-11);
    setrgbcolor(dbaspro);
    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
    
    
    // ΠΡΟΣΘΑΦΑΙΡΕΣΗ
    setrgbcolor(dbaspro);
    rectangle (caxt,inpyearyb+8,caxb,adddaysyb+5);
    if (keyb_gr) strcpy(str1024,"Προσθαφαίρεση Ημερών");
    else strcpy(str1024,"Add/Subtract Days");
    normtext_tomy(str1024,0);
    _outmystr_center_col(bookman_14n,str1024,caxt+6,inpyearyb+10,caxb-6,inpyearyb+35,cyan,olobkxr);
    setrgbcolor(dbaspro);
    rectangle (adddaysxt,adddaysyt,adddaysxb,adddaysyb);
    setcolor (COLOR((int) bluechxr[0],(int) bluechxr[1],(int) bluechxr[2]+20 ));
    line (caxt+20,inpyearyb+28,caxb-20,inpyearyb+28);
    
    // ΜΗΝΕΣ
    mhnxt=caxb+10;
    mhnxb=mhnxt+60;
    for (f=1; f<13 ; f++) {
        normtext_tomy (month[f],0);
        mhnyt[f]=mhnyb[f-1]+4;
        mhnyb[f] = mhnyt[f]+20;
        setrgbcolor(dbaspro);
        rectangle (mhnxt,mhnyt[f],mhnxb,mhnyb[f]);
        if (f!=umonth) _outmystr_center_col(arial_12,month[f],mhnxt,mhnyt[f]+1,mhnxb,mhnyb[f],olochxr,olobkxr);
        else {
            _bareacls(mhnxt+1,mhnyt[f]+1,mhnxb-1,mhnyb[f]-1,bkxrepi);
            _outmystr_center_col(arial_12,month[f],mhnxt,mhnyt[f]+1,mhnxb,mhnyb[f],bluechxr,bkxrepi);
        }
    }
    
    refresh();
    //memfld = malloc(26);
    //if(!memfld) goto FYGE;
    //flddate=memfld;
    
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/hand_17.ico");
    mem_arrs=icontomem(file_1,255);
    if (mem_arrs==NULL) {information(2-keyb_gr,file_1,NULL); goto FYGE;} 
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_right_2020.ico");
    mem_ri = icontomem (file_1,255);
    if (!mem_ri) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_left_2020.ico");
    mem_le = icontomem (file_1,255);
    if (!mem_le) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // Ένα "ν" δίπλα στην δοθείσα ημερομηνία !
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Search_2020.ico");
    mem_ok= icontomem (file_1,255);
    if (mem_ok==NULL) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // YES !!! Περνάει την ημερομηνία
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Yes_3221.ico");
    mem_yes= icontomem (file_1,255);
    if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_5421.ico");
    mem_akyro = icontomem (file_1,255);
    if (!mem_akyro) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/sync_2121.ico");
    mem_sync = icontomem (file_1,255);
    if (!mem_sync) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    // ΕΙΚΟΝΙΔΙΑ
    _puticon(movext,moveyt,mem_arrs,255);
    _realputicon(leyearxt,leyearyt,mem_le);
    _realputicon(ledayxt,ledayyt,mem_le);
    _realputicon(riyearxt,riyearyt,mem_ri);
    _realputicon(ridayxt,ridayyt,mem_ri);
    _realputicon(putokxt,putokyt,mem_ok);
    _realputicon(addokxt,addokyt,mem_ok);
    _realputicon(yesxt,yesyt,mem_yes);
    _realputicon(akyroxt,akyroyt,mem_akyro);
    
    syncyes=1; _realputicon(syncxt,syncyt,mem_sync);
    
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
    d=0;

    do {

        if (!SDL_PollEvent(&sdlev)) continue;

        switch (sdlev.type) {
            
            case SDL_MOUSEMOTION:
                
                //while ( (SDL_PollEvent(&sdlev)) && (sdlev.type==SDL_MOUSEMOTION) ) continue ;    
                if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) {
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                continue;
                }
                
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                SDL_FlushEvent(SDL_MOUSEMOTION);
                if (mx<info.left || my<info.top) continue ;
        
                if (mx>caxt && mx<caxb && my>cayt && my<cayb) { // into Panel
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (promonbox!=-1) {
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                        line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                        refresh();
                        promonbox=monbox=-1;
                    }
                    else if (inpyear) {
                        inpyear=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                        refresh();
                    }
                    else if (inpmonth) {
                        inpmonth=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                        refresh();
                    }
                    else if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; Rputicon(leyearxt,leyearyt,mem_le,olobkxr); }
                    else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                    else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    
    
                    if (!panel) {
                        panel=1;
                        setrgbcolor(dbmag);
                        rectangle (caxt,cayt,caxb,cayb);
                        refresh();
                    }
                    if (my<cy[1]) box=-1;
                    else {
                    dx=(mx-caxt)/bw; dy=(my-cy[1])/bh;
                    box=(dy*7)+dx+1;}
                    
                    if (box==probox) continue ;
                    if (!specmonth){
                        if (probox!=-1) {
                            a=(probox/7)+1 ; b=probox%7 ;
                            if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                            if (probox!=uday) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);    
                            }
                            else {
                            setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);    
                            }
                            refresh();
                        }
                        if (box>mo[umonth] || box==-1) {box=probox=-1;continue;}
                        //if (box!=uday) setrgbcolor(dbyel); else setrgbcolor(dbblack);
                        if (box!=uday) setcolor (COLOR(ejobkxr[0],ejobkxr[1],ejobkxr[2])); else setrgbcolor(dbblack);
                        rectangle (cx[dx+1]+1,cy[dy+1]+1,cx[dx+1]+bw-1,cy[dy+1]+bh-1);
                        rectangle (cx[dx+1]+2,cy[dy+1]+2,cx[dx+1]+bw-2,cy[dy+1]+bh-2);
                        refresh();
                        probox=box;
                        continue;
                    }
                    else { // specmonth=1 - Okt 1582

                        if (probox!=-1) {
                            
                            a=(probox/7)+1 ; b=probox%7 ;
                            if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                            c=(probox<5) ? 0 : 4 ;
                            
                            if (probox!=uday+c) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);    
                            }
                            else {
                            setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);    
                            }
                            
                            refresh();
                        }
                        if (box>4 && box<19) {box=probox=-1;continue;}
                        if (box==-1) {box=probox=-1;continue;}
                        c=(box<5) ? 0 : 4 ;
                        //if (box!=uday+c) setrgbcolor(dbyel); else setrgbcolor(dbblack);
                        if (box!=uday+c) setcolor (COLOR(ejobkxr[0],ejobkxr[1],ejobkxr[2])); else setrgbcolor(dbblack);
                        rectangle (cx[dx+1]+1,cy[dy+1]+1,cx[dx+1]+bw-1,cy[dy+1]+bh-1);
                        rectangle (cx[dx+1]+2,cy[dy+1]+2,cx[dx+1]+bw-2,cy[dy+1]+bh-2);
                        refresh();
                        probox=box;
                        
                    }
                    continue ;
                }
                
                if (panel) {
                    panel=0;
                    setrgbcolor(dbaspro);
                    rectangle (caxt,cayt,caxb,cayb);
                    if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                    else c=0;
                    if (probox!=-1) {
                        a=(probox/7)+1 ; b=probox%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        if (probox!=uday+c) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);
                        }
                        else {
                            setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);
                        }
                        box=probox=-1;
                    }
                    refresh();
                }
                
                if (mx>mhnxt && mx<mhnxb && my>mhnyt[1] && my<mhnyb[12]) { // into 12 months
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (inpyear) {
                        inpyear=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                        refresh();
                    }
                    else if (inpmonth) {
                        inpmonth=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                        refresh();
                    }
                    else if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                    else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                                        
                    monbox=((my-mhnyt[1])/24) + 1;
                    if (monbox>12) monbox=12;
                    if (promonbox==monbox) continue ;
                    if (promonbox!=-1) {
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                        line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                    }
                    setrgbcolor(dbmag);
                    rectangle (mhnxt,mhnyt[monbox],mhnxb,mhnyb[monbox]);
                    line(mhnxt-1,mhnyt[monbox]+1,mhnxt-1,mhnyb[monbox]+1);
                    line(mhnxt-1,mhnyb[monbox]+1,mhnxb,mhnyb[monbox]+1);
                    promonbox=monbox;
                    refresh();
                    continue;
                }
                
                if (promonbox!=-1) {
                    setrgbcolor(dbaspro);
                    rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                    line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                    refresh();
                    promonbox=monbox=-1;
                }                
                

                if (mx>inpyearxt && mx<inpyearxb && my>inpyearyt && my<inpyearyb) { // into inpyear
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                if (inpmonth) {
                    inpmonth=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                }
                else if (inpday) {
                    inpday=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                }
                else if (adddays) {
                    adddays=0;
                    setrgbcolor(dbaspro);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                }
                else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                   
                    
                    if (inpyear) continue;
                    inpyear=1;
                    setrgbcolor(dbmag);
                    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                    rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpyear) {
                    inpyear=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                    refresh();
                }
                
                
                if (mx>inpmonthxt && mx<inpmonthxb && my>inpmonthyt && my<inpmonthyb) { // into inmonth
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                    else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    
                    
                    if (inpmonth) continue;
                    inpmonth=1;
                    setrgbcolor(dbmag);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpmonth) {
                    inpmonth=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                }
                
                
                if (mx>inpdayxt && mx<inpdayxb && my>inpdayyt && my<inpdayyb) { // into inpday
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                    else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                   
                    
                    if (inpday) continue;
                    inpday=1;
                    setrgbcolor(dbmag);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpday) {
                    inpday=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                }
                
                
                if (mx>adddaysxt && mx<adddaysxb && my>adddaysyt && my<adddaysyb) { // into adddays
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                    else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                   
                    
                    if (adddays) continue;
                    adddays=1;
                    setrgbcolor(dbmag);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (adddays) {
                    adddays=0;
                    setrgbcolor(dbaspro);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                }
                

                if (mx>movext && mx<movext+17 && my>moveyt && my<moveyt+17) { // move window
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                    else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                
                    
                    if (marrs) continue ;
                    marrs=1;
                    putNOTicon(movext,moveyt,mem_arrs);
                    if (keyb_gr) show_help (" Αλλαγή Θέσης Παραθύρου ",movext,moveyt+18,&hdhlpxt , &hdhlpyt);
                    else show_help (" Change Window Position ",movext,moveyt+20,&hdhlpxt , &hdhlpyt);
                    continue ;
                }
        
                if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }


                if (mx>leyearxt && mx<leyearxt+20 && my>leyearyt && my<leyearyt+20) { // Left Year
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                    else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                
                    
                    if (leyear) continue ;
                    leyear=1;
                    RNputicon(leyearxt,leyearyt,mem_le,olobkxr);
                    continue ;
                }
        
                if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                
                
                if (mx>riyearxt && mx<riyearxt+20 && my>riyearyt && my<riyearyt+20) { // Right Year
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                    else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
            
                    
                    if (riyear) continue ;
                    riyear=1;
                    RNputicon(riyearxt,riyearyt,mem_ri,olobkxr);
                    continue ;
                }
        
                if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
                
                
                if (mx>ledayxt && mx<ledayxt+20 && my>ledayyt && my<ledayyt+20) { // Left day
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                    else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
               
                                        
                    if (leday) continue ;
                    leday=1;
                    RNputicon(ledayxt,ledayyt,mem_le,olobkxr);
                    continue ;
                }
        
                if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
                
                
                if (mx>ridayxt && mx<ridayxt+20 && my>ridayyt && my<ridayyt+20) { // Right day
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                                                            
                    if (riday) continue ;
                    riday=1;
                    RNputicon(ridayxt,ridayyt,mem_ri,olobkxr);
                    continue ;
                }
        
                if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
                
                
                if (mx>putokxt && mx<putokxt+20 && my>putokyt && my<putokyt+20) { // Put OK !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr);  if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                    else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                                                            
                    if (putok) continue ;
                    putok=1;
                    RNputicon(putokxt,putokyt,mem_ok,olobkxr);
                    if (year_t[0]!=255) {show_help(" Κλικ για Μετάβαση ", putokxt,putokyt+25, &hdhlpxt , &hdhlpyt) ;}
                    continue ;
                }
        
                if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                
                
                if (mx>addokxt && mx<addokxt+20 && my>addokyt && my<addokyt+20) { // Add OK !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                  
                                        
                    if (addok) continue ;
                    addok=1;
                    RNputicon(addokxt,addokyt,mem_ok,olobkxr);
                    if (prosadd!=0) {show_help(" Κλικ για Μετάβαση ", addokxt,addokyt+25, &hdhlpxt , &hdhlpyt) ;}
                    continue ;
                }
        
                if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt); }
                
                
                if (mx>yesxt && mx<yesxt+32 && my>yesyt && my<yesyt+21) { // YESSSSSSS !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                    else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                 
                                        
                    if (finyes) continue ;
                       
                    finyes=1;
                    RNputicon(yesxt,yesyt,mem_yes,olobkxr);
                    continue ;
                }
        
                if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                
                
                if (mx>akyroxt && mx<akyroxt+54 && my>akyroyt && my<akyroyt+21) { // akyroooo !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                            line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                            line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                            line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                            line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                            line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                
                                        
                    if (akyro) continue ;
                    akyro=1;
                    RNputicon(akyroxt,akyroyt,mem_akyro,olobkxr);
                    continue ;
                }
        
                if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
                
                
                if (syncyes) {
                    if (mx>syncxt && mx<syncxt+20 && my>syncyt && my<syncyt+20) { // Sync !
                        
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                        if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                            line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                            line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                            line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                            line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                            line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                                                             
                        if (sync) continue ;
                        sync=1;
                        RNputicon(syncxt,syncyt,mem_sync,olobkxr);
                        if (keyb_gr) show_help(" Λήψη Ημερομηνίας από το Πάνελ ", syncxt,syncyt+35, &hdhlpxt , &hdhlpyt) ;
                        else show_help(" Get Date from Panel ", syncxt,syncyt+35, &hdhlpxt , &hdhlpyt) ;
                        continue ;
                    }
            
                    if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
                }
                
                
                if (!nowon) {
                    if (mx>recshmxt && mx<recshmxb && my>recshmyt && my<recshmyb) { // SHMERA !
                        
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
             
                                            
                        if (pronow) continue ;
                        pronow=1;
                        setrgbcolor(dbred);
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh();
                        continue ;
                    }
            
                    if (pronow) {
                        pronow=0; 
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh(); 
                    }
                }
                
                
                
            // ΤΕΛΟΣ ΤΑ ΠΙΘΑΝΑ ΣΗΜΕΙΑ !!
                if (!ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                ektos=1;
                }
                
            break ; // Πέρας mousemotion
            
            case SDL_MOUSEBUTTONDOWN:
                
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                if (ektos) continue ;
                SDL_FlushEvent(SDL_MOUSEBUTTONDOWN) ;
                SDL_FlushEvent(SDL_MOUSEMOTION) ;
                if (probox!=-1) {
LIKE_PROBOX:
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    if (specmonth) {c=(uday<5) ? 0 : 4 ;}
                    else c=0;
                    if (probox!=uday+c) {
                        a=((uday+c)/7)+1 ; b=(uday+c)%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        _bareacls (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1,genbkxr);
                        if (b==bluedy) _outmystr_center_col (notosans_14n,monda[uday],cx[b],cy[a],cx[b]+bw-1,cy[a]+bh,bluechxr,genbkxr);
                        else if (b==reddy) _outmystr_center_col (notosans_14n,monda[uday],cx[b],cy[a],cx[b]+bw-1,cy[a]+bh,redchxr,genbkxr);
                        else _outmystr_center_col (notosans_14n,monda[uday],cx[b],cy[a],cx[b]+bw-1,cy[a]+bh,genchxr,genbkxr);
                        
                        if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                        else c=0;
                        uday=probox-c;
                        //specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        a=(probox/7)+1 ; b=probox%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        _bareacls (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1,bkxrepi);
                        if (b==bluedy) _outmystr_center_col (notosans_14n,monda[uday],cx[b],cy[a],cx[b]+bw-1,cy[a]+bh,bluechxr,bkxrepi);
                        else if (b==reddy) _outmystr_center_col (notosans_14n,monda[uday],cx[b],cy[a],cx[b]+bw-1,cy[a]+bh,redchxr,bkxrepi);
                        else _outmystr_center_col (notosans_14n,monda[uday],cx[b],cy[a],cx[b]+bw-1,cy[a]+bh,genchxr,bkxrepi);
                       
                        setrgbcolor(dbblack);
                        rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                        rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);
                        
                        // Τι μέρα έχουμε στις τάδε του μήνα ;
                        unameday=startmonth;
                        for (f=2; f<=uday ; f++) {
                            unameday++;
                            if (unameday==8) unameday=1;
                        }
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                        
                        if (!d) {
                        // Ξαναχρωμάτισε το panel
                        setrgbcolor(dbmag);
                        rectangle (caxt,cayt,caxb,cayb);}
                        else { probox=-1; d=0;}
                        refresh();
                        
                    }
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    continue ;
                }
                                
                if(riday){
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    size=500000000;
                    
                    do{
                    if (uyear==2500) {
                        if (umonth==12 && uday==31) break ;
                    }
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    if (uday==mo[umonth]) { 
                        uday=1; 
                        unameday++;
                        if (unameday==8) unameday=1;
                        startmonth=unameday;
                        
                        // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                        _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                        _outmystr_center_col(bookman_14n,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                        line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        
                        umonth++;
                        if (umonth==13) { 
                            umonth=1; 
                            uyear++;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                            
                            story.olo=0;
                            story.meros[0]= uday;
                            story.meros[1]= umonth;
                            story.mewo[1]=uyear;
                                                        
                            uolo=story.olo ;
                            
                            greg = (uolo>=arx_grh) ? 1 : 0 ; 
                            
                            if (greg) {
    
                                if (uyear%4) mo[2]=28;
                                else {
                                    if (uyear%100) mo[2]=29;
                                    else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                    }
                            }

                            else { mo[2] = (uyear%4) ? 28 : 29 ; }
                        }
                        
                        // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                        _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                        _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                        setrgbcolor(dbmag);
                        rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                        line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                        line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        
                    }
                    else { 
                        uday++; 
                        unameday++;
                        if (unameday==8) unameday=1;
                        story.olo=0;
                        story.meros[0]= uday;
                        story.meros[1]= umonth;
                        story.mewo[1]=uyear;
                        
                        //printf("uday = %u , umonth = %u , uyear/mewo = %u/%u \n", uday, umonth, uyear,story.mewo);
                        uolo=story.olo ;
                        if (uolo==first_xam) {
                            greg=1;
                            uday=15;
                        }
                    }
                        
                        specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                        refresh ();
                        
                        f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                        
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= ridayxt) && (sdlev.motion.x <= ridayxt+18) && (sdlev.motion.y >= ridayyt) && (sdlev.motion.y <= ridayyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}                    

                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                        } while ( (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                        continue ;
                    }
                    
                    if (pronow) {
SHMERIS :
                        pronow=0; nowon=1;d=0;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh(); 
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        unameday=diar->tm_wday+1;
                        uday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        strcpy (mera[0],mera[unameday]);
                        greg=1;
                        
                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            
                            umonth=nowmonth;
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        if (nowyear != uyear) {
                        // ΕΤΟΣ - ΣΗΜΕΡΑ
                        
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",nowyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                            if (nowyear%4) mo[2]=28;
                            else {
                                if (nowyear%100) mo[2]=29;
                                else {mo[2]=(nowyear%400) ? 28 : 29 ;}
                            }
                            uyear = nowyear ;
                        }
                        
                        startmonth=unameday+1;
                        if (startmonth==8) startmonth=1;
                        for (f=uday ; f>0 ; f--){
                            startmonth--;
                            if (!startmonth) startmonth=7;
                        }
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                        
                       
                        // ΑΝΑΨΕ ΤΟ ΚΟΥΜΠΙ ΣΗΜΕΡΑ
                        
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        
                        // ΠΑΝΕΛ
                        specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                        
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;
                        }
                        
                        refresh();
                        continue ;
                    }
                    
                if(leday){
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    size=500000000;
                    do {
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                                        
                    if (uday==1) {
                        if (umonth==1){
                            if (uyear<=2000) break;
                            else {
                                uyear--;
                                // ΑΛΛΑΓΗ ΕΤΟΥΣ
                                _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                                sprintf (str1024,"%04u",uyear);
                                normtext_tomy(str1024,0);
                                _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                                
                                uday=31; umonth=12;
                                
                                startmonth=unameday;
                                for (f=31 ; f>0 ; f--) {
                                startmonth--;
                                if (!startmonth) startmonth=7;
                                }
                                
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                
                                uolo=story.olo ;
                                
                                greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                
                                if (greg) {

                                    if (uyear%4) mo[2]=28;
                                    else {
                                        if (uyear%100) mo[2]=29;
                                        else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                        }
                                }

                                else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[1]+1,mhnxb-1,mhnyb[1]-1,olobkxr);
                            _outmystr_center_col(arial_12,month[1],mhnxt,mhnyt[1]+1, mhnxb, mhnyb[1],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[1],mhnxb,mhnyb[1]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[1]+1,mhnxt-1,mhnyb[1]+1);
                            line(mhnxt-1,mhnyb[1]+1,mhnxb,mhnyb[1]+1);
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗNA
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            }
                        }
                        else {
                            
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            umonth--;
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            
                            uday=mo[umonth];
                            startmonth=unameday;
                            for (f=uday ; f>0 ; f--) {
                                startmonth--;
                                if (!startmonth) startmonth=7;
                            }
                        }
                    }
                    else { uday--; }
                    
                    unameday--;
                    if (!unameday) unameday=7;
                        
                    story.olo=0;
                    story.meros[0]= uday;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                        
                    if (uolo==last_xam) uday=4;
                                
                    
                    specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                    refresh ();
                    
                    f=0; while (f<size) f++;
                   if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= ledayxt) && (sdlev.motion.x <= ledayxt+18) && (sdlev.motion.y >= ledayyt) && (sdlev.motion.y <= ledayyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    } while ( (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                    continue ;
                }
                    
                if (promonbox!=-1) {
                    if (umonth==promonbox) continue ;
                    //nowday=uday; nowmonth=umonth; nownameday=unameday;

                    // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                    _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                    setrgbcolor(dbaspro);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                    
                    umonth = promonbox;
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                    
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                    _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                    setrgbcolor(dbmag);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                    
                    specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    
                }
                
                
                if (leyear) {
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    if (uyear==2000) continue ;
                    size=500000000;
                    do{
                    uyear--;

                    // ΑΛΛΑΓΗ ΕΤΟΥΣ
                    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                    sprintf (str1024,"%04u",uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);

                    a = (uday>28) ? 28 : uday ;
                    story.olo=0;
                    story.meros[0]= a;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                    
                    greg = (uolo>=arx_grh) ? 1 : 0 ; 
                    
                    if (greg) {

                        if (uyear%4) mo[2]=28;
                        else {
                            if (uyear%100) mo[2]=29;
                            else {mo[2]=(uyear%400) ? 28 : 29 ;}
                            }
                    }

                    else { mo[2] = (uyear%4) ? 28 : 29 ; }
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    
                    specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= leyearxt) && (sdlev.motion.x <= leyearxt+18) && (sdlev.motion.y >= leyearyt) && (sdlev.motion.y <= leyearyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    } while ( (uyear!=2000) && (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                    continue ;
                }
                
                
                if (riyear) {
                    auto int pev ;
                    while (SDL_PollEvent(&sdlev)) { ; } 
                    if (uyear==2500) continue ;
                    size=500000000;
                    do {
                    uyear++;

                    // ΑΛΛΑΓΗ ΕΤΟΥΣ
                    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                    sprintf (str1024,"%04u",uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);

                    a = (uday>28) ? 28 : uday ;
                    story.olo=0;
                    story.meros[0]= a;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                    
                    greg = (uolo>=arx_grh) ? 1 : 0 ; 
                    
                    if (greg) {

                        if (uyear%4) mo[2]=28;
                        else {
                            if (uyear%100) mo[2]=29;
                            else {mo[2]=(uyear%400) ? 28 : 29 ;}
                            }
                    }

                    else { mo[2] = (uyear%4) ? 28 : 29 ; }
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    
                    specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    pev = SDL_PollEvent(&sdlev) ;
                    if (sdlev.type==SDL_MOUSEMOTION) {
                        
                        motn = ( (sdlev.motion.x >= riyearxt) && (sdlev.motion.x <= riyearxt+18) && (sdlev.motion.y >= riyearyt) && (sdlev.motion.y <= riyearyt+18) ) ? 0 : 1 ;
                        if (!motn) { pev=0; } SDL_FlushEvent(SDL_MOUSEMOTION) ;
                    } else { motn=0 ;}
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    
                    } while ( (uyear!=2500) && (!pev) && (sdlev.type!=SDL_MOUSEBUTTONUP) && (!motn) ) ;
                    continue;
                }
                
                if (inpyear) {
                    
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[notosans_14n];
                    bareacls(inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb-1,olobkxr);
                    i=num_input(year_t,inpyearxt+20,inpyearyt+1,inpyearxb-1,inpyearyb-1,4,0);
                    if (year_t[0]==255) {prosyear=0 ; continue ;}
                    prosyear=(unsigned short int) convert_str (4,year_t);
                    if (prosyear<2000) prosyear=2000;
                    else if (prosyear>2500) prosyear=2500; 
                    
                    sprintf (str1024,"%04u",prosyear);
                    sprintf (year_t,"%u",prosyear);
                    normtext_tomy(str1024,0); normtext_tomy(year_t,0);
                    _bareacls(inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb-1,olobkxr);
                    _outmystr_center_col(notosans_14n, str1024,  inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb,olochxr,olobkxr);
                    refresh();
                    

                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpyearxt,inpyearyt,inpyearxb,inpyearyb);
                        setrgbcolor (dbmag);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        inpmonth=1; inpyear=0;
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        refresh();
                        i=num_input(month_t,inpmonthxt+10,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,2,0);
                        
                        prosmonth=(unsigned short int) convert_str (2,month_t);
                        if (!prosmonth) prosmonth=1;
                        else if (prosmonth>12) prosmonth=12; 
                        
                        sprintf (str1024,"%02u",prosmonth);
                        sprintf (month_t,"%u",prosmonth);
                        normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        _outmystr_center_col(notosans_14n, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                        refresh();
                        
                    }
                    else continue ;
                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        setrgbcolor (dbmag);
                        rectangle (inpdayxt,inpdayyt,inpdayxb,inpdayyb);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        refresh();
                        inpmonth=0; inpday=1;
                        if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                        i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                        prosday=(unsigned short int) convert_str (2,day_t);
                        if (!prosday) prosday=1; 
                        else if (prosday>b) prosday=b; 
                        sprintf (day_t,"%u",prosday);
                        sprintf (str1024,"%02u",prosday);
                        normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        _outmystr_center_col(notosans_14n, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, 
                                             olochxr,olobkxr);
                        refresh();
                        
                    }
                    
                    continue;
                }
                
                
                if (inpmonth) {
                    
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[notosans_14n];
                    bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                    i=num_input(month_t,inpmonthxt+10,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,2,0);
                    if (month_t[0]==255) {prosmonth=0 ; continue ;}
                    prosmonth=(unsigned short int) convert_str (2,month_t);
                    if (!prosmonth) prosmonth=1;
                    else if (prosmonth>12) prosmonth=12; 
                    sprintf (month_t,"%u",prosmonth);    
                    sprintf (str1024,"%02u",prosmonth);
                    normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                    _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                    _outmystr_center_col(notosans_14n, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                    refresh();
                
                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        setrgbcolor (dbmag);
                        rectangle (inpdayxt,inpdayyt,inpdayxb,inpdayyb);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        refresh();
                        inpmonth=0; inpday=1;
                        if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                        
                        i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                        
                        prosday=(unsigned short int) convert_str (2,day_t);
                        if (!prosday) prosday=1; 
                        else if (prosday>b) prosday=b; 
                        sprintf (day_t,"%u",prosday);
                        sprintf (str1024,"%02u",prosday);
                        normtext_tomy(str1024,0);
                        normtext_tomy(day_t,0);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        _outmystr_center_col(notosans_14n, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                        refresh();
                    }
                    
                    continue;
                }
                
                
                if (inpday) {
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[notosans_14n];
                    
                    bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                    i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                    if (day_t[0]==255) {prosday=0 ; continue ;}
                    prosday=(unsigned short int) convert_str (2,day_t);
                    
                    if (!prosmonth) {
                        prosmonth=1;
                        sprintf (str1024,"%02u",prosmonth);
                        sprintf (month_t,"%u",prosmonth);
                        normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        _outmystr_center_col(notosans_14n, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                    }
                    if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                    
                    if (!prosday) prosday=1; 
                    else if (prosday>b) prosday=b; 
                        
                    sprintf (str1024,"%02u",prosday);
                    sprintf (day_t,"%u",prosday);
                    normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                    _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                    _outmystr_center_col(notosans_14n, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                    refresh();
                    continue ;
                }
                    
                    if (putok) {
                        
                        if (year_t[0]==255) continue;
                        if (prosyear==uyear && prosmonth==umonth && prosday==uday) continue ;
                        if (month_t[0]==255) {
                            prosmonth=1;
                            sprintf (str1024,"%02u",prosmonth);
                            sprintf (month_t,"%u",prosmonth);
                            normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                            _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                            _outmystr_center_col(notosans_14n, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                            refresh();
                        }
                        
                        if (day_t[0]==255) {
                            prosday=1;
                            sprintf (str1024,"%02u",prosday); sprintf (day_t,"%u",prosday);
                            normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                            _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                            _outmystr_center_col(notosans_14n, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                        a = (prosday>28) ? 28 : prosday ;
                        story.olo=0;
                        story.meros[0]= a;
                        story.meros[1]= prosmonth;
                        story.mewo[1]=prosyear;
                        uolo=story.olo ;

                        greg = (uolo>=arx_grh) ? 1 : 0 ;
                        
                        uday=greday=prosday;
                        
                        if (greg) {

                            if (prosyear%4) b=28;
                            else {
                                if (prosyear%100) b=29;
                                else {b=(prosyear%400) ? 28 : 29 ;}
                                }
                        }

                        else { b = (prosyear%4) ? 28 : 29 ; }
                        
                        
                        if (prosmonth==2) {
                            if (prosday>b) {uday=b ;}
                        }
                        else if (prosday>mo[prosmonth]) uday=mo[prosmonth] ;
                        
                        story.olo=0;
                        story.meros[0]=greday;
                        story.meros[1]=prosmonth;
                        story.mewo[1]=prosyear;
                         if (story.olo<first_xam || story.olo>gre_xam_t) {greday=40;}
                        
                        
                        mo[2]=b;
                        
                        if (uday!=prosday) {
                            prosday=uday;
                            sprintf (str1024,"%02u",uday);
                            sprintf (day_t,"%u",uday);
                            normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                            _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                            _outmystr_center_col(notosans_14n, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                                                                        
                        if (prosyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            uyear=prosyear;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                        }

                        if (umonth!=prosmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);

                            umonth=prosmonth;

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        startmonth=find_dayname(uyear , umonth , 1);
                        
                        if (startmonth!=20) {
                            if (uday>mo[umonth]) uday=mo[umonth];
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        else {
                            startmonth=2;
                            if (uday>mo[umonth]) uday=mo[umonth];
                            else if (uday>4 && uday<15) {
                                uday=15;
                            }
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            if (f>4 && f<15) continue;
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        
                        
                        specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                        
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                        continue ;
                        
                    }
                    
                    if (adddays) {
                        
                        for (f=0 ; f<3 ; f++) {
                            chxr[f] = olochxr[f];
                            bkxr[f] = olobkxr[f];
                            slxr[f] = bkxrepi[f];
                        }
                        
                        gouv=myfont[notosans_14n];
                        bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                        num_input(addday_t,adddaysxt+10,adddaysyt+1,adddaysxb-1,adddaysyb-1,6,2);
                        if (addday_t[0]==255) {prosadd=0 ; continue;}
                        prosadd=(int) convert_str (6,addday_t);
                        if (prosadd<0) {
                            if (prosadd<-10000) prosadd=-10000;
                            sprintf (str1024,"%06d",prosadd);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                        } 
                        else { 
                            if (prosadd>10000) prosadd=10000;
                            sprintf (str1024,"%05d",prosadd);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                        }
                        
                        normtext_tomy(str1024,0);
                        _bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                        _outmystr_center_col(notosans_14n, str1024,  adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb, olochxr,olobkxr);
                        refresh();
                        continue ;
                    }
                    
                    if (addok) {
                        
                        if (!prosadd) continue ;
                            
                        story.olo=0;
                        story.meros[0]= uday;
                        story.meros[1]= umonth;
                        story.mewo[1]=uyear;
                        uolo=story.olo ;
                        
                        nowmonth = umonth;
                        nowyear = uyear;
                        
                        if (prosadd>0) { // ΠΡΟΣΘΕΣΗ
                            if (uolo == tel_diary) continue ;
                            i=prosadd;
                            while(i) {
                                unameday = (unameday==7) ? 1 : unameday+1;
                                uday = (uday == mo[umonth]) ? 1 : uday+1;
                                if (uday==1) {
                                    umonth=(umonth==12) ? 1 : umonth+1;
                                    if (umonth==1) {
                                        uyear++;
                                        
                                        story.olo=0;
                                        story.meros[0]= uday;
                                        story.meros[1]= umonth;
                                        story.mewo[1]=uyear;
                                        uolo=story.olo ;
                                        
                                        greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                        
                                        if (greg) {

                                            if (uyear%4) mo[2]=28;
                                            else {
                                                if (uyear%100) mo[2]=29;
                                                else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                                }
                                        }

                                        else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                        i--;
                                        continue;
                                    }
                                }
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                uolo=story.olo ;
                                
                                if (uolo==first_xam) uday=15;
                                else if (uolo==tel_diary) {i--;break;}
                                i--;
                            }
                        }
                        else { // ΑΦΑΙΡΕΣΗ
                            if (uolo == arx_diary || uolo == arx_2000) continue ;
                            i=abs(prosadd);
                            while (i) {
                                unameday = (unameday==1) ? 7 : unameday-1 ;
                                if (uday==1){
                                    if (umonth==1) {
                                        if (uyear==2000) {unameday = (unameday==7) ? 1 : unameday+1; break;}
                                        else {
                                            uyear--; uday=31; umonth=12;
                                            story.olo=0;
                                            story.meros[0]= uday;
                                            story.meros[1]= umonth;
                                            story.mewo[1]=uyear;
                                            uolo=story.olo ;
                                            
                                            greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                            
                                            if (greg) {

                                                if (uyear%4) mo[2]=28;
                                                else {
                                                    if (uyear%100) mo[2]=29;
                                                    else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                                    }
                                            }

                                            else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                            i--;
                                            continue ;
                                        }
                                    } else { umonth--; uday=mo[umonth]; i--; continue ;}
                                }
                                else { uday--;}
                                
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                uolo=story.olo ;
                                
                                if (uolo==last_xam) uday=4;
                                i--;
                                
                            }
                        }
                        
                        if (i) {
                            if (prosadd<0) {
                                prosadd=-i+1;
                                sprintf (str1024,"%06d",prosadd);
                            }
                            else {
                            prosadd=i-1;
                            sprintf (str1024,"%05d",prosadd);}
                            normtext_tomy(str1024,0);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                            _bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                            _outmystr_center_col(notosans_14n, str1024,  adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                        if (nowyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                        }

                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[nowmonth]+1,mhnxb-1,mhnyb[nowmonth]-1,olobkxr);
                            _outmystr_center_col(arial_12,month[nowmonth],mhnxt,mhnyt[nowmonth]+1, mhnxb, mhnyb[nowmonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[nowmonth],mhnxb,mhnyb[nowmonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[nowmonth]+1,mhnxt-1,mhnyb[nowmonth]+1);
                            line(mhnxt-1,mhnyb[nowmonth]+1,mhnxb,mhnyb[nowmonth]+1);

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        startmonth=unameday+1;
                        if (startmonth==8) startmonth=1;
                        
                        for (f=uday ; f>0 ; f--) {
                            startmonth=(startmonth==1) ? 7 : startmonth-1 ;
                        }
                        
                        specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday, startmonth);
                        
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                            
                        continue ;    
                    }
                    
                    if (sync){
                        
                        if (*panel_year<2000) {information (0,"Η ημερομηνία του πάνελ είναι πριν το έτος 2000!","Οι υπομνήσεις του χρήστη πρέπει να ορίζονται μετά από το έτος 2000.");continue;}
                        
                        nowyear= *panel_year;
                        nowmonth= *panel_month;
                        nowday= *panel_day ;
                       
                        if (nowyear==uyear && nowmonth==umonth && nowday==uday) continue ;
                        if (nowyear<2000) {continue;}
                        
                        a=0;
                        
                        greg = 1 ;
                        

                        if (nowyear%4) b=28;
                        else {
                            if (nowyear%100) b=29;
                            else {b=(nowyear%400) ? 28 : 29 ;}
                            }
                        
                        if (nowmonth==2 && nowday>b) a=1;
                        else if (nowday>mo[nowmonth]) a=1;
                        
                        mo[2]=b;
                        
                        if (nowyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            uyear=nowyear;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, etosbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(bookman_14n,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , etosbkxr);
                        }

                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);

                            umonth=nowmonth;

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(arial_12,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        uday=nowday ;
                        
                        startmonth=find_dayname(uyear , umonth , 1);
                        
                        
                            if (uday>mo[umonth]) uday=mo[umonth];
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        
                        specmonth=_mini_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrepi);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(neohell_13b,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, black , bkxrepi);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(notosans_14b,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, axnochxr , olobkxr);
                            refresh() ;
                            continue ;
                        }

                        continue;
                    }
                    
                    
                    if (marrs) {
                        size=imagesize(0,0,imw,imh);
                        mem_move=malloc(size);
                        if (!mem_move) {information (2-keyb_gr,0,0);continue;}
                        getimage(xt,yt,xt+imw,yt+imh,mem_move);
                        xt1=xt ; yt1=yt ;
                        dx=change_pos(&xt1, &yt1, &xb , &yb);
                        if (dx<0) { free(mem_move); xb=xt+imw; yb=yt+imh; continue ; }
                        putimage(xt,yt,mem0,0);
                        while (((yt1+imh)>=info.bottom-50)) yt1--;
                        xt=xt1; yt=yt1;
                        xb=xt+imw; yb=yt+imh;
                        getimage(xt,yt,xb,yb,mem0);
                        putimage(xt,yt,mem_move,0);
                        free(mem_move);

                                                // ΣΥΝΤΕΤΑΓΜΕΝΕΣ
                        leyearxt=recfullxt=xt+30;
                        ledayxt=xt+50;
                        movext=caxt=xt+6 ;
                        inpyearxt=xt+25;
                        moveyt=yt+4; // Επικεφαλίδα στο yt+4 επίσης!
                        
                        recfullyt=yt+4;
                        recfullyb=recfullyt+20;
                        leyearyt=riyearyt=recyearyt=mhnyb[0]=recfullyb+8;
                        mhnyb[0]-=1;
                        recyearxt=leyearxt+25;
                        recshmxt=ledayxt+25;
                        
                        recyearyb=recyearyt+20;
                        ledayyt=ridayyt=recshmyt=recyearyb+4;
                        recshmyb=recshmyt+20;
                        cayt=recshmyb+9;
                            
                            // Υπολογισμός cx - cy
                            for (i=1 ; i<8 ; i++ ) { cx[i]=caxt+(i-1)*bw; }
                            caxb=caxt+(i-1)*bw;
                            for (f=0 ; f<6;f++) { cy[f]=cayt+f*bh; }
                            cayb=cayt+f*bh;

                            ridayxt=caxb-76;
                            riyearxt=caxb-56;
                            recfullxb = riyearxt+20;
                            recyearxb=riyearxt-4 ;
                            recshmxb=ridayxt-4 ;
                            inpyearxb=inpyearxt+60;
                            inpmonthxt=inpyearxb+21; inpmonthxb=inpmonthxt+30;
                            inpdayxt=inpmonthxb+18; inpdayxb=inpdayxt+30;
                            inpyearyt = inpmonthyt = inpdayyt = cayb+40;
                            // ENDIAMESA NA GRAFEI KATI....
                            inpyearyb=inpmonthyb=inpdayyb=inpdayyt+20;
                            putokxt=inpdayxb+7; putokyt = inpdayyt-4;
                            // ENDIAMESA NA GRAFEI KATI....
                            adddaysxt=xt+70; adddaysyt=inpyearyb+40;
                            adddaysxb=adddaysxt+90;
                            adddaysyb=adddaysyt+20;
                            addokxt=adddaysxb+7; addokyt=adddaysyt-4 ;
                            yesxt = xb-50 ; yesyt = adddaysyb+17;
                            akyroxt = xt+15; akyroyt = adddaysyb+17;
                            syncxt = xt+150 ; syncyt = akyroyt;
                                                       
                            // ΜΗΝΕΣ
                            mhnxt=caxb+10;
                            mhnxb=mhnxt+60;
                            for (f=1; f<13 ; f++) {       
                                mhnyt[f]=mhnyb[f-1]+4;
                                mhnyb[f] = mhnyt[f]+20;
                            }
                            
                            refresh();
                            continue;
                    }
                    
                    
                    if (akyro) {
                        fyge=1;
                        *panel_year = 0 ;
                        *panel_month = 0 ;
                        *panel_day = 0 ;
                        *panel_nameday = 0 ;
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        continue;
                    }
                    
                    if (finyes) {
                        
                        *panel_year = uyear ;
                        *panel_month = umonth ;
                        *panel_day = uday ;
                        *panel_nameday = unameday ;
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        fyge=1;
                        continue ;
                    }
                    
                    continue;
                
            break ; // Πέρας mousebuttondown
            
        case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

        refresh(); 
        break;
        
        case SDL_QUIT :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
             fyge=1;
            *panel_year = 0 ;
            *panel_month = 0 ;
            *panel_day = 0 ;
            *panel_nameday = 0 ;
            break ;
        
        case SDL_KEYDOWN:

        ch_scan=sdlev.key.keysym.scancode;
        //do { SDL_PollEvent(&sdlev) ; } while ( (SDL_PollEvent(&sdlev)) && (sdlev.type == SDL_KEYDOWN) ) ;
        SDL_FlushEvent(SDL_KEYDOWN);
        a=0;
        d=0;
        switch (ch_scan) {
            
            case SDL_SCANCODE_LEFT :
                if (uday==1) continue ;
                a=1;
                break;

            case SDL_SCANCODE_RIGHT :
                
                if (uday==mo[umonth]) continue ;
                a=2;
                break;

            case SDL_SCANCODE_UP :
                
                dx=uday-7;
                if(dx<1) continue ;
                a=3;
                break ;
               
            case SDL_SCANCODE_DOWN :

                if ((uday+7) > mo[umonth]) continue ;
                a=4;
                break ;
                
            case SDL_SCANCODE_HOME :
                
                a=5;
                break ;

            case SDL_SCANCODE_ESCAPE :
                fyge=1;
                *panel_year = 0 ;
                *panel_month = 0 ;
                *panel_day = 0 ;
                *panel_nameday = 0 ;
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                continue ;
        }
        
        if (!a) continue ;
        d=a;
        
                
        if (panel) {
            panel=0;
            setrgbcolor(dbaspro);
            rectangle (caxt,cayt,caxb,cayb);
            if (specmonth) {c=(probox<5) ? 0 : 4 ;}
            else c=0;
            if (probox!=-1) {
                a=(probox/7)+1 ; b=probox%7 ;
                if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                if (probox!=uday+c) {
                    setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                    rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                    rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);
                }
                else {
                    setcolor (COLOR(ejobkxr[0],ejobkxr[1],ejobkxr[2]));    
                    rectangle (cx[b]+1,cy[a]+1,cx[b]+bw-1,cy[a]+bh-1);
                    rectangle (cx[b]+2,cy[a]+2,cx[b]+bw-2,cy[a]+bh-2);
                }
                box=probox=-1;
            }
            refresh();
        }
        else if (promonbox!=-1) {
                setrgbcolor(dbaspro);
                rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                refresh();
                promonbox=monbox=-1;
            }
            else if (inpyear) {
                inpyear=0;
                setrgbcolor(dbaspro);
                rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                refresh();
            }
            else if (inpmonth) {
                inpmonth=0;
                setrgbcolor(dbaspro);
                rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                refresh();
            }
            else if (inpday) {
                inpday=0;
                setrgbcolor(dbaspro);
                rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                refresh();
            }
            else if (adddays) {
                adddays=0;
                setrgbcolor(dbaspro);
                rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                refresh();
            }
            else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
            else if (riyear) {riyear=0; Rputicon(riyearxt,riyearyt,mem_ri,olobkxr); }
            else if (leday) {leday=0; Rputicon(ledayxt,ledayyt,mem_le,olobkxr); }
            else if (riday) {riday=0; Rputicon(ridayxt,ridayyt,mem_ri,olobkxr); }
            else if (putok) {putok=0; Rputicon(putokxt,putokyt,mem_ok,olobkxr); }
            else if (addok) {addok=0; Rputicon(addokxt,addokyt,mem_ok,olobkxr); }
            else if (finyes) {finyes=0; Rputicon(yesxt,yesyt,mem_yes,olobkxr); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
            else if (akyro) {akyro=0; Rputicon(akyroxt,akyroyt,mem_akyro,olobkxr); }
            else if (sync) {sync=0; Rputicon(syncxt,syncyt,mem_sync,olobkxr); hide_help(hdhlpxt , hdhlpyt);}
            else if (pronow) {
                    pronow=0; 
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                    refresh(); 
                }
         
            
            if (!ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
            ektos=1;
            }
            
            a=d;
            switch (a) {

                case 1 :
                                
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c-1;
                        if (probox>4 && probox<19) probox=4;
                        
                    }
                    else probox=uday-1;
                    
                    goto LIKE_PROBOX ;

                case 2 :
                    
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c+1;
                        if (probox>4 && probox<19) probox=19;
                        
                    }
                    else probox=uday+1;
                    
                    goto LIKE_PROBOX ;

                case 3 :
                            
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c-7;
                        if (probox>4 && probox<19) probox=4;
                        
                    }
                    else probox=uday-7;
                    
                    goto LIKE_PROBOX ;

                case 4: 

                    if ((uday+7) > mo[umonth]) continue ;
                    if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                    else c=0;
                
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c+7;
                        if (probox>4 && probox<19) probox=19;
                    }
                    else probox=uday+7;
                    
                    goto LIKE_PROBOX ;
                    
                case 5 :
                            
                    goto SHMERIS ;   
            }
            
        
        } // Πέρας switch sdlev.type
        
    } while (!fyge);


FYGE:

//    do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    
    SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
    if(mem0) {putimage(xt,yt,mem0,0); refresh();free(mem0);}
    if(mem_arrs) free(mem_arrs);
    if(mem_ri) free(mem_ri);
    if(mem_le) free(mem_le);
    if(mem_ok) free(mem_ok);
    if(mem_yes) free(mem_yes);
    if(mem_akyro) free(mem_akyro);
    if (mem_sync) free (mem_sync);
    //if( (!keepfld) && (memfld)) free(memfld);
    gouv=trampa;
    for (f=0;f<3;f++) {
        bkxr[f]=bkxr2[f] ; chxr[f]=chxr2[f] ; slxr[f]=slxr2[f];
    }
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
    return 1;
}


void recur_days ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , short int *mo)
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth

{

   if (rcr[a].anast) { return ; }

register int f ;   
short int s ;
short int tmo[13] ;    


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    // + ALarm
    
    for (f=0 ; f<rcr[a].alarm ; f++) {
        if (tmi.damo[0] == mo[tmi.damo[1]]) {
            tmi.damo[0]=1;
            tmi.damo[1] = (tmi.damo[1] == 12) ? 1 : tmi.damo[1] + 1 ;
        }
        else { tmi.damo[0] ++; continue; }
        
        if (tmi.damo[1]==1) {
            tmi.yr[1] ++ ;
            // Δεν χρειάζεται νέος υπολογισμός mo[2]
        }
    }
    
        // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
    
    // Σήμερα
    si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }

    s = 0 ;
    
    // Όσο η αρχή του τρέχοντος μήνα είναι μεγαλύτερη της παραγόμενης ημερομηνίας υπόμνησης :
    while ( ami.ak > tar.ak ) {
        for (f=1 ; f <= rcr[a].step ; f++) {
            if (tar.damo[0]==tmo[tar.damo[1]]) {
                tar.damo[0]=1;
                tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            }
            else { tar.damo[0]++; continue; }
            
            if (tar.damo[1]==1) {
                tar.yr[1] ++ ;
                // Υπολογισμός tmo[2] για new tar.year[1]
                if (tar.yr[1]%4) tmo[2]=28;
                else {
                    if (tar.yr[1]%100) tmo[2]=29;
                    else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
                }
            }
        }
    }
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός που έχει επεκταθεί με +alarm ημέρες
    
    while ( tar.ak <= tmi.ak ) {
        if (tar.damo[1] == umonth) { only[umonth][tar.damo[0]] = 1 ; }
        if (!s) {
            if ( tar.ak == si.ak ) {clue[a]=1; s=1 ;}
            else if ( tar.ak > si.ak ) {
                // Ψάχνω μήπως το σήμερα είναι προειδοποίηση
                pre.ak = tar.ak ;
                //pre.yr[1] = tar.yr[1];
                //pre.mm = tar.mm ;
                for (f=1 ; f<=rcr[a].alarm ; f++) {
                    if (pre.damo[0]>1) { 
                        pre.damo[0] -- ; 
                        if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ; break; }
                        continue ;
                    }
                    else {
                        pre.damo[1] = (pre.damo[1] == 1) ? 12 : pre.damo[1] - 1 ; 
                    }
                    
                    if (pre.damo[1]==12) {
                        pre.damo[0] = 31 ;
                        pre.yr[1] --;
                    } else { pre.damo[0] = tmo[pre.damo[1]]; }
                    
                    if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ;  break; }
                }
            }
        }
        // Υπολογισμός επόμενου tar
        for (f=1 ; f <= rcr[a].step ; f++) {
            if (tar.damo[0]==tmo[tar.damo[1]]) {
                tar.damo[0]=1;
                tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            }
            else { tar.damo[0] ++; continue; }
            
            if (tar.damo[1]==1) {
                tar.yr[1] ++ ;
                // Υπολογισμός tmo[2] για new tar.year[1]
                if (tar.yr[1]%4) tmo[2]=28;
                else {
                    if (tar.yr[1]%100) tmo[2]=29;
                    else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
                }
            }
        }
    }
}



void year_recur_days ( int a , unsigned short int uyear,  unsigned char yonly[][32])
// a = αριθμός δομής της περιοδικής υπόμνησης
// Ενημερώνει πίνακα yonly και πίνακα δομών mri

{

   if (etrcr[a].anast) { return ; }
    
register int f ;   
short int s ;
short int tmo[13] ;    


    // Αρχή τρέχοντος 'Ετους
    
    ami.damo[0] = 1 ; ami.damo[1] = 1 ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = etrcr[a].perasyear ;
    eos.damo[0] = (unsigned char) etrcr[a].perasdate ;
    eos.damo[1] = (unsigned char) etrcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή ετους
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = etrcr[a].enaryear ;
    tar.damo[0] = (unsigned char) etrcr[a].enardate ;
    tar.damo[1] = (unsigned char) etrcr[a].enarmonth ;

    // Τέλος τρέχοντος ετους
    
    tyear.damo[1] = 31 ;
    tyear.damo[0] = 12 ;
    tyear.yr[1] = uyear ;
    
    
        // Αν το τέλος έτους ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tyear.ak > eos.ak) { tyear.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος έτους ... έφυγες.
    if (tar.ak > tyear.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }

    
    // Όσο η αρχή του τρέχοντος έτους είναι μεγαλύτερη της παραγόμενης ημερομηνίας υπόμνησης :
    while ( ami.ak > tar.ak ) {
        for (f=1 ; f <= etrcr[a].step ; f++) {
            if (tar.damo[0]==tmo[tar.damo[1]]) {
                tar.damo[0]=1;
                tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            }
            else { tar.damo[0]+=1; continue; }
            
            if (tar.damo[1]==1) {
                tar.yr[1] ++ ;
                // Υπολογισμός tmo[2] για new tar.year[1]
                if (tar.yr[1]%4) tmo[2]=28;
                else {
                    if (tar.yr[1]%100) tmo[2]=29;
                    else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
                }
            }
        }
    }
    
    // Τώρα έχω tar.ak >= τρέχοντος έτους και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους έτους 
    
    while ( tar.ak <= tyear.ak ) {
        
        yonly[tar.damo[1]][tar.damo[0]] = 1 ;
        
        if (mem_g != NULL) {
            mri->dom = (unsigned short int) a ;
            mri->date = tar.mm ;
            c_arst++; mri ++ ;
            if (c_arst==arst){
                arst += 256 ;
                remem=realloc (mem_g , (szYR * arst) );
                if (remem==NULL) {
                    if(mem_g!=NULL) { free(mem_g); mem_g=NULL; }
                    arst = c_arst = 0;
                    information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                    return ;
                }
                mem_g=remem;
                mri_1 = mri = ( struct YearRec *) mem_g;
                mri += c_arst ;
            }
        }
        // Υπολογισμός επόμενου tar
        for (f=1 ; f <= etrcr[a].step ; f++) {
            if (tar.damo[0]==tmo[tar.damo[1]]) {
                tar.damo[0]=1;
                tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            }
            else { tar.damo[0] ++; continue; }
            
            if (tar.damo[1]==1) {
                tar.yr[1] ++ ;
                // Υπολογισμός tmo[2] για new tar.year[1]
                if (tar.yr[1]%4) tmo[2]=28;
                else {
                    if (tar.yr[1]%100) tmo[2]=29;
                    else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
                }
            }
        }
    }
}



void month_recur_days ( int a , unsigned short int uyear , unsigned short int umonth , short int *mo)
// a = αριθμός δομής της περιοδικής υπόμνησης
// Ενημερώνει πίνακα δομών mra για το συγκεκριμένο umonth - καλείται μια φορά για κάθε δομή RECUR

{

   if (rcr[a].anast) { return ; }
    
register int f ;   
short int tmo[13] ;    


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    
        // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
   
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }

    
    // Όσο η αρχή του τρέχοντος μήνα είναι μεγαλύτερη της παραγόμενης ημερομηνίας υπόμνησης :
    while ( ami.ak > tar.ak ) {
        for (f=1 ; f <= rcr[a].step ; f++) {
            if (tar.damo[0]==tmo[tar.damo[1]]) {
                tar.damo[0]=1;
                tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            }
            else { tar.damo[0]+=1; continue; }
            
            if (tar.damo[1]==1) {
                tar.yr[1] ++ ;
                // Υπολογισμός tmo[2] για new tar.year[1]
                if (tar.yr[1]%4) tmo[2]=28;
                else {
                    if (tar.yr[1]%100) tmo[2]=29;
                    else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
                }
            }
        }
    }
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός που έχει επεκταθεί με +alarm ημέρες
    
    while ( tar.ak <= tmi.ak ) {
        //only[umonth][tar.damo[0]] = 1 ;
        if (mem_a != NULL) {
            mra->dom = (unsigned short int) a ;
            mra->date = tar.mm ;
            c_arma++; mra ++ ;
            if (c_arma==arma){
                arma += 64 ;
                remem=realloc (mem_a , (szYR * arma) );
                if (remem==NULL) {
                    if(mem_a!=NULL) { free(mem_a); mem_a=NULL; }
                    arma = c_arma = 0;
                    information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                    return ;
                }
                mem_a=remem;
                mra_1 = mra = ( struct YearRec *) mem_a;
                mra += c_arma ;
            }
        }

        // Υπολογισμός επόμενου tar
        for (f=1 ; f <= rcr[a].step ; f++) {
            if (tar.damo[0]==tmo[tar.damo[1]]) {
                tar.damo[0]=1;
                tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            }
            else { tar.damo[0] += 1; continue; }
            
            if (tar.damo[1]==1) {
                tar.yr[1] ++ ;
                // Υπολογισμός tmo[2] για new tar.year[1]
                if (tar.yr[1]%4) tmo[2]=28;
                else {
                    if (tar.yr[1]%100) tmo[2]=29;
                    else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
                }
            }
        }
    }
}


void recur_week ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo)
// freq = 7 π.χ. κάθε εβδομάδα την ημέρα Δευτέρα...
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth
{

   if (rcr[a].anast) { return ; }
    
register int f ;   
short int s ;  
unsigned short int dd ;


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    // + ALarm
    
    for (f=0 ; f<rcr[a].alarm ; f++) {
        if (tmi.damo[0] == mo[tmi.damo[1]]) {
            tmi.damo[0]=1;
            tmi.damo[1] = (tmi.damo[1] == 12) ? 1 : tmi.damo[1] + 1 ;
        }
        else { tmi.damo[0] ++; continue; }
        
        if (tmi.damo[1]==1) {
            tmi.yr[1] ++ ;
            // Δεν χρειάζεται νέος υπολογισμός mo[2]
        }
    }
    
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    // Σήμερα
    si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
       
    
    if (tar.ak < ami.ak) {tar.ak = ami.ak; dd = startmonth ;}
    else { dd = rcr[a].enarday ; }
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός που έχει επεκταθεί με +alarm ημέρες
    
    s = 0 ;
    
    while ( tar.ak <= tmi.ak ) {
        if  (dd == rcr[a].weekday) {
            if ( tar.damo[1] == umonth ) { only[umonth][tar.damo[0]] = 1 ; }
            if (!s) {
                if ( tar.ak == si.ak ) {clue[a]=1; s=1 ;}
                else if ( tar.ak > si.ak ) {
                    // Ψάχνω μήπως το σήμερα είναι προειδοποίηση
                    pre.ak = tar.ak ;
                    //pre.yr[1] = tar.yr[1];
                    //pre.mm = tar.mm ;
                    for (f=1 ; f<=rcr[a].alarm ; f++) {
                        if (pre.damo[0]>1) { 
                            pre.damo[0] -- ; 
                            if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ; break; }
                            continue ;
                        }
                        else {
                            pre.damo[1] = (pre.damo[1] == 1) ? 12 : pre.damo[1] - 1 ; 
                        }
                        
                        if (pre.damo[1]==12) {
                            pre.damo[0] = 31 ;
                            pre.yr[1] --;
                        } else { pre.damo[0] = mo[pre.damo[1]]; }
                        
                        if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ;  break; }
                    }
                }
            }
        }
        
        // Υπολογισμός επόμενου tar
        
        if (tar.damo[0]==mo[tar.damo[1]]) {
            tar.damo[0]=1;
            tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            dd = (dd == 7) ? 1 : dd + 1;
        }
        else { tar.damo[0] ++; dd = (dd == 7) ? 1 : dd + 1; continue; }
        
        if (tar.damo[1]==1) {
            tar.yr[1] ++ ;
            // Υπολογισμός mo[2] για new tar.year[1] δεν απαιτείται !
        }
    }
}




void year_recur_week ( int a , unsigned short int uyear , unsigned char yonly[][32])
// a = αριθμός δομής της περιοδικής υπόμνησης
// Ενημερώνει only_1 και πίνακα mri
// freq = 7 , κάθε εβδομάδα την τάδε ημέρα

{
   if (etrcr[a].anast) { return ; }
   
unsigned short int dd ;
short int tmo[13] ;

    // Αρχή τρέχοντος Year
    
    ami.damo[0] = 1 ; ami.damo[1] = 1;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = etrcr[a].perasyear ;
    eos.damo[0] = (unsigned char) etrcr[a].perasdate ;
    eos.damo[1] = (unsigned char) etrcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος year έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = etrcr[a].enaryear ;
    tar.damo[0] = (unsigned char) etrcr[a].enardate ;
    tar.damo[1] = (unsigned char) etrcr[a].enarmonth ;

    // Τέλος τρέχοντος year
    
    tyear.damo[1] = 12 ;
    tyear.damo[0] = 31 ;
    tyear.yr[1] = uyear ;
    
    // Αν το τέλος year ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tyear.ak > eos.ak) { tyear.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος year τότε ... έφυγες.
    if (tar.ak > tyear.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
      
    if (tar.ak < ami.ak) {
        tar.ak = ami.ak; 
        dd = find_dayname(uyear , 1 , 1);
    }
    else { dd = etrcr[a].enarday ; }
    
    // Τώρα έχω tar.ak >= της αρχής year και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους year
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    
    while ( tar.ak <= tyear.ak ) {
        if ( dd == etrcr[a].weekday ) { 
            yonly[tar.damo[1]][tar.damo[0]] = 1 ;
            
            if (mem_g != NULL) {
                mri->dom = (unsigned short int) a ;
                mri->date = tar.mm ;
                c_arst++; mri ++ ;
                if (c_arst==arst){
                    arst += 256 ;
                    remem=realloc (mem_g , (szYR * arst) );
                    if (remem==NULL) {
                        if(mem_g!=NULL) { free(mem_g); mem_g=NULL; }
                        arst = c_arst = 0;
                        information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                        return ;
                    }
                    mem_g=remem;
                    mri_1 = mri = ( struct YearRec *) mem_g;
                    mri += c_arst ;
                }
            }
        }
        
        // Υπολογισμός επόμενου tar
        
        if (tar.damo[0]==tmo[tar.damo[1]]) {
            if (tar.damo[1]==12) { break ; }
            tar.damo[0]=1;
            tar.damo[1] ++ ;
        }
        else { tar.damo[0] ++ ; } 
        dd = (dd == 7) ? 1 : dd + 1; 
        
    }
    
}



void month_recur_week ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo)
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : πριν την κλήση του loop που βλέπει όλες τις δομές πρέπει : c_arma = 0;   mra = mra_1 ;
// Ενημερώνει γενικό πίνακα mra για το συγκεκριμένο umonth
// freq = 7 , κάθε εβδομάδα την τάδε ημέρα
{
       if (rcr[a].anast) { return ; }
       

register int f ;   
short int s ;
short int tmo[13] ;    
unsigned short int dd ;


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    
    // Αν το τέλος μήνα ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}


         
    
    if (tar.ak < ami.ak) {tar.ak = ami.ak; dd = startmonth ;}
    else { dd = rcr[a].enarday ; }
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός που έχει επεκταθεί με +alarm ημέρες
    
    s = 0 ;
    
    while ( tar.ak <= tmi.ak ) {
        if ( dd == rcr[a].weekday ) { 
            if (mem_a != NULL) {
                mra->dom = (unsigned short int) a ;
                mra->date = tar.mm ;
                c_arma++; mra ++ ;
                if (c_arma==arma){
                    arma += 64 ;
                    remem=realloc (mem_a , (szYR * arma) );
                    if (remem==NULL) {
                        if(mem_a!=NULL) { free(mem_a); mem_a=NULL; }
                        arma = c_arma = 0;
                        information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                        return ;
                    }
                    mem_a=remem;
                    mra_1 = mra = ( struct YearRec *) mem_a;
                    mra += c_arma ;
                }
            }
        }
        // Υπολογισμός επόμενου tar
        
        tar.damo[0] ++ ; 
        if (tar.damo[0]>mo[tar.damo[1]]) { break; }
        dd = (dd == 7) ? 1 : dd + 1;  
    }
}


void recur_month_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo)
//freq = 31
//Κάθε μήνα την 1η Κυριακή : which=1 , weekday=1
//Κάθε μήνα το τελευταίο Σάββατο : which=5 , weekday = 7
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth
// Καλύπτει freq=31 - κάθε μήνα την τάδε (which) Κυριακή (weekday) ή την τάδε Δευτέρα ή την τελευταία Τετάρτη κλπ
{

       if (rcr[a].anast) { return ; }
       
register int f ;   
short int s , s1 ;   
unsigned short int dd , r , w , wd ;


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    // + ALarm
    
    for (f=0 ; f<rcr[a].alarm ; f++) {
        if (tmi.damo[0] == mo[tmi.damo[1]]) {
            tmi.damo[0]=1;
            tmi.damo[1] = (tmi.damo[1] == 12) ? 1 : tmi.damo[1] + 1 ;
        }
        else { tmi.damo[0] += 1; continue; }
        
        if (tmi.damo[1]==1) {
            tmi.yr[1] += 1 ;
            // Δεν χρειάζεται νέος υπολογισμός mo[2]
        }
    }
    
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 

    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    // Σήμερα
    si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
       
    wd = rcr[a].weekday ;
    
    // Έλεγχος για τελευταία ημέρα 
    
    if (rcr[a].which==5) {
        dd = startmonth ; 
        r = (dd == wd) ? 1 : 0 ;
        for (f=2; f<=mo[umonth]; f++) {
            dd = (dd == 7) ? 1 : dd + 1;
            if (dd == wd) { r++; }
        }
        
        w = r ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η w !
        
    } else { w = rcr[a].which ; }
    
        
    if (tar.ak < ami.ak) {
        tar.ak = ami.ak; 
        dd = startmonth ; 
        r = (dd == wd) ? 1 : 0 ; }
    else { 
        dd = startmonth;
        r = (dd == wd) ? 1 : 0 ; 
        pre.ak = ami.ak ;
        
        while (tar.ak > pre.ak) {
            
            if (pre.damo[0] == mo[pre.damo[1]]) {
                pre.damo[0]=1;
                pre.damo[1] = (pre.damo[1] == 12) ? 1 : pre.damo[1] + 1 ;
                dd = (dd == 7) ? 1 : dd + 1;
                r = (dd == wd) ? 1 : 0 ;
            }
            else { pre.damo[0] ++; 
                    dd = (dd == 7) ? 1 : dd + 1; 
                    if (dd == wd) { r++ ; }  
                    continue; 
            }
            
            if (pre.damo[1]==1) {
                pre.yr[1] ++ ;
                }
            }
        }
    
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός που έχει επεκταθεί με +alarm ημέρες
    
    s = s1 = 0 ;
    
    while ( tar.ak <= tmi.ak ) {
        if  ( (dd == wd) && (r == w) ) {
            if ( tar.damo[1] == umonth ) { only[umonth][tar.damo[0]] = 1 ; s1 = 1; }
            if (!s) {
                if ( tar.ak == si.ak ) {clue[a]=1; s=1 ;}
                else if ( tar.ak > si.ak ) {
                    // Ψάχνω μήπως το σήμερα είναι προειδοποίηση
                    pre.ak = tar.ak ;
                    //pre.yr[1] = tar.yr[1];
                    //pre.mm = tar.mm ;
                    for (f=1 ; f<=rcr[a].alarm ; f++) {
                        if (pre.damo[0]>1) { 
                            pre.damo[0] -- ; 
                            if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ; break; }
                            continue ;
                        }
                        else {
                            pre.damo[1] = (pre.damo[1] == 1) ? 12 : pre.damo[1] - 1 ; 
                        }
                        
                        if (pre.damo[1]==12) {
                            pre.damo[0] = 31 ;
                            pre.yr[1] --;
                        } else { pre.damo[0] = mo[pre.damo[1]]; }
                        
                        if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ;  break; }
                    }
                }
            }
        }
        
        if ( (s) && (s1) ) break ;
        
        // Υπολογισμός επόμενου tar
        
        if (tar.damo[0] == mo[tar.damo[1]]) {
            tar.damo[0]=1;
            tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            dd = (dd == 7) ? 1 : dd + 1;
            r = (dd == wd) ? 1 : 0 ; 
            if (tar.damo[1] == 1) { tar.yr[1] ++ ; }
        }
        else { 
            tar.damo[0] ++ ; 
            dd = (dd == 7) ? 1 : dd + 1; 
            if (dd == wd) { r++ ; } 
            continue; 
        }
    }
}


void month_recur_month_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo)
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : πριν την κλήση του loop που βλέπει όλες τις δομές πρέπει : c_arma = 0;   mra = mra_1 ;
// Ενημερώνει γενικό πίνακα mra
// Καλύπτει freq=31 - κάθε μήνα την τάδε (which) Κυριακή (weekday) ή την τάδε Δευτέρα ή την τελευταία Τετάρτη κλπ
{

       if (rcr[a].anast) { return ; }
       
register int f ;     
unsigned short int dd , r , w , wd ;


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός 
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    
    // Αν το τέλος μήνα ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
       
    wd = rcr[a].weekday ;
    
    // Έλεγχος για τελευταία ζητούμενη ημέρα μηνός
    
    if (rcr[a].which==5) {
        dd = startmonth ; 
        r = (dd == wd) ? 1 : 0 ;
        for (f=2; f<=mo[umonth]; f++) {
            dd = (dd == 7) ? 1 : dd + 1;
            if (dd == wd) { r++; }
        }
        
        w = r ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η υπ' αριμ. w !
        
    } else { w = rcr[a].which ; }
    
    
    if (tar.ak < ami.ak) {
        tar.ak = ami.ak; 
        dd = startmonth ; 
        r = (dd == wd) ? 1 : 0 ; }
    else { 
        //dd = rcr[a].enarday ;
        dd = startmonth;
        r = (dd == wd) ? 1 : 0 ; 
        pre.ak = ami.ak ;
        
        // Βλέπω πόσες ζητούμενες ημέρες πέρασαν ήδη επειδή το tar > ami  ...
        while (tar.ak > pre.ak) {
            
            pre.damo[0] ++; 
            dd = (dd == 7) ? 1 : dd + 1; 
            if (dd == wd) { r++ ; }  

            }
        }
    
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός
    
    
    while ( tar.ak <= tmi.ak ) {
        if  ( (dd == wd) && (r == w) ) {
            if (mem_a != NULL) {
                mra->dom = (unsigned short int) a ;
                mra->date = tar.mm ;
                c_arma++; mra ++ ;
                if (c_arma==arma){
                    arma += 64 ;
                    remem=realloc (mem_a , (szYR * arma) );
                    if (remem==NULL) {
                        if(mem_a!=NULL) { free(mem_a); mem_a=NULL; }
                        arma = c_arma = 0;
                        information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                        return ;
                    }
                    mem_a=remem;
                    mra_1 = mra = ( struct YearRec *) mem_a;
                    mra += c_arma ;
                }
            }
            
            break ;
        }
        
        // Υπολογισμός επόμενου tar
        if (tar.damo[0] == mo[umonth]) break ;
        tar.damo[0] ++ ; 
        dd = (dd == 7) ? 1 : dd + 1; 
        if (dd == wd) { r++ ; } 
    }
}



void year_recur_month_w ( int a , unsigned short int uyear , unsigned char yonly[][32])
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : πριν την κλήση του loop που βλέπει όλες τις δομές πρέπει : c_arma = 0;   mra = mra_1 ;
// Ενημερώνει γενικό πίνακα mra
// Καλύπτει freq=31 - κάθε μήνα την τάδε (which) Κυριακή (weekday) ή την τάδε Δευτέρα ή την τελευταία Τετάρτη κλπ
{

       if (etrcr[a].anast) { return ; }
       
register int f ;     
unsigned short int dd , r , r1, w , wd , dd2 , s ;
short int tmo[13] ;

    // Αρχή year
    
    ami.damo[0] = 1 ; ami.damo[1] = 1 ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = etrcr[a].perasyear ;
    eos.damo[0] = (unsigned char) etrcr[a].perasdate ;
    eos.damo[1] = (unsigned char) etrcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = etrcr[a].enaryear ;
    tar.damo[0] = (unsigned char) etrcr[a].enardate ;
    tar.damo[1] = (unsigned char) etrcr[a].enarmonth ;

    // Τέλος τρέχοντος
    
    tyear.damo[1] = 12 ;
    tyear.damo[0] = 31 ;
    tyear.yr[1] = uyear ;
    
    
    // Αν το τέλος μήνα ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tyear.ak > eos.ak) { tyear.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα τότε ... έφυγες.
    if (tar.ak > tyear.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
       
    wd = etrcr[a].weekday ;
    
    if (tar.ak < ami.ak) {
        tar.ak = ami.ak; 
        dd = find_dayname(uyear , 1 , 1) ;
        r = (dd == wd) ? 1 : 0 ; 
        dd2 = dd ;
        
    // Έλεγχος για τελευταία ζητούμενη ημέρα μηνός
    
        if (etrcr[a].which==5) {
            r1 = r ;
            for (f=2; f<=tmo[1]; f++) {
                dd2 = (dd2 == 7) ? 1 : dd2 + 1;
                if (dd2 == wd) { r1++; }
            }
            
            w = r1 ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η υπ' αριμ. w !
            
        } else { w = etrcr[a].which ; }
        
    }
    else { 
        //dd = etrcr[a].enarday ;
        dd = find_dayname(uyear , etrcr[a].enarmonth , 1);
        r = (dd == wd) ? 1 : 0 ; 
        dd2 = dd ;
        // Έλεγχος για τελευταία ζητούμενη ημέρα μηνός , είναι 4η ή 5η ;
        
        if (etrcr[a].which==5) {
            r1 = r ;
            for (f=2; f<=tmo[etrcr[a].enarmonth]; f++) {
                dd2 = (dd2 == 7) ? 1 : dd2 + 1;
                if (dd2 == wd) { r1++; }
            }
            
            w = r1 ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η υπ' αριμ. w !
            
        } else { w = etrcr[a].which ; }
        
        pre.yr[1] = uyear ;
        pre.damo[0] = 1 ; pre.damo[1] = etrcr[a].enarmonth ;
        
        // Βλέπω πόσες ζητούμενες ημέρες πέρασαν στο μήνα που είμαστε  επειδή το tar > ami  ...
        while (tar.ak > pre.ak) {
            pre.damo[0] ++; 
            dd = (dd == 7) ? 1 : dd + 1; 
            if (dd == wd) { r++ ; }  

            }
        }
    
    
    // tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος έτους
    
    s=0 ;
    
    while ( tar.ak <= tyear.ak ) {
        if  ( (dd == wd) && (r == w) ) {
            
            s=1 ;
            yonly[tar.damo[1]][tar.damo[0]] = 1 ;
            
            if (mem_g != NULL) {
                mri->dom = (unsigned short int) a ;
                mri->date = tar.mm ;
                c_arst++; mri ++ ;
                if (c_arst==arst){
                    arst += 256 ;
                    remem=realloc (mem_g , (szYR * arst) );
                    if (remem==NULL) {
                        if(mem_g!=NULL) { free(mem_g); mem_g=NULL; }
                        arst = c_arst = 0;
                        information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                        return ;
                    }
                    mem_g=remem;
                    mri_1 = mri = ( struct YearRec *) mem_g;
                    mri += c_arst ;
                }
            }

        }
        
        if (s) {
            s=0;
            for (f=tar.damo[0]+1 ; f<=tmo[tar.damo[1]] ; f++) {
                tar.damo[0] ++ ;
                dd = (dd == 7) ? 1 : dd + 1; 
            }
            
            if (tar.damo[1] == 12) return ;
            tar.damo[0]=1;
            dd = (dd == 7) ? 1 : dd + 1;
            r = (dd == wd) ? 1 : 0 ;
            tar.damo[1]++;
            
            // Έλεγχος για τελευταία ζητούμενη ημέρα μηνός
            dd2 = dd ;
            if (etrcr[a].which==5) {
                r1 = r ;
                for (f=2; f<=tmo[tar.damo[1]]; f++) {
                    dd2 = (dd2 == 7) ? 1 : dd2 + 1;
                    if (dd2 == wd) { r1++; }
                }
                
                w = r1 ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η υπ' αριμ. w !
                
            } else { w = etrcr[a].which ; }
            
            continue ;
        }
        
        // Υπολογισμός επόμενου tar
        
        if (tar.damo[0] == tmo[tar.damo[1]]) {
            if (tar.damo[1] == 12) return ;
            tar.damo[0]=1;
            dd = (dd == 7) ? 1 : dd + 1;
            r = (dd == wd) ? 1 : 0 ;
            tar.damo[1]++;
            // Έλεγχος για τελευταία ζητούμενη ημέρα μηνός
            dd2 = dd ;
            if (etrcr[a].which==5) {
                r1 = r ;
                for (f=2; f<=tmo[tar.damo[1]]; f++) {
                    dd2 = (dd2 == 7) ? 1 : dd2 + 1;
                    if (dd2 == wd) { r1++; }
                }
                
                w = r1 ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η υπ' αριμ. w !
                
            } else { w = etrcr[a].which ; }
            
            continue ;
        }
        
        tar.damo[0] ++ ; 
        dd = (dd == 7) ? 1 : dd + 1; 
        if (dd == wd) { r++ ; } 
    }
}


/*
freq = 30 : Κάθε Μήνα 
Παράδειγμα για freq = 30
Κάθε μήνα στις 23 του μήνα : enardate=23 - monthlast=0;
Κάθε μήνα την τελευταία ημέρα του μήνα  monthlast=1 

freq = 31
Κάθε μήνα την 1η Κυριακή : which=1 , weekday=1
Κάθε μήνα το τελευταίο Σάββατο : which=5 , weekday = 7
*/



void recur_month_st ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo)
//freq = 30 : Κάθε Μήνα 
//Παράδειγμα για freq = 30
//Κάθε μήνα στις 23 του μήνα : monthlast=0  - enardate=23 ;
//Κάθε μήνα την τελευταία ημέρα του μήνα  monthlast=1 
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth

{

       if (rcr[a].anast) { return ; }
       
register int f ;   

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    // + ALarm
    
    for (f=0 ; f<rcr[a].alarm ; f++) {
        if (tmi.damo[0] == mo[tmi.damo[1]]) {
            tmi.damo[0]=1;
            tmi.damo[1] = (tmi.damo[1] == 12) ? 1 : tmi.damo[1] + 1 ;
        }
        else { tmi.damo[0] ++; continue; }
        
        if (tmi.damo[1]==1) {
            tmi.yr[1] ++ ;
            // Δεν χρειάζεται νέος υπολογισμός mo[2]
        }
    }
    
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

   
    // ΠΡΟΧΩΡΑΜΕ...
    
    // Σήμερα
    si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
    
    tar.yr[1] = uyear ;
    tar.damo[1] = umonth ;
    
    if (!rcr[a].monthlast) {
        // Συγκεκριμένη ημερομηνία
        
        if (mo[umonth] < rcr[a].enardate) { return ; }
        tar.damo[0] = rcr[a].enardate ;
    }
    else {
        // Τελευταία ημέρα του μήνα
        
        tar.damo[0] = mo[umonth] ;
    }
       
    while (tar.ak <= tmi.ak) {
        if ( tar.damo[1] == umonth ) { only[umonth][tar.damo[0]] = 1 ; }
        if ( tar.ak == si.ak ) { clue[a]=1; }
        else if ( tar.ak > si.ak ) {
            // Ψάχνω μήπως το σήμερα είναι προειδοποίηση
            pre.ak = tar.ak ;
            for (f=1 ; f<=rcr[a].alarm ; f++) {
                if (pre.damo[0]>1) { 
                    pre.damo[0] -- ; 
                    if (pre.ak == si.ak) { proclue[a] = (short int) f ; break; }
                    continue ;
                }
                else {
                    pre.damo[1] = (pre.damo[1] == 1) ? 12 : pre.damo[1] - 1 ; 
                }
                
                if (pre.damo[1]==12) {
                    pre.damo[0] = 31 ;
                    pre.yr[1] --;
                } else { pre.damo[0] = mo[pre.damo[1]]; }
                
                if (pre.ak == si.ak) { proclue[a] = (short int) f ;  break; }
            }
        }
        
        tar.damo[1]++;
        
        if (tar.damo[1]==13) {
            tar.damo[1]=1;
            tar.yr[1]++;
        }
        
        if (!rcr[a].monthlast) {
            // Συγκεκριμένη ημερομηνία
            
            if (mo[tar.damo[1]] < rcr[a].enardate) { return ; }
            tar.damo[0] = rcr[a].enardate ;
        }
        else {
            // Τελευταία ημέρα του μήνα
            
            tar.damo[0] = mo[tar.damo[1]] ;
        }
    }
}


void month_recur_month_st ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo)
//freq = 30 : Κάθε Μήνα 
//Παράδειγμα για freq = 30
//Κάθε μήνα στις 23 του μήνα : monthlast=0 και enardate = 23 ;
//Κάθε μήνα την τελευταία ημέρα του μήνα  monthlast=1 
// a = αριθμός δομής της περιοδικής υπόμνησης
// Ενημερώνει γενικό πίνακα mra


{

       if (rcr[a].anast) { return ; }
       
register int f ;   

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
       
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

   
    // ΠΡΟΧΩΡΑΜΕ...
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;

        tar.yr[1] = uyear ;
        tar.damo[1] = umonth ;

    
    if (!rcr[a].monthlast) {
        // Συγκεκριμένη ημερομηνία
        
        if (mo[tar.damo[1]] < rcr[a].enardate) { return ; }
        tar.damo[0] = rcr[a].enardate ;
    }
    else {
        // Τελευταία ημέρα του μήνα
        
        tar.damo[0] = mo[tar.damo[1]] ;
    }
    
        if (mem_a != NULL) {
            mra->dom = (unsigned short int) a ;
            mra->date = tar.mm ;
            c_arma++; mra ++ ;
            if (c_arma==arma){
                arma += 64 ;
                remem=realloc (mem_a , (szYR * arma) );
                if (remem==NULL) {
                    if(mem_a!=NULL) { free(mem_a); mem_a=NULL; }
                    arma = c_arma = 0;
                    information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                    return ;
                }
                mem_a=remem;
                mra_1 = mra = ( struct YearRec *) mem_a;
                mra += c_arma ;
            }
        }
    
}



void year_recur_month_st ( int a , unsigned short int uyear , unsigned char yonly[][32])
//freq = 30 : Κάθε Μήνα 
//Παράδειγμα για freq = 30
//Κάθε μήνα στις 23 του μήνα : monthlast=0 - enardate = 23 ;
//Κάθε μήνα την τελευταία ημέρα του μήνα  monthlast=1 
// a = αριθμός δομής της περιοδικής υπόμνησης
// Ενημερώνει γενικό πίνακα mri και yonly[13][32] 

{

       if (etrcr[a].anast) { return ; }
       
register int f ;   
short int tmo[13];

    // Αρχή Year
    
    ami.damo[0] = 1 ; ami.damo[1] = 1 ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = etrcr[a].perasyear ;
    eos.damo[0] = (unsigned char) etrcr[a].perasdate ;
    eos.damo[1] = (unsigned char) etrcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή Year
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = etrcr[a].enaryear ;
    tar.damo[0] = (unsigned char) etrcr[a].enardate ;
    tar.damo[1] = (unsigned char) etrcr[a].enarmonth ;

    // Τέλος τρέχοντος Year
    
    tmi.damo[1] = 12 ;
    tmi.damo[0] = 31 ;
    tmi.yr[1] = uyear ;
    
    // Αν το τέλος Year ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος Year τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

   
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
    if (tar.ak <= ami.ak) {
        tar.yr[1] = uyear ;
        tar.damo[1] = 1 ;
    }
    else {
        tar.yr[1] = uyear ;
        tar.damo[1] = etrcr[a].enarmonth ;
    }
    
    if (!etrcr[a].monthlast) {
        // Συγκεκριμένη ημερομηνία
        while (tmo[tar.damo[1]] < etrcr[a].enardate) { 
            if (tar.damo[1]==12) return ;
            tar.damo[1]++;
        }
        tar.damo[0] = etrcr[a].enardate ;
    }
    else {
        // Τελευταία ημέρα του μήνα
        tar.damo[0] = tmo[tar.damo[1]] ;
    }
       
    while (tar.ak <= tmi.ak) {
        
        yonly[tar.damo[1]][tar.damo[0]] = 1 ;
        
        if (mem_g != NULL) {
            mri->dom = (unsigned short int) a ;
            mri->date = tar.mm ;
            c_arst++; mri ++ ;
            if (c_arst==arst){
                arst += 256 ;
                remem=realloc (mem_g , (szYR * arst) );
                if (remem==NULL) {
                    if(mem_g!=NULL) { free(mem_g); mem_g=NULL; }
                    arst = c_arst = 0;
                    information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                    return ;
                }
                mem_g=remem;
                mri_1 = mri = ( struct YearRec *) mem_g;
                mri += c_arst ;
            }
        }
        
        if (tar.damo[1]==12) return ;
        
        tar.damo[1]++;
        
        if (!etrcr[a].monthlast) {
            // Συγκεκριμένη ημερομηνία
            
            if (tmo[tar.damo[1]] < etrcr[a].enardate) { continue ; }
            tar.damo[0] = etrcr[a].enardate ;
        }
        else {
            // Τελευταία ημέρα του μήνα
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
    }
}




void recur_month_bima ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , short int *mo)
//freq = 32 : Κάθε τόσους μήνες αρχής γενομένης από τάδε ημερομηνία (κατά προσέγγιση) 
//Παράδειγμα για freq = 32
//Κάθε 3 μήνες με έναρξη 23 του τάδε μήνα : enardate=23 ; step = 3
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth

{

       if (rcr[a].anast) { return ; }
       
register int f ;   
short int tmo[13] ;

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    // + ALarm
    
    for (f=0 ; f<rcr[a].alarm ; f++) {
        if (tmi.damo[0] == mo[tmi.damo[1]]) {
            tmi.damo[0]=1;
            tmi.damo[1] = (tmi.damo[1] == 12) ? 1 : tmi.damo[1] + 1 ;
        }
        else { tmi.damo[0] ++; continue; }
        
        if (tmi.damo[1]==1) {
            tmi.yr[1] ++ ;
            // Δεν χρειάζεται νέος υπολογισμός mo[2]
        }
    }
    
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
   
    while (tar.ak < ami.ak) {
        tar.damo[1] += rcr[a].step;
        if (tar.damo[1] > 12 ) {
            tar.damo[1] -= 12 ;
            tar.yr[1]++;
            // Υπολογισμός tmo[2] για tar.yr[1]
            if (tar.yr[1]%4) tmo[2]=28;
            else {
                if (tar.yr[1]%100) tmo[2]=29;
                else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
            }
        }
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) {
           tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = rcr[a].enardate;}
            
    }
    

    
    while (tar.ak <= tmi.ak) {
        if ( tar.damo[1] == umonth ) { only[umonth][tar.damo[0]] = 1 ; }
        if ( tar.ak == si.ak ) { clue[a]=1; }
        else if ( tar.ak > si.ak ) {
            // Ψάχνω μήπως το σήμερα είναι προειδοποίηση
            pre.ak = tar.ak ;
            for (f=1 ; f<=rcr[a].alarm ; f++) {
                if (pre.damo[0]>1) { 
                    pre.damo[0] -- ; 
                    if (pre.ak == si.ak) { proclue[a] = (short int) f ; break; }
                    continue ;
                }
                else {
                    pre.damo[1] = (pre.damo[1] == 1) ? 12 : pre.damo[1] - 1 ; 
                }
                
                if (pre.damo[1]==12) {
                    pre.damo[0] = 31 ;
                    pre.yr[1] --;
                } else { pre.damo[0] = tmo[pre.damo[1]]; }
                
                if (pre.ak == si.ak) { proclue[a] = (short int) f ;  break; }
            }
        }
        
        tar.damo[1] += rcr[a].step;
        if (tar.damo[1] > 12 ) {
            tar.damo[1] -= 12 ;
            tar.yr[1]++;
            // Υπολογισμός tmo[2] για tar.yr[1]
            if (tar.yr[1]%4) tmo[2]=28;
            else {
                if (tar.yr[1]%100) tmo[2]=29;
                else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
            }
        }
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = rcr[a].enardate;}
        
    }
}



void month_recur_month_bima ( int a , unsigned short int uyear , unsigned short int umonth , short int *mo)
//freq = 32 : Κάθε τόσους μήνες αρχής γενομένης από τάδε ημερομηνία (κατά προσέγγιση) 
//Παράδειγμα για freq = 32
//Κάθε 3 μήνες με έναρξη 23 του τάδε μήνα : enardate=23 ; step = 3
// a = αριθμός δομής της περιοδικής υπόμνησης
// Ενημερώνει πίνακα mra για το συγκεκριμένο umonth

{
  
       if (rcr[a].anast) { return ; }
       
short int tmo[13] ;

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
        
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
   
    while (tar.ak < ami.ak) {
        tar.damo[1] += rcr[a].step;
        if (tar.damo[1] > 12 ) {
            tar.damo[1] -= 12 ;
            tar.yr[1]++;
            // Υπολογισμός tmo[2] για tar.yr[1]
            if (tar.yr[1]%4) tmo[2]=28;
            else {
                if (tar.yr[1]%100) tmo[2]=29;
                else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
            }
        }
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = rcr[a].enardate;}
    }
    

    
    if (tar.ak<=tmi.ak) {
    
        if (mem_a != NULL) {
            mra->dom = (unsigned short int) a ;
            mra->date = tar.mm ;
            c_arma++; mra ++ ;
            if (c_arma==arma){
                arma += 64 ;
                remem=realloc (mem_a , (szYR * arma) );
                if (remem==NULL) {
                    if(mem_a!=NULL) { free(mem_a); mem_a=NULL; }
                    arma = c_arma = 0;
                    information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                    return ;
                }
                mem_a=remem;
                mra_1 = mra = ( struct YearRec *) mem_a;
                mra += c_arma ;
            }
        }
    }
}



void year_recur_month_bima ( int a , unsigned short int uyear , unsigned char yonly[][32])
//freq = 32 : Κάθε τόσους μήνες (από 1 έως 11) αρχής γενομένης από τάδε ημερομηνία (κατά προσέγγιση) 
//Παράδειγμα για freq = 32
//Κάθε 3 μήνες με έναρξη 23 του τάδε μήνα : enardate=23 ; step = 3
// a = αριθμός δομής της περιοδικής υπόμνησης
// Ενημερώνει πίνακα mra για το συγκεκριμένο umonth

{
 
       if (etrcr[a].anast) { return ; }
       
short int tmo[13] ;

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = 1 ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = etrcr[a].perasyear ;
    eos.damo[0] = (unsigned char) etrcr[a].perasdate ;
    eos.damo[1] = (unsigned char) etrcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = etrcr[a].enaryear ;
    tar.damo[0] = (unsigned char) etrcr[a].enardate ;
    tar.damo[1] = (unsigned char) etrcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = 12 ;
    tmi.damo[0] = 31 ;
    tmi.yr[1] = uyear ;
        
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
   
    while (tar.ak < ami.ak) {
        tar.damo[1] += etrcr[a].step;
        if (tar.damo[1] > 12 ) {
            tar.damo[1] -= 12 ;
            tar.yr[1]++;
            // Υπολογισμός tmo[2] για tar.yr[1]
            if (tar.yr[1]%4) tmo[2]=28;
            else {
                if (tar.yr[1]%100) tmo[2]=29;
                else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
            }
        }
        
        if (tmo[tar.damo[1]] < etrcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = etrcr[a].enardate;}
    }
    

    
    while (tar.ak<=tmi.ak) {
    
        yonly[tar.damo[1]][tar.damo[0]] = 1 ;
        
        if (mem_g != NULL) {
            mri->dom = (unsigned short int) a ;
            mri->date = tar.mm ;
            c_arst++; mri ++ ;
            if (c_arst==arst){
                arst += 256 ;
                remem=realloc (mem_g , (szYR * arst) );
                if (remem==NULL) {
                    if(mem_g!=NULL) { free(mem_g); mem_g=NULL; }
                    arst = c_arst = 0;
                    information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                    return ;
                }
                mem_g=remem;
                mri_1 = mri = ( struct YearRec *) mem_g;
                mri += c_arst ;
            }
        }
        
        tar.damo[1] += etrcr[a].step;
        if (tar.damo[1] > 12 ) {
            tar.damo[1] -= 12 ;
            tar.yr[1]++;
            // Υπολογισμός tmo[2] για tar.yr[1]
            if (tar.yr[1]%4) tmo[2]=28;
            else {
                if (tar.yr[1]%100) tmo[2]=29;
                else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
            }
        }
        
        if (tmo[tar.damo[1]] < etrcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = etrcr[a].enardate;}
        
    }
}



void recur_year_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate , unsigned short int startmonth ,short int *mo)
//freq = 366
//Κάθε τόσα χρόνια (step=1 έως 10) το μήνα enarmonth την 1η Κυριακή : which=1 , weekday=1
//Κάθε step χρόνια το μήνα enarmonth το τελευταίο Σάββατο : which=5 (τελευταίο) , weekday = 7
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth

{
    
       if (rcr[a].anast) { return ; }
       
register int f ;   
short int s , s1 ;   
unsigned short int dd , r , w , wd  ;
short int tmo[13];


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    // + ALarm
    
    for (f=0 ; f<rcr[a].alarm ; f++) {
        if (tmi.damo[0] == mo[tmi.damo[1]]) {
            tmi.damo[0]=1;
            tmi.damo[1] = (tmi.damo[1] == 12) ? 1 : tmi.damo[1] + 1 ;
        }
        else { tmi.damo[0] += 1; continue; }
        
        if (tmi.damo[1]==1) {
            tmi.yr[1] ++ ;
            // Δεν χρειάζεται νέος υπολογισμός mo[2]
        }
    }
    
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 

    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

    
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
    s=0 ;
    
    if (tar.yr[1] < uyear) s = 1 ;
    
    while (tar.ak < ami.ak) {
        tar.yr[1] += rcr[a].step;
        // Υπολογισμός tmo[2] για tar.yr[1]
        if (tar.yr[1]%4) tmo[2]=28;
        else {
            if (tar.yr[1]%100) tmo[2]=29;
            else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
        }
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = rcr[a].enardate;}
    }
    
    if (tar.ak > tmi.ak) return ;
    
    wd = rcr[a].weekday ;
    
    // Έλεγχος για τελευταία ζητούμενη ημέρα τρέχοντος μηνός umonth (αν ζητείται ας πούμε τελευταία Δευτέρα ή τελεταία Τρίτη ) 
    
    if (rcr[a].which==5) {
        dd = startmonth ; 
        r = (dd == wd) ? 1 : 0 ;
        for (f=2; f<=mo[umonth]; f++) {
            dd = (dd == 7) ? 1 : dd + 1;
            if (dd == wd) { r++; }
        }
        
        w = r ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η w !
        
    } else { w = rcr[a].which ; }
        
        dd = startmonth;
        r = (dd == wd) ? 1 : 0 ; 
        
        if (!s) {  // χρονιά έναρξης υπόμνησης = uyear 
            
            pre.ak = ami.ak ;
            
            while (tar.ak > pre.ak) {
                
                if (pre.damo[0] == mo[pre.damo[1]]) {
                    pre.damo[0]=1;
                    pre.damo[1] = (pre.damo[1] == 12) ? 1 : pre.damo[1] + 1 ;
                    dd = (dd == 7) ? 1 : dd + 1;
                    r = (dd == wd) ? 1 : 0 ;
                }
                else { pre.damo[0] ++; 
                        dd = (dd == 7) ? 1 : dd + 1; 
                        if (dd == wd) { r++ ; }  
                        continue; 
                }
                
                if (pre.damo[1]==1) {
                    pre.yr[1] ++ ;
                    }
                }
        }
        else {tar.ak = ami.ak;}
        
    
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός που έχει επεκταθεί με +alarm ημέρες
    
    s = s1 = 0 ;
    
    while ( tar.ak <= tmi.ak ) {
        if  ( (dd == wd) && (r == w) ) {
            if ( tar.damo[1] == umonth ) { only[umonth][tar.damo[0]] = 1 ; s1 = 1; }
            if (!s) {
                if ( tar.ak == si.ak ) {clue[a]=1; s=1 ;}
                else if ( tar.ak > si.ak ) {
                    // Ψάχνω μήπως το σήμερα είναι προειδοποίηση
                    pre.ak = tar.ak ;
                    for (f=1 ; f<=rcr[a].alarm ; f++) {
                        if (pre.damo[0]>1) { 
                            pre.damo[0] -- ; 
                            if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ; break; }
                            continue ;
                        }
                        else {
                            pre.damo[1] = (pre.damo[1] == 1) ? 12 : pre.damo[1] - 1 ; 
                        }
                        
                        if (pre.damo[1]==12) {
                            pre.damo[0] = 31 ;
                            pre.yr[1] --;
                        } else { pre.damo[0] = tmo[pre.damo[1]]; }
                        
                        if (pre.ak == si.ak) { s=1; proclue[a] = (short int) f ;  break; }
                    }
                }
            }
        }
        
        if ( (s) && (s1) ) break ;
        
        // Υπολογισμός επόμενου tar
        
        if (tar.damo[0] == tmo[tar.damo[1]]) {
            tar.damo[0]=1;
            tar.damo[1] = (tar.damo[1] == 12) ? 1 : tar.damo[1] + 1 ;
            dd = (dd == 7) ? 1 : dd + 1;
            r = (dd == wd) ? 1 : 0 ; 
            if (tar.damo[1] == 1) { tar.yr[1] ++ ; }
        }
        else { 
            tar.damo[0] ++ ; 
            dd = (dd == 7) ? 1 : dd + 1; 
            if (dd == wd) { r++ ; } 
            continue; 
        }
    }
}



void month_recur_year_w ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int startmonth ,short int *mo)
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : πριν την κλήση του loop που βλέπει όλες τις δομές πρέπει : c_arma = 0;   mra = mra_1 ;
// Ενημερώνει γενικό πίνακα mra
//freq = 366
//Κάθε τόσα χρόνια (step=1 έως 10) το μήνα enarmonth την 1η Κυριακή : which=1 , weekday=1
//Κάθε step χρόνια το μήνα enarmonth το τελευταίο Σάββατο : which=5 (τελευταίο) , weekday = 7
{

       if (rcr[a].anast) { return ; }
       
register int f ;     
unsigned short int dd , r , w , wd ,s ;
short int tmo[13];


    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός 
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    
    // Αν το τέλος μήνα ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}
    
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
    s=0 ;
    
    if (tar.yr[1] < uyear) s = 1 ;
    
    while (tar.ak < ami.ak) {
        tar.yr[1] += rcr[a].step;
        // Υπολογισμός tmo[2] για tar.yr[1]
        if (tar.yr[1]%4) tmo[2]=28;
        else {
            if (tar.yr[1]%100) tmo[2]=29;
            else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
        }
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = rcr[a].enardate;}
    }
    
    if (tar.ak > tmi.ak) return ;
       
    wd = rcr[a].weekday ;
    
    // Έλεγχος για τελευταία ζητούμενη ημέρα μηνός
    
    if (rcr[a].which==5) {
        dd = startmonth ; 
        r = (dd == wd) ? 1 : 0 ;
        for (f=2; f<=mo[umonth]; f++) {
            dd = (dd == 7) ? 1 : dd + 1;
            if (dd == wd) { r++; }
        }
        
        w = r ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η υπ' αριμ. w !
        
    } else { w = rcr[a].which ; }
    
    

        dd = startmonth;
        r = (dd == wd) ? 1 : 0 ; 
        pre.ak = ami.ak ;
        
    if (!s) {
        // Βλέπω πόσες φορές ενδεχομένως πέρασε ήδη η ζητούμενη ημέρα ΑΝ το tar > ami  ... και φθάνω πρακτικά στο enarday 
        while (tar.ak > pre.ak) {
            
            pre.damo[0] ++; 
            dd = (dd == 7) ? 1 : dd + 1; 
            if (dd == wd) { r++ ; }  

            }
    }
    else {tar.ak = ami.ak;}
        
    
    
    // Τώρα έχω tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος μηνός
    
    
    while ( tar.ak <= tmi.ak ) {
        if  ( (dd == wd) && (r == w) ) {
            if (mem_a != NULL) {
                mra->dom = (unsigned short int) a ;
                mra->date = tar.mm ;
                c_arma++; mra ++ ;
                if (c_arma==arma){
                    arma += 64 ;
                    remem=realloc (mem_a , (szYR * arma) );
                    if (remem==NULL) {
                        if(mem_a!=NULL) { free(mem_a); mem_a=NULL; }
                        arma = c_arma = 0;
                        information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                        return ;
                    }
                    mem_a=remem;
                    mra_1 = mra = ( struct YearRec *) mem_a;
                    mra += c_arma ;
                }
            }
            
            break ;
        }
        
        // Υπολογισμός επόμενου tar
        if (tar.damo[0] == mo[umonth]) break ;
        tar.damo[0] ++ ; 
        dd = (dd == 7) ? 1 : dd + 1; 
        if (dd == wd) { r++ ; } 
    }
}



void year_recur_year_w ( int a , unsigned short int uyear , unsigned char yonly[][32])
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : πριν την κλήση του loop που βλέπει όλες τις δομές πρέπει : c_arma = 0;   mra = mra_1 ;
// Ενημερώνει γενικό πίνακα mra
//freq = 366
//Κάθε τόσα χρόνια (step=1 έως 10) το μήνα enarmonth την 1η Κυριακή : which=1 , weekday=1
//Κάθε step χρόνια το μήνα enarmonth το τελευταίο Σάββατο : which=5 (τελευταίο) , weekday = 7
{

       if (etrcr[a].anast) { return ; }
       
register int f ;     
unsigned short int dd , r , r1, w , wd , dd2 , s ;
short int tmo[13] ;

    // Αρχή year
    
    ami.damo[0] = 1 ; ami.damo[1] = 1 ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = etrcr[a].perasyear ;
    eos.damo[0] = (unsigned char) etrcr[a].perasdate ;
    eos.damo[1] = (unsigned char) etrcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = etrcr[a].enaryear ;
    tar.damo[0] = (unsigned char) etrcr[a].enardate ;
    tar.damo[1] = (unsigned char) etrcr[a].enarmonth ;

    // Τέλος τρέχοντος
    
    tyear.damo[1] = 12 ;
    tyear.damo[0] = 31 ;
    tyear.yr[1] = uyear ;
    
    
    // Αν το τέλος μήνα ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tyear.ak > eos.ak) { tyear.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα τότε ... έφυγες.
    if (tar.ak > tyear.ak) {return ;}


   
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    // Σήμερα
    //si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;
    
    s=0 ;
    
    if (tar.yr[1] < uyear) s = 1 ;
    
    while (tar.ak < ami.ak) {
        tar.yr[1] += etrcr[a].step;
        // Υπολογισμός tmo[2] για tar.yr[1]
        if (tar.yr[1]%4) tmo[2]=28;
        else {
            if (tar.yr[1]%100) tmo[2]=29;
            else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
        }
        
        if (tmo[tar.damo[1]] < etrcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = etrcr[a].enardate;}
    }
    
    if (tar.ak > tyear.ak) return ;
       
    wd = etrcr[a].weekday ;

    //dd = rcr[a].enarday ;
    dd = find_dayname(uyear , etrcr[a].enarmonth , 1);
    r = (dd == wd) ? 1 : 0 ; 
    dd2 = dd ;
    // Έλεγχος για τελευταία ζητούμενη ημέρα μηνός , είναι 4η ή 5η ;
    
    if (etrcr[a].which==5) {
        r1 = r ;
        for (f=2; f<=tmo[etrcr[a].enarmonth]; f++) {
            dd2 = (dd2 == 7) ? 1 : dd2 + 1;
            if (dd2 == wd) { r1++; }
        }
        
        w = r1 ; // H τελευταία ζητούμενη ημέρα του μήνα (π.χ. Δευτέρα) είναι η υπ' αριμ. w !
        
    } else { w = etrcr[a].which ; }
    
    if (!s) {
        pre.yr[1] = uyear ;
        pre.damo[0] = 1 ; pre.damo[1] = etrcr[a].enarmonth ;
        
        // Βλέπω πόσες ζητούμενες ημέρες πέρασαν στο μήνα που είμαστε  επειδή το tar > ami  ...
        while (tar.ak > pre.ak) {
            pre.damo[0] ++; 
            dd = (dd == 7) ? 1 : dd + 1; 
            if (dd == wd) { r++ ; }  

            }
    }
    else {tar.damo[0]=1;}
    
    
    
    // tar.ak >= της αρχής τρέχοντος μήνα και tar.ak <= eos.ak
    
    // Συνεχίζω...όσο το tar.ak <= του τέλους τρέχοντος έτους
    
    
    while ( tar.ak <= tyear.ak ) {
        if  ( (dd == wd) && (r == w) ) {
            
            yonly[tar.damo[1]][tar.damo[0]] = 1 ;
            
            if (mem_g != NULL) {
                mri->dom = (unsigned short int) a ;
                mri->date = tar.mm ;
                c_arst++; mri ++ ;
                if (c_arst==arst){
                    arst += 256 ;
                    remem=realloc (mem_g , (szYR * arst) );
                    if (remem==NULL) {
                        if(mem_g!=NULL) { free(mem_g); mem_g=NULL; }
                        arst = c_arst = 0;
                        information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                        return ;
                    }
                    mem_g=remem;
                    mri_1 = mri = ( struct YearRec *) mem_g;
                    mri += c_arst ;
                }
            }
            
            return ;

        }
        
        
        // Υπολογισμός επόμενου tar
        
        if (tar.damo[0] == tmo[tar.damo[1]]) {
            
            return ;
        }
        
        tar.damo[0] ++ ; 
        dd = (dd == 7) ? 1 : dd + 1; 
        if (dd == wd) { r++ ; } 
    }
}



void recur_year_st ( int a , unsigned short int uyear , unsigned short int umonth , unsigned short int udate ,short int *mo)
//freq = 365 : Κάθε χρόνο ή κάθε step χρόνια , τον τάδε μήνα , τάδε ημερομηνία ή τελευταία ημέρα του μήνα 
//Παράδειγμα για freq = 365
//Κάθε step χρόνια στις 23 του μήνα Σεπτεμβρ. (step = 0-10 , enardate=23 , monthlast=0 , enarmonth=9 )
// Κάθε step χρόνια tην τελευταία ημέρα του μήνα Σεπτεμβρ. (step = 0-10 , monthlast=1 , enarmonth=9 )
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth


{

       if (rcr[a].anast) { return ; }
       
register int f ;   
short int tmo[13] ;

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;
    
    // + ALarm
    
    for (f=0 ; f<rcr[a].alarm ; f++) {
        if (tmi.damo[0] == mo[tmi.damo[1]]) {
            tmi.damo[0]=1;
            tmi.damo[1] = (tmi.damo[1] == 12) ? 1 : tmi.damo[1] + 1 ;
        }
        else { tmi.damo[0] ++; continue; }
        
        if (tmi.damo[1]==1) {
            tmi.yr[1] ++ ;
            // Δεν χρειάζεται νέος υπολογισμός mo[2]
        }
    }
    
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

   
    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    
    while (tar.ak < ami.ak) {
        tar.yr[1] += rcr[a].step;
        // Υπολογισμός tmo[2] για tar.yr[1]
        if (tar.yr[1]%4) tmo[2]=28;
        else {
            if (tar.yr[1]%100) tmo[2]=29;
            else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
        }
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = rcr[a].enardate;}
    }
        
    
    //if ( (tar.damo[0] != rcr[a].enardate) && (!rcr[a].monthlast) ) return ;
    
        if (!rcr[a].monthlast) {
        // Συγκεκριμένη ημερομηνία
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) { return ; }
        tar.damo[0] = rcr[a].enardate ;
    }
    else {
        // Τελευταία ημέρα του μήνα
        
        tar.damo[0] = tmo[tar.damo[1]] ;
    }
    
    if (tar.ak > tmi.ak) return ;
    
    // Σήμερα
    si.yr[1] = uyear ; si.damo[0] = (unsigned char) udate ; si.damo[1] = (unsigned char) umonth ;

    if ( tar.damo[1] == umonth ) { only[umonth][tar.damo[0]] = 1 ; }
    if ( tar.ak == si.ak ) { clue[a]=1; }
    else if ( tar.ak > si.ak ) {
        // Ψάχνω μήπως το σήμερα είναι προειδοποίηση
        pre.ak = tar.ak ;
        for (f=1 ; f<=rcr[a].alarm ; f++) {
            if (pre.damo[0]>1) { 
                pre.damo[0] -- ; 
                if (pre.ak == si.ak) { proclue[a] = (short int) f ; break; }
                continue ;
            }
            else {
                pre.damo[1] = (pre.damo[1] == 1) ? 12 : pre.damo[1] - 1 ; 
            }
            
            if (pre.damo[1]==12) {
                pre.damo[0] = 31 ;
                pre.yr[1] --;
            } else { pre.damo[0] = tmo[pre.damo[1]]; }
            
            if (pre.ak == si.ak) { proclue[a] = (short int) f ;  break; }
        }
    }
}


void month_recur_year_st ( int a , unsigned short int uyear , unsigned short int umonth , short int *mo)
//freq = 365 : Κάθε χρόνο ή κάθε step χρόνια , τον τάδε μήνα , τάδε ημερομηνία ή τελευταία ημέρα του μήνα 
//Παράδειγμα για freq = 365
//Κάθε step χρόνια στις 23 του μήνα Σεπτεμβρ. (step = 0-10 , enardate=23 , monthlast=0 , enarmonth=9 )
// Κάθε step χρόνια tην τελευταία ημέρα του μήνα Σεπτεμβρ. (step = 0-10 , monthlast=1 , enarmonth=9 )
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth


{

       if (rcr[a].anast) { return ; }
       
register int f ;   
short int tmo[13] ;

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = (unsigned char) umonth ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = rcr[a].perasyear ;
    eos.damo[0] = (unsigned char) rcr[a].perasdate ;
    eos.damo[1] = (unsigned char) rcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = rcr[a].enaryear ;
    tar.damo[0] = (unsigned char) rcr[a].enardate ;
    tar.damo[1] = (unsigned char) rcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tmi.damo[1] = (unsigned char) umonth ;
    tmi.damo[0] = (unsigned char) mo[umonth] ;
    tmi.yr[1] = uyear ;   
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tmi.ak > eos.ak) { tmi.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tmi.ak) {return ;}

    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    
    while (tar.ak < ami.ak) {
        tar.yr[1] += rcr[a].step;
        // Υπολογισμός tmo[2] για tar.yr[1]
        if (tar.yr[1]%4) tmo[2]=28;
        else {
            if (tar.yr[1]%100) tmo[2]=29;
            else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
        }
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = rcr[a].enardate;}
    }
    
    
    //if ( (tar.damo[0] != rcr[a].enardate) && (!rcr[a].monthlast) ) return ;
    
        if (!rcr[a].monthlast) {
        // Συγκεκριμένη ημερομηνία
        
        if (tmo[tar.damo[1]] < rcr[a].enardate) { return ; }
        tar.damo[0] = rcr[a].enardate ;
    }
    else {
        // Τελευταία ημέρα του μήνα
        
        tar.damo[0] = tmo[tar.damo[1]] ;
    }
    
    if (tar.ak > tmi.ak) return ;
    
    if (mem_a != NULL) {
        mra->dom = (unsigned short int) a ;
        mra->date = tar.mm ;
        c_arma++; mra ++ ;
        if (c_arma==arma){
            arma += 64 ;
            remem=realloc (mem_a , (szYR * arma) );
            if (remem==NULL) {
                if(mem_a!=NULL) { free(mem_a); mem_a=NULL; }
                arma = c_arma = 0;
                information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                return ;
            }
            mem_a=remem;
            mra_1 = mra = ( struct YearRec *) mem_a;
            mra += c_arma ;
        }
    }
}



void year_recur_year_st ( int a , unsigned short int uyear , unsigned char yonly[][32])
//freq = 365 : Κάθε χρόνο ή κάθε step χρόνια , τον τάδε μήνα , τάδε ημερομηνία ή τελευταία ημέρα του μήνα 
//Παράδειγμα για freq = 365
//Κάθε step χρόνια στις 23 του μήνα Σεπτεμβρ. (step = 0-10 , enardate=23 , monthlast=0 , enarmonth=9 )
// Κάθε step χρόνια tην τελευταία ημέρα του μήνα Σεπτεμβρ. (step = 0-10 , monthlast=1 , enarmonth=9 )
// a = αριθμός δομής της περιοδικής υπόμνησης
// Υπενθύμιση : να μηδενίζονται τα clue - proclue  πριν κληθεί τούτο εδώ !!!
// Ενημερώνει γενικό πίνακα only[13][32] για το συγκεκριμένο umonth


{

       if (etrcr[a].anast) { return ; }
       
register int f ;   
short int tmo[13] ;

    // Αρχή τρέχοντος Μηνός
    
    ami.damo[0] = 1 ; ami.damo[1] = 1 ;
    ami.yr[1] = uyear ;
    
        
    // Ημερομηνία πέρατος υπόμνησης
    
    eos.yr[1] = etrcr[a].perasyear ;
    eos.damo[0] = (unsigned char) etrcr[a].perasdate ;
    eos.damo[1] = (unsigned char) etrcr[a].perasmonth ;
    
    
    // Αν η υπόμνηση τελειώνει πριν την αρχή τρέχοντος μηνός έφυγες
    
    if (ami.ak > eos.ak) {return ;}

    tar.yr[1] = etrcr[a].enaryear ;
    tar.damo[0] = (unsigned char) etrcr[a].enardate ;
    tar.damo[1] = (unsigned char) etrcr[a].enarmonth ;

    // Τέλος τρέχοντος μηνός + ημέρες προειδοποίησης alarm
    
    tyear.damo[1] = 12 ;
    tyear.damo[0] = 31 ;
    tyear.yr[1] = uyear ;   
    
    // Αν το τέλος μήνα + αλαρμ ξεπερνά το τέλος της υπόμνησης τότε ... 
    if (tyear.ak > eos.ak) { tyear.ak = eos.ak ;} 
    
    // Αν η υπόμνηση αρχίζει μετά το τέλος του τρέχοντος μήνα + ημέρες προειδ. τότε ... έφυγες.
    if (tar.ak > tyear.ak) {return ;}

    // ΠΡΟΧΩΡΑΜΕ...
    
    tmo[1]=tmo[3]=tmo[5]=tmo[7]=tmo[8]=tmo[10]=tmo[12]=31;
    tmo[4]=tmo[6]=tmo[9]=tmo[11]=30;
       
    // Υπολογισμός tmo[2] για tar.yr[1]
    if (tar.yr[1]%4) tmo[2]=28;
    else {
        if (tar.yr[1]%100) tmo[2]=29;
        else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
    }
    
    
    while (tar.ak < ami.ak) {
        tar.yr[1] += etrcr[a].step;
        // Υπολογισμός tmo[2] για tar.yr[1]
        if (tar.yr[1]%4) tmo[2]=28;
        else {
            if (tar.yr[1]%100) tmo[2]=29;
            else {tmo[2]=(tar.yr[1]%400) ? 28 : 29 ;}
        }
        
        if (tmo[tar.damo[1]] < etrcr[a].enardate) {
            tar.damo[0] = tmo[tar.damo[1]] ;
        }
        else {tar.damo[0] = etrcr[a].enardate;}
    }
    
    
    //if ( (tar.damo[0] != rcr[a].enardate) && (!rcr[a].monthlast) ) return ;
    
        if (!etrcr[a].monthlast) {
        // Συγκεκριμένη ημερομηνία
        
        if (tmo[tar.damo[1]] < etrcr[a].enardate) { return ; }
        tar.damo[0] = etrcr[a].enardate ;
    }
    else {
        // Τελευταία ημέρα του μήνα
        
        tar.damo[0] = tmo[tar.damo[1]] ;
    }
    
    if (tar.ak > tyear.ak) return ;
    
    yonly[tar.damo[1]][tar.damo[0]] = 1 ;
    
    if (mem_g != NULL) {
        mri->dom = (unsigned short int) a ;
        mri->date = tar.mm ;
        c_arst++; mri ++ ;
        if (c_arst==arst){
            arst += 256 ;
            remem=realloc (mem_g , (szYR * arst) );
            if (remem==NULL) {
                if(mem_g!=NULL) { free(mem_g); mem_g=NULL; }
                arst = c_arst = 0;
                information ( 0, "Δεν επαρκεί η Μνήμη!","Κλείστε την εφαρμογή και επανέλθετε...!");
                return ;
            }
            mem_g=remem;
            mri_1 = mri = ( struct YearRec *) mem_g;
            mri += c_arst ;
        }
    }
}


int pers_rec_inp (short int new, short int old , unsigned short int uday, unsigned short int umonth, unsigned short int uyear)
// if new<0 δεν πρόκειται για προσθήκη νέας αλλά για επεξεργασία παλαιάς υπόμνησης (της old)
// if new>=0 τότε πρόκειται για προσθήκη νέας υπόμνησης ... της new (σ' αυτή την περίπτωση old=-1)
// Eπιστρέφει 0 αν δεν γίνει τίποτε και 1 αν πάει καλά !

{
short int mbox = 26 ;
enum epges {
    marrs, inpt , apo , eos , pos_days=15,  pia_day , piakyr_month, pos_months, piakyr_year, pos_years1 , pos_years2 ,  anastol, alarm, yes, go };
    
short int basep[11]; // Βασικές Επιλογές για συνδυασμό με κείμενα korm[]
register int f,i ;

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0=0 , *mem_go=0 , *mem_yes=0, *mem_arrs =0 ,*mem_zer=0 , *mem_tod=0;

unsigned char what ;
int a , b, k ;
int mx,my,mx1, my1, xt1, yt1, xb1, yb1, xb, yb , fyge=0 , dx ;
unsigned int size ;
unsigned short int ch_scan , wkd ;
int choxr_r[3] , white[3], cobkxr[3] , boxbkxr[3] , boxchxr[3], boxslxr[3], cochxrepi[3], cobkxrepi[3] ;
int cochxr[3] , coslxr[3] ;
int black [3] , yel[3] , redy[3] ;



unsigned char date_t[6] ;
short int iday=0, imonth=0 , iyear = 0;
short int opro[8]; 
char menu_pro[8][120] ;
char keim_pro[50];
unsigned char epilogeas [30] ;
short int loop=1;
static short int xt,yt ;
static short int fiti;
static short int mobsorton;
unsigned char kormos [11][140] ; 
unsigned char anastol_t[2][50] , alarm_t[50] , enarj_t[40] , eos_t[40];
int poption=-1 , foption=-1 ;
unsigned char gmonth_t[13][30] , tomonth_t[13][30] ;
unsigned char stis_t[60] ;
short int evmonthx , evmonthy , evmonthsx , evmonthx1, evmonthy1, evmonthsy , evyearx , evyeary, evyearsx , evyearsy ;
short int monthevyearx , monthevyeary ,  monthevyearsx , monthevyearsy ,monthevyearx1 , monthevyeary1;
short int evmonthsx1 , evmonthsy1 , evyearx1 , evyeary1 , evyearsx1, evyearsy1 ;
short int levyearsx , levyearsx1 , levyearsy, levyearsy1 , ektos=1 ;
short int prenx, preny, prenx1, preny1, preosx, preosy, preosx1, preosy1 ;
short int evyearlx , evyearly, evyearlx1 , evyearly1 ; 

struct boxes {
    short int x;
    short int y;
    short int x1;
    short int y1;
} bo [mbox+1] ;

int *colp;
char mera[8][24];
unsigned char string [100];
int pm[2][2];
unsigned short int panel_year, panel_month, panel_date, panel_nameday, podays , targt ;
char mn_pro[8][44]; 
int pras[3] ;
unsigned char podays_t[10] , pomonths_t[10], poyears1_t[10], poyears2_t[10];
unsigned short int pomonths , poyears1, poyears2 ;

int krata_font = ponom_font ;
int axno[3] ;

struct RECURRENT local ;

ponom_font = notosans_18n;

podays_t[0]=255; pomonths_t[0]=255; poyears1_t[0]=255; poyears2_t[0]=255;

strcpy (mera[0],"  ");
strcpy (mera[1],"Κυριακή");  strcpy (mera[2],"Δευτέρα"); strcpy (mera[3],"Τρίτη"); strcpy (mera[4],"Τετάρτη");
strcpy (mera[5],"Πέμπτη"); strcpy (mera[6],"Παρασκευή"); strcpy (mera[7],"Σάββατο"); 

for (f=0;f<3;f++) {
    bkxr1[f]=cobkxr[f] ; chxr1[f]=cochxr[f] ; slxr1[f]=slxr[f];
}


    // do {
       // SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
        
    SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
                          // Συσχετισμός βασικών επιλογών με κουτάκια δεξιά    
    for (f=4 ; f<15 ; f++) { basep[f-4] = f; }

    
    strcpy (mn_pro[0] , "Χωρίς Προειδοποίηση");
    strcpy (mn_pro[1] , "Προειδοπ. 24 ωρών");
    strcpy (mn_pro[2] , "Προειδοπ. 48 ωρών");
    strcpy (mn_pro[3] , "Προειδοπ. 3 ημερών");
    strcpy (mn_pro[4] , "Προειδοπ. 4 ημερών");
    strcpy (mn_pro[5] , "Προειδοπ. 5 ημερών");
    strcpy (mn_pro[6] , "Προειδοπ. 6 ημερών");
    strcpy (mn_pro[7] , "Προειδοπ. 7 ημερών");

    for (f=0;f<8;f++) { opro[f]=1; }

    strcpy (kormos[0] , "Κάθε         Ημέρες");
    strcpy (kormos[1] , "Κάθε Εβδομάδα , ημέρα :");
    strcpy (kormos[2] , "Κάθε Μήνα στις ..");
    strcpy (kormos[3] , "Κάθε Μήνα την τελ. ημέρα");
    strcpy (kormos[4] , "Κάθε Μήνα την ημέρα :");
    strcpy (kormos[5] , "Κάθε         Μήνες στις ..");
    strcpy (kormos[6] , "Κάθε Χρόνο στις ..");
    strcpy (kormos[7] , "Κάθε Χρόνο την τελ. ημέρα του μηνός..");
    strcpy (kormos[8] , "Κάθε Χρόνο, το μήνα ......................  και ημέρα :");
    strcpy (kormos[9] , "Κάθε         Χρόνια στις ..");
    strcpy (kormos[10] , "Κάθε         Χρόνια την τελ. ημέρα μηνός ..");

    strcpy (anastol_t[0], "Υπόμνηση ΕΝΕΡΓΗ");  normtext_tomy (anastol_t[0],0);
    strcpy (anastol_t[1], "Υπόμν. σε ΑΝΑΣΤΟΛΗ");  normtext_tomy (anastol_t[1],0);

    //enarj_t[30] , eos_t[30];
    strcpy (enarj_t, "ΈΝΑΡΞΗ ΥΠΟΜΝΗΣΗΣ");  normtext_tomy (enarj_t,0);
    strcpy (eos_t, "ΠΕΡΑΣ ΥΠΟΜΝΗΣΗΣ");  normtext_tomy (eos_t,0);

    for (f=0 ; f<11 ; f++) {
        normtext_tomy (kormos[f],0);
    }
    
    strcpy (gmonth_t[0] , "  ");
    strcpy (gmonth_t[1] , "Ιανουαρίου");
    strcpy (gmonth_t[2] , "Φεβρουαρίου");
    strcpy (gmonth_t[3] , "Μαρτίου");
    strcpy (gmonth_t[4] , "Απριλίου");
    strcpy (gmonth_t[5] , "Μαίου");
    strcpy (gmonth_t[6] , "Ιουνίου");
    strcpy (gmonth_t[7] , "Ιουλίου");
    strcpy (gmonth_t[8] , "Αυγούστου");
    strcpy (gmonth_t[9] , "Σεπτεμβρίου");
    strcpy (gmonth_t[10] , "Οκτωβρίου");
    strcpy (gmonth_t[11] , "Νοεμβρίου");
    strcpy (gmonth_t[12] , "Δεκεμβρίου");
    
    strcpy (tomonth_t[0] , "  ");
    strcpy (tomonth_t[1] , "Ιανουάριο");
    strcpy (tomonth_t[2] , "Φεβρουάριο");
    strcpy (tomonth_t[3] , "Μάρτιο");
    strcpy (tomonth_t[4] , "Απρίλιο");
    strcpy (tomonth_t[5] , "Μάϊο");
    strcpy (tomonth_t[6] , "Ιούνιο");
    strcpy (tomonth_t[7] , "Ιούλιο");
    strcpy (tomonth_t[8] , "Αύγουστο");
    strcpy (tomonth_t[9] , "Σεπτέμβριο");
    strcpy (tomonth_t[10] , "Οκτώβριο");
    strcpy (tomonth_t[11] , "Νοέμβριο");
    strcpy (tomonth_t[12] , "Δεκέμβριο");


    size=imagesize(0,0,999,419);
    mem0=malloc(size);
    if (!mem0) {information (2-keyb_gr,0,0); goto FYGE;}

    pras[0] = 0 ; pras[1] = 85 ; pras[2] = 0 ; 
    coslxr[0]=20; coslxr[1]=220; coslxr[2]=20;
    cochxrepi[0]=0; cochxrepi[1]=0; cochxrepi[2]=255;
    cobkxrepi[0]=168 ; cobkxrepi[1]=224 ; cobkxrepi[2]=0 ;
    boxchxr[0]=boxchxr[1]=0 ; boxchxr[2]=255;
    boxslxr[0]=255; boxslxr[1]=110; boxslxr[2]=234; 
    black[0]=black[1]=black[2]=0 ;
    cochxr[0]=0 ; cochxr[1]=0 ; cochxr[2]=200 ; 
    axno[0] = 180 ; axno[1] = 180 ; axno[2] = 180 ;  
    cobkxr[0]=159; cobkxr[1]=155;  cobkxr[2]=116;
    choxr_r[0]=0; choxr_r[1]=0;  choxr_r[2]=0;
    white[0]=255; white[1]=255;  white[2]=255;
    boxbkxr[0]=160 ; boxbkxr[1]=160 ; boxbkxr[2]=0 ; 
    yel[0]=210; yel[1]=210; yel[2]=0;
    redy[0] = 180 ; redy[1] = redy[2] = 0 ;

    if (!fiti) {
    xt=(info.right-info.left-999) / 2 ; yt=(info.bottom-info.top-419) / 2 ;}
    fiti=1;
    while ( (xt+999)>info.right-2 ) xt--;
    if (yt<info.top) yt=(info.bottom-info.top-419) / 2 ;
    while (yt+419 > info.bottom-2) yt--;
    xb=xt+999;
    yb=yt+419;
    getimage(xt,yt,xb,yb,mem0);


    // ΕΠΙΚΕΦΑΛΙΔΑ
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/hand_17.ico");
    mem_arrs=icontomem(file_1,255);
    if (!mem_arrs) {information(2-keyb_gr,file_1,NULL); goto FYGE;} 


    // Yes : 54 Χ 36
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Yel_ok_39.ico");
    mem_yes= icontomem (file_1,255);
    if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // Cancel : 54 Χ 21
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_5421.ico");
    mem_go = icontomem (file_1,255);
    if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    // cancel=0 ; Rputicon(goxt,goyt,mem_go,black);
    // RNputicon(goxt,goyt,mem_go,black);



    whouv=gouv;



    _bareacls(xt,yt,xb,yb,cobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    refresh();

    //EPIKEFALIDA

    if (new>=0) sprintf (str1024,"Προσθήκη Νέας Περιοδικής Υπόμνησης (No %03d)" , (int) new+1 );
    else sprintf (str1024,"Επεξεργασία Περιοδικής Υπόμνησης (No %03d)" , (int) old+1 );
    normtext_tomy (str1024,0);
    _outmystr_center_col(bookman_20n, str1024 , xt+8, yt+7, xb-8, yt+34, cochxr , cobkxr);
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+30, xb-i, yt+30);

    refresh();
    f=3*70*myfont_wid[4]/4;
    i= (xb-xt-f+1) / 2 ;


    // ΣΥΝΤΕΤΑΓΜΕΝΕΣ
    
    bo[marrs].x = xt+10 ; bo[marrs].x1 =  bo[marrs].x + 17 ;
    bo[marrs].y = yt+7 ; bo[marrs].y1 =  bo[marrs].y + 17 ;
    
    bo[inpt].x = bo[marrs].x1 ; bo[inpt].x1 =  xb - 17 ;
    bo[inpt].y = bo[marrs].y1 + 20 ; bo[inpt].y1 =  bo[inpt].y + 25 ;
    
    
    bo[pos_days].x = bo[pos_months].x = bo[pos_years1].x = bo[pos_years2].x = xt + 90 ;
    bo[pos_days].x1 = bo[pos_days].x + 35 ;
    bo[pos_months].x1 = bo[pos_years1].x1 = bo[pos_years2].x1 = bo[pos_days].x1 ;
        
    a = bo[inpt].y1 + 20 ;
    k=8 ;
    i=0; 
    for (f=4 ; f<15 ; f++) {
        bo[f].x = bo[marrs].x ;
        bo[f].x1 = bo[f].x + 17 ;
        bo[f].y = a + i*22 + i*7;
        bo[f].y1 = bo[f].y + 20 ;
        setcolor (0);
        rectangle (bo[f].x , bo[f].y , bo[f].x1 , bo[f].y1 );
        _outmystr_col (notosans_20n, kormos[f-4], bo[f].x1 + k , bo[f].y , xb-17 , cochxr, cobkxr);
        i++;
    }
    
    bo[apo].x = bo[inpt].x + 500; bo[apo].x1 =  bo[apo].x + 200 ;
    bo[apo].y = bo[inpt].y1 + 20 ; bo[apo].y1 =  bo[apo].y + 22 ;
        
    bo[eos].x = bo[apo].x ; bo[eos].x1 =  bo[eos].x + 200 ;
    bo[eos].y = bo[basep[1]].y ; bo[eos].y1 =  bo[eos].y + 22 ;
    
    bo[alarm].x = bo[apo].x ; bo[alarm].x1 =  bo[alarm].x + 200 ;
    bo[alarm].y = bo[basep[2]].y ; bo[alarm].y1 =  bo[alarm].y + 22 ;
    
    bo[anastol].x = bo[apo].x ; bo[anastol].x1 =  bo[anastol].x + 200 ;
    bo[anastol].y = bo[basep[3]].y ; bo[anastol].y1 =  bo[anastol].y + 22 ;
    
    bo[pos_days].y = bo[basep[0]].y ;  bo[pos_days].y1 = bo[pos_days].y + 22 ;
    bo[pos_months].y = bo[basep[5]].y ;  bo[pos_months].y1 = bo[pos_months].y + 22 ;
    bo[pos_years1].y = bo[basep[9]].y ;  bo[pos_years1].y1 = bo[pos_years1].y + 22 ;
    bo[pos_years2].y = bo[basep[10]].y ;  bo[pos_years2].y1 = bo[pos_years2].y + 22 ;
    
    bo[pia_day].x = xt+300 ; bo[pia_day].x1 = bo[pia_day].x + 100 ;
    bo[pia_day].y = bo[basep[1]].y ; bo[pia_day].y1 = bo[pia_day].y + 22 ;
    
    bo[piakyr_month].x = xt+300 ; bo[piakyr_month].x1 = bo[piakyr_month].x + 200 ;
    bo[piakyr_month].y = bo[basep[4]].y ; bo[piakyr_month].y1 = bo[piakyr_month].y + 22 ;
    
    bo[piakyr_year].x = xt+480 ; bo[piakyr_year].x1 = bo[piakyr_year].x + 200 ;
    bo[piakyr_year].y = bo[basep[8]].y ; bo[piakyr_year].y1 = bo[piakyr_year].y + 22 ;
    
    bo[go].x = xb-120 ; bo[go].x1 = bo[go].x + 54 ;
    bo[go].y = bo[basep[10]].y ; bo[go].y1 = bo[go].y + 21 ;
    
    bo[yes].x = xb-60 ; bo[yes].x1 = bo[yes].x + 54 ;
    bo[yes].y = bo[basep[10]].y - 14 ; bo[yes].y1 = bo[yes].y + 36 ;
    
    evmonthx = xt + 210 ; evmonthy = bo[basep[2]].y ;
    evmonthx1 = evmonthx+30 ; evmonthy1 = evmonthy+22 ;
    /*
    // Κάθε μήνα στις .. 24
    _bareacls(evmonthx , evmonthy, evmonthx1 , evmonthy1 , cobkxr) ;
    sprintf (date_t , "%02d" , 24) ; normtext_tomy (date_t,0);
    _outmystr_col (notosans_20n, date_t, evmonthx ,evmonthy,evmonthx1 , black, cobkxr);
    */
    evmonthsx = xt + 260 ; evmonthsy = bo[basep[5]].y ;
    evmonthsx1 = evmonthsx + 30 ; evmonthsy1 = evmonthsy + 22 ;
    
    /*
    // Κάθε τόσους μήνες στις .. 24
    _bareacls(evmonthsx , evmonthsy, evmonthsx1 , evmonthsy1 , cobkxr) ;
    _outmystr_col (notosans_20n, date_t, evmonthsx ,evmonthsy,evmonthsx1 , black, cobkxr);
    */
    
    evyearx = evmonthx+5 ; evyeary = bo[basep[6]].y ;
    evyearx1 = evyearx + 160 ; evyeary1 = evyeary + 22 ;

    /*
    // Κάθε χρόνο στις .. 24 Σεπτεμβρίου
    sprintf (stis_t , "%02d %s" , 24, gmonth_t[9]) ; normtext_tomy (stis_t,0);
    _bareacls(evyearx , evyeary, evyearx1 , evyeary1 , cobkxr) ;
    _outmystr_col (notosans_20n, stis_t, evyearx ,evyeary,evyearx1 , black, cobkxr);
    */
    
    // Κάθε Χρόνο την τελευταία ημέρα μηνός τάδε
    evyearlx = xt+415 ; evyearly = bo[basep[7]].y ;
    evyearlx1 = evyearlx + 130 ; evyearly1 = evyearly + 22 ;


    
    monthevyearx = xt+240 ; monthevyeary = bo[basep[8]].y ;  
    monthevyearx1 =  monthevyearx + 120 ; monthevyeary1 = monthevyeary+22;
    
    /*
    // Κάθε χρόνο το μήνα .. τάδε ... την τάδε Δευτέρα
    sprintf (stis_t , "%s" , tomonth_t[12]) ; normtext_tomy (stis_t,0);
    _bareacls(monthevyearx , monthevyeary, monthevyearx1 , monthevyeary1 , cobkxr) ;
    _outmystr_col (notosans_20n, stis_t, monthevyearx ,monthevyeary,monthevyearx1 , black, cobkxr);
    */
    
    evyearsx = evmonthsx + 8 ; evyearsy = bo[basep[9]].y ;
    evyearsx1 = evyearsx + 160 ; evyearsy1 = evyearsy + 22 ;
    monthevyearsx = bo[piakyr_year].x ; monthevyearsy = bo[basep[10]].y ;
    
    /*
        // Κάθε τόσα χρόνια στις .. 24 Σεπτεμβρίου
    sprintf (stis_t , "%02d %s" , 24, gmonth_t[9]) ; normtext_tomy (stis_t,0);
    _bareacls(evyearsx , evyearsy, evyearsx1 , evyearsy1 , cobkxr) ;
    _outmystr_col (notosans_20n, stis_t, evyearsx ,evyearsy,evyearsx1 , black, cobkxr);
    */
    
    levyearsx = xt + 440 ; levyearsy = bo[basep[10]].y ;
    levyearsx1 = levyearsx + 135 ; levyearsy1 = levyearsy + 22 ;
    
    /*
        // Κάθε τόσα χρόνια την τελ. ημέρα του μηνός .. Σεπτεμβρίου
    sprintf (stis_t , "%s" , gmonth_t[2]) ; normtext_tomy (stis_t,0);
    _bareacls(levyearsx , levyearsy, levyearsx1 , levyearsy1 , cobkxr) ;
    _outmystr_col (notosans_20n, stis_t, levyearsx ,levyearsy,levyearsx1 , black, cobkxr);
    */
    
    prenx = bo[apo].x1+30 ; prenx1 = xb-20 ;
    preny = bo[apo].y ; preny1 = preny+22 ;
    
    preosx = prenx ; preosx1 = prenx1 ;
    preosy = bo[eos].y ; preosy1 = preosy+22 ;
    
    setcolor (0);
    
    rectangle (bo[inpt].x , bo[inpt].y , bo[inpt].x1 , bo[inpt].y1 );
    rectangle (bo[apo].x , bo[apo].y , bo[apo].x1 , bo[apo].y1 );
    rectangle (bo[eos].x , bo[eos].y , bo[eos].x1 , bo[eos].y1 );
    rectangle (bo[pos_days].x , bo[pos_days].y , bo[pos_days].x1 , bo[pos_days].y1) ;
    rectangle (bo[pos_months].x , bo[pos_months].y , bo[pos_months].x1 , bo[pos_months].y1) ;
    rectangle (bo[pos_years1].x , bo[pos_years1].y , bo[pos_years1].x1 , bo[pos_years1].y1) ;
    rectangle (bo[pos_years2].x , bo[pos_years2].y , bo[pos_years2].x1 , bo[pos_years2].y1) ;
    rectangle (bo[pia_day].x , bo[pia_day].y , bo[pia_day].x1 , bo[pia_day].y1) ;
    rectangle (bo[piakyr_month].x , bo[piakyr_month].y , bo[piakyr_month].x1 , bo[piakyr_month].y1) ;
    rectangle (bo[piakyr_year].x , bo[piakyr_year].y , bo[piakyr_year].x1 , bo[piakyr_year].y1) ;
    rectangle (bo[anastol].x , bo[anastol].y , bo[anastol].x1 , bo[anastol].y1) ;
    rectangle (bo[alarm].x , bo[alarm].y , bo[alarm].x1 , bo[alarm].y1) ;
    
    _outmystr_center_col (notosans_16b,enarj_t, bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , black , cobkxr);
    _outmystr_center_col (notosans_16b,eos_t, bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , black , cobkxr);

    refresh();
    
    
    
    
    if (new>=0) { // Προσθήκη νέας υπόμνησης της new
        
        local.freq = 0 ; 
        local.step = 0 ;
        local.weekday = 0 ;
        local.monthlast = 0 ;
        local.which = 0 ;
        local.alarm = 0;
        local.anast = 0 ;
        local.basic_option = -1;
        local.keim[0] = 255 ;
        strcpy (alarm_t, mn_pro[0]);  normtext_tomy (alarm_t,0);
        _outmystr_center_col (notosans_16b,anastol_t[0], bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , pras , cobkxr);
        _outmystr_center_col (notosans_16b,alarm_t, bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , black , cobkxr);
        podays = pomonths = poyears1 = poyears2 = wkd = 0 ;
        pm[0][0] = pm[0][1] = pm[1][0] = pm[1][1] = 0 ;
        ami.ak = tmi.ak = 0 ;
    }
    else { // Επεργασία παλιάς υπόμνησης της old επειδή το new<0
/*
   short int freq ; 
   unsigned short int enaryear;
   unsigned short int enarmonth;
   unsigned short int enardate;
   unsigned short int enarday;
   unsigned short int perasyear;
   unsigned short int perasmonth;
   unsigned short int perasdate;
   unsigned short int perasday;
   unsigned short int step ;
   unsigned short int weekday ;
   unsigned short int monthlast ;
   unsigned short int which ;
   unsigned short int alarm ;
   unsigned short int anast ;
   short int basic_option;
   unsigned short int extra1;
   unsigned char keim[70];
 
 */
        local.freq = rcr[old].freq ;
        local.enaryear = rcr[old].enaryear;
        local.enarmonth = rcr[old].enarmonth;
        local.enardate = rcr[old].enardate;
        local.enarday = rcr[old].enarday;
        ami.damo[0] = local.enardate;
        ami.damo[1] = local.enarmonth;
        ami.yr[1] = local.enaryear;
        local.perasyear = rcr[old].perasyear;
        local.perasmonth = rcr[old].perasmonth;
        local.perasdate = rcr[old].perasdate;
        local.perasday = rcr[old].perasday;
        tmi.damo[0] = local.perasdate;
        tmi.damo[1] = local.perasmonth;
        tmi.yr[1] = local.perasyear;
        local.step = rcr[old].step;
        local.weekday = rcr[old].weekday;
        local.monthlast = rcr[old].monthlast;
        local.which = rcr[old].which;
        local.alarm = rcr[old].alarm;
        strcpy (alarm_t, mn_pro[local.alarm]);  normtext_tomy (alarm_t,0);
        local.anast = rcr[old].anast;
        local.basic_option = rcr[old].basic_option;
        mystrcpy_lim (local.keim , rcr[old].keim, 69) ;
        
        foption=local.basic_option+4;
        panel_date = local.enardate;
        panel_month = local.enarmonth ;
        panel_year = local.enaryear ;

        // Κιτρίνισμα κουτιού βασικής επιλογής
        bareacls (bo[foption].x+1 , bo[foption].y+1 , bo[foption].x1-1, bo[foption].y1-1 ,yel);

        // Εγγραφή Κειμένου Υπόμνησης
        if (local.keim[0]!=255) _outmystr_center_col (notosans_18b, local.keim , bo[inpt].x+1,bo[inpt].y+1,bo[inpt].x1-1,bo[inpt].y1-1, black, cobkxr) ;

        // Εγγραφή Έναρξης
        sprintf (str1024 ,"%02d %s %d",panel_date,gmonth_t[panel_month],panel_year);
        normtext_tomy (str1024,string);
        _outmystr_col (notosans_20n,string, prenx , preny , prenx1, cochxr , cobkxr);
        
        
        // Κάθε τόσες ημέρες
        if (local.basic_option==0) {
            podays = local.step ;
            sprintf(str1024,"%d", (int) podays);
            normtext_tomy(str1024 , podays_t);
            //_bareacls (bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,podays_t, bo[pos_days].x+1 , bo[pos_days].y+1 , bo[pos_days].x1-1 , bo[pos_days].y1-1 , black , cobkxr);
        }

        if (local.basic_option==1) {
        // Κάθε εβδομάδα την ημέρα τάδε
        sprintf (str1024 , "%s" , mera[local.weekday]);
        pm[0][0] = pm[1][0] = 0 ; 
        pm[0][1] = pm[1][1] = 0 ;
        wkd = local.weekday ;
        normtext_tomy (str1024,string);
        _outmystr_center_col (notosans_16b,string, bo[pia_day].x+2 , bo[pia_day].y+2 , bo[pia_day].x1-1 , bo[pia_day].y1 , black , cobkxr);
        }
                    
        // Κάθε μήνα στις .. τάδε ημερομηνία
        sprintf (str1024 , "%02d" , panel_date) ; normtext_tomy (str1024,string);
        _outmystr_col (notosans_20n, string, evmonthx ,evmonthy,evmonthx1 , black, cobkxr);
        

        // Κάθε μήνα ή κάθε χρόνο την τάδε Δευτέρα...
        
        if ( (local.basic_option==4) || (local.basic_option==8) ) {
            wkd = 0 ;
            if (local.basic_option==4) {
                a = pm[0][0] = local.which ; 
                b = pm[0][1] = local.weekday ;
                pm[1][0] = 0 ; 
                pm[1][1] = 0 ;
            }
            else {
                a = pm[1][0] = local.which ; 
                b = pm[1][1] = local.weekday ;
                pm[0][0] = 0 ; 
                pm[0][1] = 0 ;
            }
            
            if (b==7) {
                //Sabbato
                if (a==5) {
                    sprintf (str1024,"Τελ. %s",mera[7]);
                }
                else {sprintf (str1024,"%dο %s",a,mera[7]);}
            }
            else {
                //όχι Σάββατο
                if (a==5) {
                    sprintf (str1024,"Τελ. %s",mera[b]);
                }
                else {sprintf (str1024,"%dη %s",a,mera[b]);}
            }
            
            normtext_tomy (str1024,string);
            
            if (local.basic_option==4) {
            _outmystr_center_col (notosans_16b,string, bo[piakyr_month].x+2 , bo[piakyr_month].y+2 , bo[piakyr_month].x1-1 , bo[piakyr_month].y1 , black , cobkxr);}
            
            else {
            // Κάθε χρόνο τάδε μήνα ΤΑΔΕ ΚΥΡΙΑΚΗ
            _outmystr_center_col (notosans_16b,string, bo[piakyr_year].x+2 , bo[piakyr_year].y+2 , bo[piakyr_year].x1-1 , bo[piakyr_year].y1 , black , cobkxr); } 
        }


        // Κάθε τόσους μήνες στις .. τάδε ημερομηνία
        _outmystr_col (notosans_20n, string, evmonthsx ,evmonthsy,evmonthsx1 , black, cobkxr);
        
        // Κάθε τόσους μήνες
        if (local.basic_option==5) {
            pomonths = local.step ;
            sprintf(str1024,"%d", (int) pomonths);
            normtext_tomy(str1024 , pomonths_t);
            //_bareacls (bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,pomonths_t, bo[pos_months].x+1 , bo[pos_months].y+1 , bo[pos_months].x1-1 , bo[pos_months].y1-1 , black , cobkxr);
        }
        

        // Κάθε χρόνο στις .. ημερομηνία - μήνας
        sprintf (str1024 , "%02d %s" , panel_date, gmonth_t[panel_month]) ; normtext_tomy (str1024,string);
        _outmystr_col (notosans_20n, string, evyearx ,evyeary,evyearx1 , black, cobkxr);
        
        // Κάθε τόσα χρόνια στις .. ημερομηνία - μήνας // 
        _outmystr_col (notosans_20n, string, evyearsx ,evyearsy,evyearsx1 , black, cobkxr);       

        // Κάθε Χρόνο τον ΤΑΔΕ ΜΗΝΑ την τάδε Κυριακή...

        sprintf (str1024 , "%s" , tomonth_t[panel_month]) ; normtext_tomy (str1024,string);
        _bareacls(monthevyearx , monthevyeary, monthevyearx1 , monthevyeary1+3 , cobkxr) ;
        _outmystr_center_col (notosans_20n, string, monthevyearx ,monthevyeary,monthevyearx1 ,monthevyeary1+3,  black, cobkxr);
        
        // Κάθε τόσα χρόνια στις .. ημερομηνία - μήνας
        if (local.basic_option==9) {
            poyears1 = local.step ;
            sprintf(str1024,"%d", (int) poyears1);
            normtext_tomy(str1024 , poyears1_t);
            //_bareacls (bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,poyears1_t, bo[pos_years1].x+1 , bo[pos_years1].y+1 , bo[pos_years1].x1-1 , bo[pos_years1].y1-1 , black , cobkxr);
        }
        
        // Κάθε χρόνο και κάθε τόσα χρόνια την τελ. ημέρα του μηνός .. Σεπτεμβρίου
        sprintf (str1024 , "%s" , gmonth_t[panel_month]) ; normtext_tomy (str1024,string);
        _outmystr_col (notosans_20n, string, levyearsx ,levyearsy,levyearsx1 , black, cobkxr);
        _outmystr_col (notosans_20n, string, evyearlx ,evyearly,evyearlx1 , black, cobkxr);
        
        if (local.basic_option==10) {
            poyears2 = local.step ;
            sprintf(str1024,"%d", (int) poyears2);
            normtext_tomy(str1024 , poyears2_t);
            //_bareacls (bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,poyears2_t, bo[pos_years2].x+1 , bo[pos_years2].y+1 , bo[pos_years2].x1-1 , bo[pos_years2].y1-1 , black , cobkxr);
        }
        
        // Εγγραφή Πέρατος
            sprintf (str1024 ,"%02d %s %d",local.perasdate,gmonth_t[local.perasmonth],local.perasyear);
            normtext_tomy (str1024,string);
            _outmystr_col (notosans_20n,string, preosx,preosy,preosx1,cochxr , cobkxr);

            // Alarm
            
            strcpy (alarm_t, mn_pro[local.alarm]);  normtext_tomy (alarm_t,0);
            if (!local.alarm) { colp = black ; } else { colp = pras ;}
            _outmystr_center_col (notosans_16b,alarm_t, bo[alarm].x+2 , bo[alarm].y+2 , bo[alarm].x1-1 , bo[alarm].y1 , colp , cobkxr);
            
            // Αναστολή
            if (!local.anast) { colp = pras ; } else { colp = redy ;}
            _bareacls (bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , cobkxr) ;
            _outmystr_center_col (notosans_16b,anastol_t[local.anast], bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , colp , cobkxr);
            
        foption = -1 ;
        
    }

    _puticon(bo[yes].x,bo[yes].y,mem_yes,255);
    _realputicon(bo[go].x,bo[go].y,mem_go);
    _puticon(bo[marrs].x,bo[marrs].y,mem_arrs,255);

    refresh();

    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor); 
    mem_small = 0 ;

do {
if (!SDL_PollEvent(&sdlev)) continue;
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        //while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
            if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) {continue ;}
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
        for (f=0 ; f<mbox ; f++) {
            if (mx>=bo[f].x && mx<=bo[f].x1 && my>=bo[f].y && my<=bo[f].y1) {foption=f ; break; }   
        }
       
       if (f == mbox) {
           
            if (!ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                ektos=1;
            }
            
            
            if (poption==-1) continue;
            else {
                // Επαναφορά κανονικής κατάστασης
                if (mem_small) {hide_help(hdhlpxt , hdhlpyt);}
                
                if (poption==marrs) {
                    puticon(bo[marrs].x,bo[marrs].y,mem_arrs,255);
                    poption=-1;
                    continue ;
                }
                else if (poption==go) {
                    Rputicon(bo[go].x,bo[go].y,mem_go,cobkxr);
                    poption=-1;
                    continue ;
                }
                else if (poption==yes) {
                    puticon(bo[yes].x,bo[yes].y,mem_yes,255);
                    poption=-1;
                    continue ;
                }
                else if (poption==apo) {
                    _bareacls (bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,enarj_t, bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , black , cobkxr);
                }
                else if (poption==eos) {
                    _bareacls (bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,eos_t, bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , black , cobkxr);
                }
                else if (poption==anastol) {
                    if (!local.anast) { colp = pras ; } else { colp = redy ;}
                    _bareacls (bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,anastol_t[local.anast], bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , colp , cobkxr);
                }
                else if (poption==alarm) {
                    if (!local.alarm) { colp = black ; } else { colp = pras ;}
                    _bareacls (bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,alarm_t, bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , colp , cobkxr);
                }
                
                setcolor (COLOR(cobkxr[0], cobkxr[1], cobkxr[2]));
                rectangle (bo[poption].x-1 , bo[poption].y-1 , bo[poption].x1+1, bo[poption].y1+1);
                rectangle (bo[poption].x-2 , bo[poption].y-2 , bo[poption].x1+2, bo[poption].y1+2);
                refresh();
                
                poption = -1 ;
                continue ;
            }
    }
    else {
        
        // Κάτι έχει επιλεγεί !!
        
        if (poption == foption) continue ;
        
        if (ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ektos=0;
        }
        
        if (poption!=-1) {
            // Επαναφορά κανονικής κατάστασης

                if (poption==marrs) {
                    puticon(bo[marrs].x,bo[marrs].y,mem_arrs,255);
                    poption=-1;
                    
                }
                else if (poption==go) {
                    Rputicon(bo[go].x,bo[go].y,mem_go,cobkxr);
                    poption=-1;
                    
                }
                else if (poption==yes) {
                    puticon(bo[yes].x,bo[yes].y,mem_yes,255);
                    poption=-1;
                    
                }
                else if (poption==apo) {
                    _bareacls (bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,enarj_t, bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , black , cobkxr);
                }
                else if (poption==eos) {
                    _bareacls (bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,eos_t, bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , black , cobkxr);
                }
                else if (poption==anastol) {
                    if (!local.anast) { colp = pras ; } else { colp = redy ;}
                    _bareacls (bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,anastol_t[local.anast], bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , colp , cobkxr);
                }
                else if (poption==alarm) {
                    if (!local.alarm) { colp = black ; } else { colp = pras ;}
                    _bareacls (bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , cobkxr) ;
                    _outmystr_center_col (notosans_16b,alarm_t, bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , colp , cobkxr);
                }
                
                if (poption!=-1) {
                setcolor (COLOR(cobkxr[0], cobkxr[1], cobkxr[2]));
                rectangle (bo[poption].x-1 , bo[poption].y-1 , bo[poption].x1+1, bo[poption].y1+1);
                rectangle (bo[poption].x-2 , bo[poption].y-2 , bo[poption].x1+2, bo[poption].y1+2);
                refresh();
                }
            
        }
        
        // ΕΝΕΡΓΟΠΟΙΗΣΗ ΝΕΑΣ ΕΠΙΛΟΓΗΣ
        a=0 ;
        
        if (foption==inpt) {show_help("Εισαγωγή - Επεξεργασία Κειμένου Υπόμνησης", bo[inpt].x, bo[inpt].y1+4 , &hdhlpxt , &hdhlpyt) ;}
        
        else if (foption==pos_days) {show_help("Από 3 έως και 365 ημέρες", bo[pos_days].x, bo[pos_days].y1+4 , &hdhlpxt , &hdhlpyt) ;}
        
        else if (foption==pos_months) {show_help("Από 2 έως και 11 μήνες", bo[pos_months].x, bo[pos_months].y1+4 , &hdhlpxt , &hdhlpyt) ;}
        
        else if (foption==pos_years1) {show_help("Από 2 έως και 10 χρόνια", bo[pos_years1].x, bo[pos_years1].y1+4 , &hdhlpxt , &hdhlpyt) ;}
        
        else if (foption==pos_years2) {show_help("Από 2 έως και 10 χρόνια", bo[pos_years2].x, bo[pos_years2].y1+4 , &hdhlpxt , &hdhlpyt) ;}
        
        else if (foption==marrs) {
            putNOTicon(bo[marrs].x,bo[marrs].y,mem_arrs);
            show_help("Μετακίνηση παραθύρου", bo[marrs].x, bo[marrs].y1+2 , &hdhlpxt , &hdhlpyt) ;
            a=1 ;
        }
        else if (foption==go) {
            RNputicon(bo[go].x,bo[go].y,mem_go,cobkxr);
            a=1 ;
        }
        else if (foption==yes) {
            putNOTicon(bo[yes].x,bo[yes].y,mem_yes);
            a=1;
        }
        else if (foption==apo) {
            _bareacls (bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , yel) ;
            _outmystr_center_col (notosans_16b,enarj_t, bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , black , cobkxr);
        }
        else if (foption==eos) {
            _bareacls (bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , yel) ;
            _outmystr_center_col (notosans_16b,eos_t, bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , black , cobkxr);
        }
        else if (foption==anastol) {
            if (!local.anast) { colp = pras ; } else { colp = redy ;}
            _bareacls (bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , yel) ;
            _outmystr_center_col (notosans_16b,anastol_t[local.anast], bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , colp , cobkxr);
        }
        else if (foption==alarm) {
            if (!local.alarm) { colp = black ; } else { colp = pras ;}
            _bareacls (bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , yel) ;
            _outmystr_center_col (notosans_16b,alarm_t, bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , colp , cobkxr);
        }
        
        if (!a) {
            
            setcolor (COLOR(coslxr[0],coslxr[1], coslxr[2]));
            rectangle (bo[foption].x-1 , bo[foption].y-1 , bo[foption].x1+1, bo[foption].y1+1);
            setcolor (COLOR(black[0], black[1], black[2]));
            rectangle (bo[foption].x-2 , bo[foption].y-2 , bo[foption].x1+2, bo[foption].y1+2);
            refresh();
        }
        
    poption = foption ;
    continue ;
    }

     /*   
    // ΤΕΛΟΣ ΤΑ ΠΙΘΑΝΑ ΣΗΜΕΙΑ !!
        if (!ektos) {
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        ektos=1;
        }
        
    */
        
        break ; // break of SDL_MOUSEMOTION
        
        case SDL_MOUSEBUTTONDOWN:
        
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx1 = sdlev.button.x ; my1= sdlev.button.y ;
            if ( (abs (mx1-mx) > 40) || (abs (my1-my) > 40) ) {
                SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
                continue ;
            }
            
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (foption != poption) continue ;
            
            a=0;
            for (f=0 ; f<11 ; f++) {
                if (foption == basep[f]) {a=1; break;}
            }
            
            if (a) {
                if (local.basic_option==-1) {
                    local.basic_option = (short int) f;
                    bareacls (bo[foption].x+1 , bo[foption].y+1 , bo[foption].x1-1, bo[foption].y1-1 ,yel);}
                else {
                    b = local.basic_option + 4 ;
                    bareacls (bo[b].x+1 , bo[b].y+1 , bo[b].x1-1, bo[b].y1-1 ,cobkxr);
                    local.basic_option = (short int) f ;
                    bareacls (bo[foption].x+1 , bo[foption].y+1 , bo[foption].x1-1, bo[foption].y1-1 ,yel);
                }
            }
            
            else if (foption==inpt) {
                

                chxr[0] = chxr[1] = chxr[2] = 255;
                bkxr[0] = bkxr[1] = bkxr[2] = 0 ;
                slxr[0] = 0 ; slxr[1] = 38 ; slxr[2] = 157 ;  
                bareacls (bo[inpt].x+1,bo[inpt].y+1,bo[inpt].x1-1,bo[inpt].y1-1,bkxr);
                gouv=myfont[notosans_18n];
                text_input(local.keim,bo[inpt].x+1,bo[inpt].y+1,bo[inpt].x1-1,bo[inpt].y1-1,69);
                bareacls (bo[inpt].x+1,bo[inpt].y+1,bo[inpt].x1-1,bo[inpt].y1-1,cobkxr);
                if (local.keim[0]!=255) _outmystr_center_col (notosans_18b, local.keim , bo[inpt].x+1,bo[inpt].y+1,bo[inpt].x1-1,bo[inpt].y1-1, black, cobkxr) ;
                refresh();
            }
            
            else if (foption == piakyr_month) {
                //Header = "Γραμματοσειρά Καταλόγου Ονομάτων";
                Header = (char *) NULL ;
                dbbut[2].butt_elem = sbutton_show ( dbbut[2].mem_butt , dbbut[2].butt_data , dbbut[2].butt_ar , dbbut[2].butt_orio , dbbut[2].butt_name , &dbbut[2].butt_sorton , 0 );
                dx=dbbut[2].butt_elem;
                Header = (char *) NULL ;
//Μετά από επιλογή στο μενού για το κάθε 2η Τρίτη ή κάθε τελευταία Κυριακή κλπ :
//user_ans = ...έστω 12 (από 0 έως και 34)
//which = (user_ans/7) + 1 ; άρα 2
//weekday = (user_ans % 7) + 1 ; 
//άρα 6 - Παρασκ.
                if (dx>=0) {
                    a = (dx/7) + 1 ;
                    b = (dx % 7) + 1 ;
                    //local.which = (unsigned short int) a ;
                    //local.weekday = (unsigned short int) b ;
                    pm[0][0] = a ; pm[0][1] = b ; 
                    _bareacls (bo[piakyr_month].x+1 , bo[piakyr_month].y+1 , bo[piakyr_month].x1-1 , bo[piakyr_month].y1-1 , cobkxr) ;
                    if (b==7) {
                        //Sabbato
                        if (a==5) {
                            sprintf (str1024,"Τελ. %s",mera[7]);
                        }
                        else {sprintf (str1024,"%dο %s",a,mera[7]);}
                    }
                    else {
                        //όχι Σάββατο
                        if (a==5) {
                            sprintf (str1024,"Τελ. %s",mera[b]);
                        }
                        else {sprintf (str1024,"%dη %s",a,mera[b]);}
                    }
                    
                    normtext_tomy (str1024,string);
                    _outmystr_center_col (notosans_16b,string, bo[piakyr_month].x+2 , bo[piakyr_month].y+2 , bo[piakyr_month].x1-1 , bo[piakyr_month].y1 , black , cobkxr);
                } 
            }
            
            else if (foption == piakyr_year) {
                //Header = "Γραμματοσειρά Καταλόγου Ονομάτων";
                Header = (char *) NULL ;
                dbbut[2].butt_elem = sbutton_show ( dbbut[2].mem_butt , dbbut[2].butt_data , dbbut[2].butt_ar , dbbut[2].butt_orio , dbbut[2].butt_name , &dbbut[2].butt_sorton , 0 );
                dx=dbbut[2].butt_elem;
                Header = (char *) NULL ;
//Μετά από επιλογή στο μενού για το κάθε 2η Τρίτη ή κάθε τελευταία Κυριακή κλπ :
//user_ans = ...έστω 12 (από 0 έως και 34)
//which = (user_ans/7) + 1 ; άρα 2
//weekday = (user_ans % 7) + 1 ; 
//άρα 6 - Παρασκ.
                if (dx>=0) {
                    a = (dx/7) + 1 ;
                    b = (dx % 7) + 1 ;
                    //local.which = (unsigned short int) a ;
                    //local.weekday = (unsigned short int) b ;
                    pm[1][0] = a ; pm[1][1] = b ; 
                    _bareacls (bo[piakyr_year].x+1 , bo[piakyr_year].y+1 , bo[piakyr_year].x1-1 , bo[piakyr_year].y1-1 , cobkxr) ;
                    if (b==7) {
                        //Sabbato
                        if (a==5) {
                            sprintf (str1024,"Τελ. %s",mera[7]);
                        }
                        else {sprintf (str1024,"%dο %s",a,mera[7]);}
                    }
                    else {
                        //όχι Σάββατο
                        if (a==5) {
                            sprintf (str1024,"Τελ. %s",mera[b]);
                        }
                        else {sprintf (str1024,"%dη %s",a,mera[b]);}
                    }
                    
                    normtext_tomy (str1024,string);
                    _outmystr_center_col (notosans_16b,string, bo[piakyr_year].x+2 , bo[piakyr_year].y+2 , bo[piakyr_year].x1-1 , bo[piakyr_year].y1 , black , cobkxr);
                } 
            }
            
             else if (foption == apo) {
                // Κλήση της mini χρονομηχανής
                ektos=1;
                panel_year=uyear ; panel_month = umonth; panel_date=uday; panel_nameday = 0 ;
                i=mini_calendar(&panel_year, &panel_month, &panel_date,&panel_nameday);
                if ( (i) && (panel_year) ) {
                ami.damo[0] = panel_date;
                ami.damo[1] = panel_month;
                ami.yr[1] = panel_year;
                local.enardate= panel_date;
                local.enarmonth = panel_month;
                local.enaryear = panel_year;
                local.enarday = panel_nameday;
                bareacls (prenx,preny,prenx1,preny1,cobkxr);
                sprintf (str1024 ,"%02d %s %d",panel_date,gmonth_t[panel_month],panel_year);
                normtext_tomy (str1024,string);
                _outmystr_col (notosans_20n,string, prenx , preny , prenx1, cochxr , cobkxr);
                // Κάθε μήνα στις .. τάδε ημερομηνία
                _bareacls(evmonthx , evmonthy, evmonthx1 , evmonthy1 , cobkxr) ;
                sprintf (str1024 , "%02d" , panel_date) ; normtext_tomy (str1024,string);
                _outmystr_col (notosans_20n, string, evmonthx ,evmonthy,evmonthx1 , black, cobkxr);
                // Κάθε τόσους μήνες στις .. τάδε ημερομηνία
                _bareacls(evmonthsx , evmonthsy, evmonthsx1 , evmonthsy1 , cobkxr) ;
                _outmystr_col (notosans_20n, string, evmonthsx ,evmonthsy,evmonthsx1 , black, cobkxr);
                // Κάθε χρόνο στις .. ημερομηνία - μήνας
                sprintf (str1024 , "%02d %s" , panel_date, gmonth_t[panel_month]) ; normtext_tomy (str1024,string);
                _bareacls(evyearx , evyeary, evyearx1 , evyeary1 , cobkxr) ;
                _outmystr_col (notosans_20n, string, evyearx ,evyeary,evyearx1 , black, cobkxr);
                // Κάθε τόσα χρόνια στις .. ημερομηνία - μήνας
                _bareacls(evyearsx , evyearsy, evyearsx1 , evyearsy1 , cobkxr) ;
                _outmystr_col (notosans_20n, string, evyearsx ,evyearsy,evyearsx1 , black, cobkxr);
                // Κάθε χρόνο το μήνα .. τάδε ... την τάδε ημέρα εβδομάδος
                sprintf (str1024 , "%s" , tomonth_t[panel_month]) ; normtext_tomy (str1024,string);
                _bareacls(monthevyearx , monthevyeary, monthevyearx1 , monthevyeary1+3 , cobkxr) ;
                _outmystr_center_col (notosans_20n, string, monthevyearx ,monthevyeary,monthevyearx1 ,monthevyeary1+3,  black, cobkxr);
                // Κάθε τόσα χρόνια την τελ. ημέρα του μηνός .. Σεπτεμβρίου
                sprintf (str1024 , "%s" , gmonth_t[panel_month]) ; normtext_tomy (str1024,string);
                _bareacls(levyearsx , levyearsy, levyearsx1 , levyearsy1 , cobkxr) ;
                _outmystr_col (notosans_20n, string, levyearsx ,levyearsy,levyearsx1 , black, cobkxr);
                // Κάθε Χρόνο την τελευταία ημέρα μηνός τάδε
                _bareacls(evyearlx , evyearly, evyearlx1 , evyearly1 , cobkxr) ;
                _outmystr_col (notosans_20n, string, evyearlx ,evyearly,evyearlx1 , black, cobkxr);
                if ((tmi.ak) && (ami.ak >= tmi.ak)) {
                    information (0 , "Πέρας υπόμνησης ΜΗ αποδεκτό!","Παρακαλώ προβείτε σε ανάλογη  τροποποίηση!");
                    sprintf (str1024 ,"%02d %s %d",local.perasdate,gmonth_t[local.perasmonth],local.perasyear);
                    normtext_tomy (str1024,string);
                    _outmystr_col (notosans_20n,string, preosx,preosy,preosx1, axno , cobkxr);
                    }
                }
            }
            
            else if (foption == eos) {

                // Κλήση της mini χρονομηχανής
                ektos=1;
                panel_year=uyear ; panel_month = umonth; panel_date=uday; panel_nameday = 0 ;
                i=mini_calendar(&panel_year, &panel_month, &panel_date,&panel_nameday);
                if ( (i) && (panel_year) ) {
                tmi.damo[0] = panel_date;
                tmi.damo[1] = panel_month;
                tmi.yr[1] = panel_year;
                local.perasdate= panel_date;
                local.perasmonth = panel_month;
                local.perasyear = panel_year;
                local.perasday = panel_nameday;
                bareacls (preosx,preosy,preosx1,preosy1,cobkxr);
                sprintf (str1024 ,"%02d %s %d",panel_date,gmonth_t[panel_month],panel_year);
                normtext_tomy (str1024,string);
                if (ami.ak >= tmi.ak) {colp = axno ; }  else { colp = cochxr ; }
                _outmystr_col (notosans_20n,string, preosx,preosy,preosx1,colp , cobkxr);
                if (ami.ak >= tmi.ak) information (0 , "Πέρας υπόμνησης ΜΗ αποδεκτό!","Παρακαλώ προβείτε σε ανάλογη τροποποίηση!");
                }
            }
            
            else if (foption == pia_day) { // Κάθε εβδομάδα την ημέρα τάδε wkd
                for (f=0 ; f<7 ; f++) {
                    strcpy (menu_pro[f] , mera[f+1]) ;
                }
                for (f=0;f<7;f++) { opro[f]=1; }
                strcpy (epilogeas,"Επιλέξατε..");
                normtext_tomy (epilogeas,0);
                dx=fastmenu_show_opt(7, opro, menu_pro, epilogeas , bo[pia_day].x1-176, bo[pia_day].y1+10);
                ektos=1;
                if (dx>=0) {
                    wkd = (unsigned short int) (dx + 1) ; 
                    _bareacls (bo[pia_day].x+1, bo[pia_day].y+1, bo[pia_day].x1-1, bo[pia_day].y1-1 , cobkxr) ;
                    sprintf (str1024 , "%s" , mera[dx+1]);
                    normtext_tomy (str1024,string);
                    _outmystr_center_col (notosans_16b,string, bo[pia_day].x+2 , bo[pia_day].y+2 , bo[pia_day].x1-1 , bo[pia_day].y1 , black , cobkxr);
                }
            }
            
            else if (foption == alarm) { // Προειδοποίηση
                
                for (f=0 ; f<8 ; f++) {
                    strcpy (menu_pro[f] , mn_pro[f]) ;
                }
                for (f=0;f<8;f++) { opro[f]=1; }
                strcpy (epilogeas,"Επιλέξατε..");
                normtext_tomy (epilogeas,0);
                dx=fastmenu_show_opt(8, opro, menu_pro, epilogeas , bo[alarm].x-25, bo[alarm].y1+10);
                ektos=1;
                if (dx>=0) {
                    local.alarm = (unsigned short int) (dx) ; 
                    strcpy (alarm_t, mn_pro[local.alarm]);  normtext_tomy (alarm_t,0);
                }
            }
            
            
        else if (foption == anastol) { // Αναστολή
            
            local.anast = 1 - local.anast ;
            
        }
        
        else if (foption == pos_days) {
            
            gouv=myfont[notosans_16n];
            chxr[0] = chxr[1] = chxr[2] = 255;
            bkxr[0] = bkxr[1] = bkxr[2] = 0 ;
            slxr[0] = 0 ; slxr[1] = 38 ; slxr[2] = 157 ; 
            bareacls (bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,bkxr);
            dx=num_input(podays_t,bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,3,0);
            a=0 ;
            if (podays_t[0]!=255) {
                podays=(unsigned short int) convert_str (3,podays_t);
                if (podays>365) { a=1; podays=365; }
                else if (podays<3) { a=1; podays=3; }
                if (a) {
                    sprintf (str1024,"%d",(int)podays);
                    normtext_tomy(str1024,podays_t);
                }

            _bareacls (bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,podays_t, bo[pos_days].x+1 , bo[pos_days].y+1 , bo[pos_days].x1-1 , bo[pos_days].y1-1 , black , cobkxr);
            }
            else {podays=0 ; _bareacls (bo[pos_days].x+1,bo[pos_days].y+1,bo[pos_days].x1-1,bo[pos_days].y1-1,cobkxr);}
        }
        
        else if (foption == pos_months) {
            
            gouv=myfont[notosans_16n];
            chxr[0] = chxr[1] = chxr[2] = 255;
            bkxr[0] = bkxr[1] = bkxr[2] = 0 ;
            slxr[0] = 0 ; slxr[1] = 38 ; slxr[2] = 157 ; 
            bareacls (bo[pos_months].x+1,bo[pos_months].y+1,bo[pos_months].x1-1,bo[pos_months].y1-1,bkxr);
            dx=num_input(pomonths_t,bo[pos_months].x+1,bo[pos_months].y+1,bo[pos_months].x1-1,bo[pos_months].y1-1,2,0);
            a=0 ;
            if (pomonths_t[0]!=255) {
                pomonths=(unsigned short int) convert_str (2,pomonths_t);
                if (pomonths>11) { a=1; pomonths=11; }
                else if (pomonths<2) { a=1; pomonths=2; }
                if (a) {
                    sprintf (str1024,"%d",(int)pomonths);
                    normtext_tomy(str1024,pomonths_t);
                }

            _bareacls (bo[pos_months].x+1,bo[pos_months].y+1,bo[pos_months].x1-1,bo[pos_months].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,pomonths_t, bo[pos_months].x+1 , bo[pos_months].y+1 , bo[pos_months].x1-1 , bo[pos_months].y1-1 , black , cobkxr);
            }
            else {pomonths=0; _bareacls (bo[pos_months].x+1,bo[pos_months].y+1,bo[pos_months].x1-1,bo[pos_months].y1-1,cobkxr);}
        }
        
        else if (foption == pos_years1) {
            
            gouv=myfont[notosans_16n];
            chxr[0] = chxr[1] = chxr[2] = 255;
            bkxr[0] = bkxr[1] = bkxr[2] = 0 ;
            slxr[0] = 0 ; slxr[1] = 38 ; slxr[2] = 157 ; 
            bareacls (bo[pos_years1].x+1,bo[pos_years1].y+1,bo[pos_years1].x1-1,bo[pos_years1].y1-1,bkxr);
            dx=num_input(poyears1_t,bo[pos_years1].x+1,bo[pos_years1].y+1,bo[pos_years1].x1-1,bo[pos_years1].y1-1,2,0);
            a=0 ;
            if (poyears1_t[0]!=255) {
                poyears1=(unsigned short int) convert_str (2,poyears1_t);
                if (poyears1>10) { a=1; poyears1=10; }
                else if (poyears1<2) { a=1; poyears1=2; }
                if (a) {
                    sprintf (str1024,"%d",(int)poyears1);
                    normtext_tomy(str1024,poyears1_t);
                }

            _bareacls (bo[pos_years1].x+1,bo[pos_years1].y+1,bo[pos_years1].x1-1,bo[pos_years1].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,poyears1_t, bo[pos_years1].x+1 , bo[pos_years1].y+1 , bo[pos_years1].x1-1 , bo[pos_years1].y1-1 , black , cobkxr);
            }
            else {poyears1=0; _bareacls (bo[pos_years1].x+1,bo[pos_years1].y+1,bo[pos_years1].x1-1,bo[pos_years1].y1-1,cobkxr);}
        }
        
        else if (foption == pos_years2) {
            
            gouv=myfont[notosans_16n];
            chxr[0] = chxr[1] = chxr[2] = 255;
            bkxr[0] = bkxr[1] = bkxr[2] = 0 ;
            slxr[0] = 0 ; slxr[1] = 38 ; slxr[2] = 157 ; 
            bareacls (bo[pos_years2].x+1,bo[pos_years2].y+1,bo[pos_years2].x1-1,bo[pos_years2].y1-1,bkxr);
            dx=num_input(poyears2_t,bo[pos_years2].x+1,bo[pos_years2].y+1,bo[pos_years2].x1-1,bo[pos_years2].y1-1,2,0);
            a=0 ;
            if (poyears2_t[0]!=255) {
                poyears2=(unsigned short int) convert_str (2,poyears2_t);
                if (poyears2>10) { a=1; poyears2=10; }
                else if (poyears2<2) { a=1; poyears2=2; }
                if (a) {
                    sprintf (str1024,"%d",(int)poyears2);
                    normtext_tomy(str1024,poyears2_t);
                }

            _bareacls (bo[pos_years2].x+1,bo[pos_years2].y+1,bo[pos_years2].x1-1,bo[pos_years2].y1-1,cobkxr);
            _outmystr_center_col (notosans_16b,poyears2_t, bo[pos_years2].x+1 , bo[pos_years2].y+1 , bo[pos_years2].x1-1 , bo[pos_years2].y1-1 , black , cobkxr);
            }
            else {poyears2=0; _bareacls (bo[pos_years2].x+1,bo[pos_years2].y+1,bo[pos_years2].x1-1,bo[pos_years2].y1-1,cobkxr);}
        }
        
        else if (foption == marrs) {
            
            xt1=xt;
            yt1=yt;
            xb1=xb;
            yb1=yb;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); goto EPANAFORA ;}

            getimage(xt,yt,xb,yb,mem_zer);
            putimage(xt,yt,mem0,0); 
            
            getimage (xt1,yt1,xb1,yb1,mem0);
            
            xt=xt1 ; yt=yt1; xb=xb1; yb=yb1;
            putimage (xt,yt,mem_zer,0);
            free(mem_zer) ; mem_zer=0;

            // Επανακαθορισμός ΣΥΝΤΕΤΑΓΜΕΝΩΝ
            
            bo[marrs].x = xt+10 ; bo[marrs].x1 =  bo[marrs].x + 17 ;
            bo[marrs].y = yt+7 ; bo[marrs].y1 =  bo[marrs].y + 17 ;
            
            bo[inpt].x = bo[marrs].x1 ; bo[inpt].x1 =  xb - 17 ;
            bo[inpt].y = bo[marrs].y1 + 20 ; bo[inpt].y1 =  bo[inpt].y + 25 ;
            
            
            bo[pos_days].x = bo[pos_months].x = bo[pos_years1].x = bo[pos_years2].x = xt + 90 ;
            bo[pos_days].x1 = bo[pos_days].x + 35 ;
            bo[pos_months].x1 = bo[pos_years1].x1 = bo[pos_years2].x1 = bo[pos_days].x1 ;
                
            a = bo[inpt].y1 + 20 ;
            k=8 ;
            i=0; 
            for (f=4 ; f<15 ; f++) {
                bo[f].x = bo[marrs].x ;
                bo[f].x1 = bo[f].x + 17 ;
                bo[f].y = a + i*22 + i*7;
                bo[f].y1 = bo[f].y + 20 ;
                i++;
            }
            
            bo[apo].x = bo[inpt].x + 500; bo[apo].x1 =  bo[apo].x + 200 ;
            bo[apo].y = bo[inpt].y1 + 20 ; bo[apo].y1 =  bo[apo].y + 22 ;
                
            bo[eos].x = bo[apo].x ; bo[eos].x1 =  bo[eos].x + 200 ;
            bo[eos].y = bo[basep[1]].y ; bo[eos].y1 =  bo[eos].y + 22 ;
            
            bo[alarm].x = bo[apo].x ; bo[alarm].x1 =  bo[alarm].x + 200 ;
            bo[alarm].y = bo[basep[2]].y ; bo[alarm].y1 =  bo[alarm].y + 22 ;
            
            bo[anastol].x = bo[apo].x ; bo[anastol].x1 =  bo[anastol].x + 200 ;
            bo[anastol].y = bo[basep[3]].y ; bo[anastol].y1 =  bo[anastol].y + 22 ;
            
            bo[pos_days].y = bo[basep[0]].y ;  bo[pos_days].y1 = bo[pos_days].y + 22 ;
            bo[pos_months].y = bo[basep[5]].y ;  bo[pos_months].y1 = bo[pos_months].y + 22 ;
            bo[pos_years1].y = bo[basep[9]].y ;  bo[pos_years1].y1 = bo[pos_years1].y + 22 ;
            bo[pos_years2].y = bo[basep[10]].y ;  bo[pos_years2].y1 = bo[pos_years2].y + 22 ;
            
            bo[pia_day].x = xt+300 ; bo[pia_day].x1 = bo[pia_day].x + 100 ;
            bo[pia_day].y = bo[basep[1]].y ; bo[pia_day].y1 = bo[pia_day].y + 22 ;
            
            bo[piakyr_month].x = xt+300 ; bo[piakyr_month].x1 = bo[piakyr_month].x + 200 ;
            bo[piakyr_month].y = bo[basep[4]].y ; bo[piakyr_month].y1 = bo[piakyr_month].y + 22 ;
            
            bo[piakyr_year].x = xt+480 ; bo[piakyr_year].x1 = bo[piakyr_year].x + 200 ;
            bo[piakyr_year].y = bo[basep[8]].y ; bo[piakyr_year].y1 = bo[piakyr_year].y + 22 ;
            
            bo[go].x = xb-120 ; bo[go].x1 = bo[go].x + 54 ;
            bo[go].y = bo[basep[10]].y ; bo[go].y1 = bo[go].y + 21 ;
            
            bo[yes].x = xb-60 ; bo[yes].x1 = bo[yes].x + 54 ;
            bo[yes].y = bo[basep[10]].y - 14 ; bo[yes].y1 = bo[yes].y + 36 ;
            
            evmonthx = xt + 210 ; evmonthy = bo[basep[2]].y ;
            evmonthx1 = evmonthx+30 ; evmonthy1 = evmonthy+22 ;

            evmonthsx = xt + 260 ; evmonthsy = bo[basep[5]].y ;
            evmonthsx1 = evmonthsx + 30 ; evmonthsy1 = evmonthsy + 22 ;
            
            evyearx = evmonthx+5 ; evyeary = bo[basep[6]].y ;
            evyearx1 = evyearx + 160 ; evyeary1 = evyeary + 22 ;
            
            evyearlx = xt+415 ; evyearly = bo[basep[7]].y ;
            evyearlx1 = evyearlx + 130 ; evyearly1 = evyearly + 22 ;
        
            monthevyearx = xt+240 ; monthevyeary = bo[basep[8]].y ;  
            monthevyearx1 =  monthevyearx + 120 ; monthevyeary1 = monthevyeary+22;
            
            evyearsx = evmonthsx + 8 ; evyearsy = bo[basep[9]].y ;
            evyearsx1 = evyearsx + 160 ; evyearsy1 = evyearsy + 22 ;
            monthevyearsx = bo[piakyr_year].x ; monthevyearsy = bo[basep[10]].y ;

            levyearsx = xt + 440 ; levyearsy = bo[basep[10]].y ;
            levyearsx1 = levyearsx + 135 ; levyearsy1 = levyearsy + 22 ;
            
            prenx = bo[apo].x1+30 ; prenx1 = xb-20 ;
            preny = bo[apo].y ; preny1 = preny+22 ;
            
            preosx = prenx ; preosx1 = prenx1 ;
            preosy = bo[eos].y ; preosy1 = preosy+22 ;         
            refresh();

        }
            
EPANAFORA :
            // Επαναφορά κανονικής κατάστασης
            a=0 ;
            if (foption==marrs) {
                puticon(bo[marrs].x,bo[marrs].y,mem_arrs,255);
                a=1;
            }
            else if (foption==go) {
                Rputicon(bo[go].x,bo[go].y,mem_go,cobkxr);
                fyge = 0;
                loop = 0;
                a=1;
            }
            else if (foption==yes) {
                a=1; puticon(bo[yes].x,bo[yes].y,mem_yes,255);
                
                b=0;
                
                if (local.keim[0]==255) {
                    b=1; information (0,"Δεν έχετε εισάγει κείμενο για την υπόμνηση!",0);
                }
                else if (local.basic_option==-1) {
                     b=1; information (0,"Δεν έχετε καθορίσει τον τύπο της υπόμνησης!","(Σημειώστε ένα από τα 11 κουτάκια αριστερά)");
                }
                else if (!ami.ak) {
                     b=1; information (0,"Δεν έχετε καθορίσει έναρξη υπόμνησης!",0);
                }
                else if (!tmi.ak) {
                     b=1; information (0,"Δεν έχετε καθορίσει πέρας υπόμνησης!",0);
                }
                else if (ami.ak>=tmi.ak) {
                     b=1; information (0,"Επανακαθορίστε το πέρας της υπόμνησης!",0);
                }
                
                dx=0;
                
                if (!b) {
                    
                    targt = ( new < 0 ) ? old : new ; 
                    local.which = 0 ;
                    local.weekday = 0 ;
                    local.monthlast = 0 ;
                    local.step = 0 ;
                    
                    switch (local.basic_option) {
                        
                        case 0 : // Κάθε τόσες ημέρες
                            
                            if (podays) {
                                local.freq=1 ;
                                local.step=podays;
                                
                                if (local.alarm>1 && podays<7) {
                                    information (0,"Η προειδοποίηση θα περιοριστεί σε 1 ημέρα..","..λόγω μικρής συχνότητας επανάληψης");
                                    local.alarm=1 ;}
                                dx=1;
                                loop=0;
                                fyge=1;
                            }
                            else {
                             information (0,"Δεν έχετε συμπληρώσει ανά πόσες ημέρες!",0);   
                            }
                            
                            break ;
                            
                            
                        case 1 : // Κάθε εβδομάδα
                            
                            if (wkd) {
                                local.freq = 7 ;
                                local.weekday = wkd;
                                local.monthlast = 0 ;
                                if ( local.alarm>2 ) {
                                    information (0,"Η προειδοποίηση θα περιοριστεί σε 2 ημέρες..","..λόγω μικρής συχνότητας επανάληψης");
                                    local.alarm=2 ;}
                                dx=1;
                            }
                            else {
                             information (0,"Δεν έχετε καθορίσει επιθυμητή ημέρα!",0);   
                            }
                            
                            break ;
                            
                        case 2 : // Κάθε μήνα τάδε του μηνός
                            
                            local.freq = 30 ;
                            dx=1;
                            break ;
                            
                        case 3 : // Κάθε μήνα την τελ. ημέρα
                            
                            local.freq = 30 ;
                            local.monthlast = 1 ;
                            dx=1;
                            break ;
                            
                        case 4 : // Κάθε μήνα την τάδε Κυριακή 
                            
                            if (pm[0][0] && pm[0][1]) {
                            local.freq = 31 ;
                            local.which = (unsigned short int) pm[0][0] ;
                            local.weekday = (unsigned short int) pm[0][1] ;
                            dx=1;
                            }
                            else {
                             information (0,"Δεν έχετε καθορίσει επιθυμητή ημέρα!",0);   
                            }
                            break ;
                            

                        case 5 : // Κάθε τόσους μήνες τάδε του μηνός
                            
                            if (pomonths) {
                            local.freq = 32 ;
                            local.step=pomonths;
                            dx=1;
                            }
                            else {
                             information (0,"Δεν έχετε συμπληρώσει ανά πόσoυς μήνες!",0);   
                            }
                            break ;
                            
                        case 6 : // Κάθε χρόνο τάδε του μηνός
                            
                            local.freq = 365 ;
                            local.step=1;
                            dx=1;
                            break ;
                            
                        case 7 : // Κάθε χρόνο τελευταία ημέρα του τάδε μηνός
                            
                            local.freq = 365 ;
                            local.monthlast = 1 ;
                            local.step=1;
                            dx=1;
                            break ;
                            
                        case 8 : // Κάθε χρόνο την τάδε / τελευταία Κυριακή τάδε μηνός 
                            
                            if (pm[1][0] && pm[1][1]) {
                            local.freq = 366 ;
                            local.step=1;
                            local.which = (unsigned short int) pm[1][0] ;
                            local.weekday = (unsigned short int) pm[1][1] ;
                            dx=1;
                            }
                            else {
                             information (0,"Δεν έχετε καθορίσει επιθυμητή ημέρα!",0);   
                            }
                            break ;
                            
                            
                        case 9 : // Κάθε τόσα χρόνια τάδε ημερομηνια
                            if (poyears1) {
                            local.freq = 365 ;
                            local.step = poyears1;
                            dx=1;
                            }
                            else {
                             information (0,"Δεν έχετε συμπληρώσει ανά πόσα χρόνια!",0);   
                            }
                            break ;
                            
                            
                        case 10 : // Κάθε τόσα χρόνια τελευταία ημέρα μηνός τάδε
                            if (poyears2) {
                            local.freq = 365 ;
                            local.monthlast = 1 ;
                            local.step = poyears2;
                            dx=1;
                            }
                            else {
                             information (0,"Δεν έχετε συμπληρώσει ανά πόσα χρόνια!",0);   
                            }
                            break ;
                    }
                    
                    if (dx) {
                        loop=0;
                        fyge=1;
                        rcr[targt].freq = local.freq ;
                        rcr[targt].which = local.which ;
                        rcr[targt].weekday = local.weekday ;
                        rcr[targt].monthlast = local.monthlast ;
                        rcr[targt].step = local.step ;
                        rcr[targt].enaryear = local.enaryear ;
                        rcr[targt].enarmonth = local.enarmonth ;
                        rcr[targt].enardate = local.enardate ; 
                        rcr[targt].enarday = local.enarday ;

                        rcr[targt].perasyear = local.perasyear ;
                        rcr[targt].perasmonth = local.perasmonth ;
                        rcr[targt].perasdate = local.perasdate ;
                        rcr[targt].perasday = local.perasday ;
                        
                        rcr[targt].alarm = local.alarm ;
                        rcr[targt].anast = local.anast ;
                        rcr[targt].basic_option = local.basic_option ;
                        mystrcpy_lim (rcr[targt].keim, local.keim, 69) ;
                        
                        //printf ("targ = %d , styear = %d\n",targt, rcr[targt].enaryear);

                    }
                }
                
            }
            else if (foption==apo) {
                _bareacls (bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , cobkxr) ;
                _outmystr_center_col (notosans_16b,enarj_t, bo[apo].x+1 , bo[apo].y+1 , bo[apo].x1-1 , bo[apo].y1-1 , black , cobkxr);
            }
            else if (foption==eos) {
                _bareacls (bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , cobkxr) ;
                _outmystr_center_col (notosans_16b,eos_t, bo[eos].x+1 , bo[eos].y+1 , bo[eos].x1-1 , bo[eos].y1-1 , black , cobkxr);
            }
            else if (foption==anastol) {
                if (!local.anast) { colp = pras ; } else { colp = redy ;}
                _bareacls (bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , cobkxr) ;
                _outmystr_center_col (notosans_16b,anastol_t[local.anast], bo[anastol].x+1 , bo[anastol].y+1 , bo[anastol].x1-1 , bo[anastol].y1-1 , colp , cobkxr);
            }
            else if (foption==alarm) {
                if (!local.alarm) { colp = black ; } else { colp = pras ;}
                _bareacls (bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , cobkxr) ;
                _outmystr_center_col (notosans_16b,alarm_t, bo[alarm].x+1 , bo[alarm].y+1 , bo[alarm].x1-1 , bo[alarm].y1-1 , colp , cobkxr);
            }
            
            if (!a) {
            setcolor (COLOR(cobkxr[0], cobkxr[1], cobkxr[2]));
            rectangle (bo[foption].x-1 , bo[foption].y-1 , bo[foption].x1+1, bo[foption].y1+1);
            rectangle (bo[foption].x-2 , bo[foption].y-2 , bo[foption].x1+2, bo[foption].y1+2);
            refresh();
            }
            
            foption = mbox;
            poption = -1 ;
            
        }
       
        break ;
        
        case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            ch_scan=sdlev.key.keysym.scancode;
                        
            switch (ch_scan) { 
                        
                case SDL_SCANCODE_ESCAPE :  
                   
                    loop=0;
                    break ;
                    
                case SDL_SCANCODE_RETURN :
                
                break ;
                
            }
            
        break ;

        case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

        refresh(); 
        continue;
    }
        
} while (loop);

FYGE:
ponom_font = krata_font ;
if (mem0) {
    fidicls(xt,yt,xb,yb,55,84,112); 
    putimage (xt,yt,mem0,0);
    refresh();
    free (mem0) ;
}

if (mem_go) free (mem_go);
if (mem_yes) free(mem_yes);
if (mem_arrs) free(mem_arrs);
if (mem_zer) free (mem_zer) ;

gouv=whouv;
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
return fyge;
}


int pers_rec_show(short int *sorton , unsigned short int uday, unsigned short int umonth, unsigned short int uyear )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!

{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0 , *mem_go=0 ;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 , *mem_fonter=0;
int *mem_int ;
short int delon=1;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepl2, xtepr2, xtepl3, xtepr3 ,xtepr, ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int neaepxt , neaepyt , neaepxb , neaepyb , tropxt , tropyt , tropxb , tropyb ;
unsigned short int plbut , key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , proelem ,c , c1 ;
unsigned char what ;
unsigned int size;
unsigned char *str , *ghost_str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary , neaepcl, tropcl;
Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] , tropchxr[3], tropbkxr[3];
unsigned int *shoitem;
short int infmobxt, infmobyt, cancel=0 , goxt , goyt ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

union {
    unsigned int ak;
    unsigned short int daye[2];
    unsigned char damo[4] ;
} dasi [250];

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
int fnt ;
short int orio ;
unsigned char epeteios [32] , tropop [30];
unsigned char but_name[90];
int chxrc[3] , bkxrc[3] , slxrc[3] ;

unsigned char *but[250] ;
unsigned char gbut[250][70];
unsigned char krit[250];
//short int dasi[250];
unsigned char dadm[250][30];
unsigned char nox[250][6];
char mera[8][24];
int black[3] ; 

tropchxr[0] = 116 , tropchxr[1] = 255 , tropchxr[2] = 101 ;
tropbkxr[0] = 196 , tropbkxr[1] = 46, tropbkxr[2] = 0;
orio = 87;
strcpy (but_name , "Πίνακας Περιοδικών Υπομνήσεων");
normtext_tomy (but_name,0);
strcpy (epeteios , "Νέα Υπόμνηση");
normtext_tomy (epeteios,0);
strcpy (tropop , "Τροποποίηση");
normtext_tomy (tropop,0);
fnt=personal_font;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];

plbut=ar_clue;    
key_1=sort_1=65000;

strcpy (mera[0],"  ");
strcpy (mera[1],"Κυριακή");  strcpy (mera[2],"Δευτέρα"); strcpy (mera[3],"Τρίτη"); strcpy (mera[4],"Τετάρτη");
strcpy (mera[5],"Πέμπτη"); strcpy (mera[6],"Παρασκευή"); strcpy (mera[7],"Σάββατο"); 

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0;f<plbut;f++) {
    
    krit[f]=0;
    but[f]=rcr[f].keim;
    mystrcpy(gbut[f],but[f]);
    if (!rcr[f].anast) {
        gsee.dm[0] = rcr[f].enardate;
        gsee.dm[1] = rcr[f].enarmonth;
        dasi[f].daye[0]=gsee.tog ;
        dasi[f].daye[1]=rcr[f].enaryear;
        sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , rcr[f].enaryear);
    } else {
        dasi[f].ak = 0 ;
        strcpy(dadm[f],"Σε αναστολή");
    }
    normtext_tomy(dadm[f],0);
    sprintf (nox[f] , "%03d" , f+1) ; 
    normtext_tomy (nox[f],0);
}

// Sorting Procedure !!
ardom_mem=malloc(250*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*4);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f].ak;
    }

// SORTING DATES!!
    pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 

i=orio*2*myfont_wid[fnt]/3;
f=info.right-info.left;
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 

if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-16) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);

xtepr3=xb-9;
xtepl=xt+9; xtepr = xtepl+9*myfont_wid[fnt]/4;
xtepl2 = xtepr+3;
xtepl3=xtepr3-3*13*myfont_wid[fnt]/4;
xtepr2=xtepl3-3;

ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 35 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;
goxt = xok-80 ; goyt = ysort +14 ;

neaepxt = tropxt= xvice + 60 ; neaepyt = ybarb+8 ;
neaepxb = tropxb= neaepxt+100 ; neaepyb = neaepyt+18; 
tropyt=neaepyb+8; tropyb = tropyt+18;
infmobxt = neaepxb+35 ; infmobyt = neaepyt+13 ;

_areacls (xtepl,ytepl,xtepr3,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr3);
refresh();

/*
chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
slxr[0]=190; slxr[1]=228; slxr[2]=0;
*/

chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
slxr[0]=20; slxr[1]=140; slxr[2]=80;
xrep[0]=chxr[0]; xrep[1]=chxr[1]; xrep[2]=chxr[2];  
xrkl[0]=0 ; xrkl[1] = 150; xrkl[2] = 100;
slkl[1]=40 ; slkl[0] = 10; slkl[2] = 100;
black[0] = black[1] = black[2] = 0 ;

_bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr3,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/dates_sort.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 


// Cancel : 94 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/go_5421.ico");
mem_go = icontomem (file_1,255);
if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    
//_bareacls (xtepl,ytepl,xtepr3,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

_realputicon(goxt,goyt,mem_go);

setcolor(1);
rectangle (neaepxt , neaepyt, neaepxb, neaepyb) ;
setcolor(2) ;
rectangle (neaepxt-1 , neaepyt-1, neaepxb+1, neaepyb+1) ;
_bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr);
_outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);

setcolor(1);
rectangle (tropxt , tropyt, tropxb, tropyb) ;
setcolor(2) ;
rectangle (tropxt-1 , tropyt-1, tropxb+1, tropyb+1) ;
_bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr);
_outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        _outfanis_col(fnt, nox[a] , xtepl+1 , ytepl+k*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[a]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[a]] , xtepl3+1 , ytepl+k*fhe , xtepr3);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(0);
line (xtepr+2,ytepl,xtepr+2,ytepl+k*fhe+1);
line (xtepr2+2,ytepl,xtepr2+2,ytepl+k*fhe+1);
line(xtepl,ytepl+k*fhe+1,xtepr3,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0; neaepcl=tropcl=0 ;
protyx=tyx=lines; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
        if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    //while (SDL_PollEvent(&sdlev)) continue ;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION); 
    if (mx<info.left || my<info.top) continue ;
     
     
    if (mx>xtepl && mx<xtepr3 && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
     tyx=(my-ytepl)/fhe;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 12 χρώματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
          
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);
          if (mem_small) hide_help (hdhlpxt , hdhlpyt);
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
                //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);       
                refresh();
                protyx=lines;
                ektos=1;
                if (mem_small) hide_help (hdhlpxt , hdhlpyt);
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else {if (mem_small) hide_help (hdhlpxt , hdhlpyt); continue;}
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        i=ar_dom[el];
         //_bareacls(xtepl+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl2+1, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl3+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
         _outfanis_colxr(fnt, nox[el] , xtepl+1 , ytepl+tyx*fhe , xtepr , xrep, slxr);
        _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+tyx*fhe , xtepr3 , xrep, slxr);
        refresh ();
        //_outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr3, xrep, slxr);
        if (rcr[i].anast) {show_help (" Σε αναστολή ", infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);}
        else {
            sprintf (str1kb,"Από %02d-%02d-%02d έως %02d-%02d-%02d-", rcr[i].enardate , rcr[i].enarmonth , rcr[i].enaryear ,  rcr[i].perasdate , rcr[i].perasmonth , rcr[i].perasyear ) ;
            switch (rcr[i].basic_option) {
                
                case 0 : // Κάθε τόσες ημέρες
                    sprintf(str1024,"%sΚάθε %d ημέρες",str1kb,rcr[i].step);
                    break;
                    
                case 1 : // Κάθε εβδομάδα ημέρα τάδε
                    sprintf(str1024,"%sΚάθε εβδομ. ημέρα %s",str1kb,mera[rcr[i].weekday]);
                    break;
                    
                case 2 : // Κάθε μήνα στις ...
                    sprintf(str1024,"%sΚάθε μήνα στις %d",str1kb,rcr[i].enardate);
                    break;
                    
                case 3 : // Κάθε μήνα τελ. ημέρα
                    sprintf(str1024,"%sΚάθε μήνα τελευτ. ημέρα",str1kb);
                    break;
                    
                case 4 : // Κάθε μήνα το τάδε Σάββατο ή την τάδε Κυριακή
                    if (rcr[i].which == 5) {
                        sprintf(str1024,"%sΚάθε μήνα τελευτ. %s",str1kb,mera[rcr[i].weekday]);
                    }
                    else {
                        if (rcr[i].weekday==7) {
                            sprintf(str1024,"%sΚάθε μήνα %do Σάββατο",str1kb,rcr[i].which);
                        }
                        else {
                    sprintf(str1024,"%sΚάθε μήνα %dη %s",str1kb,rcr[i].which,mera[rcr[i].weekday]);}
                    }
                    break ;
                    
                case 5 : // Κάθε τόσους μήνες τάδε του μηνός
                    sprintf(str1024,"%sΚάθε %d μήνες στις %d",str1kb,rcr[i].step,rcr[i].enardate);
                    break;
                    
                case 6 : // Κάθε χρόνο στις τάδε του μηνός τάδε
                    sprintf(str1024,"%sΚάθε χρόνο στις %d %s",str1kb,rcr[i].enardate , omonth[rcr[i].enarmonth]);
                    break ;
                    
                case 7: // Κάθε χρόνο , τελευταία ημέρα του μηνός τάδε
                    sprintf(str1024,"%sΚάθε χρόνο τελευτ. ημέρα %s",str1kb,omonth[rcr[i].enarmonth]);
                    break ;
                    
                case 8 : // Κάθε χρόνο την τρίτη Κυριακή του μήνα τάδε
                    if (rcr[i].which == 5) {
                        sprintf(str1024,"%sΚάθε χρόνο τελευτ. %s %s",str1kb,mera[rcr[i].weekday],omonth[rcr[i].enarmonth] );
                    }
                    else {
                        if (rcr[i].weekday==7) {
                            sprintf(str1024,"%sΚάθε χρόνο %do Σάββατο %s",str1kb,rcr[i].which,omonth[rcr[i].enarmonth]);
                        }
                        else {
                    sprintf(str1024,"%sΚάθε χρόνο %dη %s %s",str1kb,rcr[i].which,mera[rcr[i].weekday],omonth[rcr[i].enarmonth]);}
                    }
                    break ;
                    
                case 9 : // Κάθε τόσα χρόνια τάδε ημερομ.
                    sprintf(str1024,"%sΚάθε %d χρόνια στις %d %s",str1kb,rcr[i].step, rcr[i].enardate , omonth[rcr[i].enarmonth]);
                    break ;
                    
                case 10 : // Κάθε τόσα χρόνια τελευταία ημέρα μηνός τάδε
                    sprintf(str1024,"%sΚάθε %d χρόνια τελευτ. ημέρα %s",str1kb,rcr[i].step,  omonth[rcr[i].enarmonth]);
                    break ;
            } 
            show_help (str1024, infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);
        }
        /*
        if (pers[i].mob) {
            mytext_tonorm (pers[i].ktex,nktex,140);
            show_help (nktex, infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);
        }
        */
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        if (mem_small) hide_help (hdhlpxt , hdhlpyt);
        el = (sort) ? pano-protyx : pano+protyx;
        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
         
         
        el = (sort) ? pano-tyx : pano+tyx;
        i=ar_dom[el];
        //_bareacls(xtepl+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl2+1, ytepl+tyx*fhe,xtepr2,ytepl+tyx*fhe+(fhe-2),slxr);
        _bareacls (xtepl3+1, ytepl+tyx*fhe,xtepr3,ytepl+tyx*fhe+(fhe-2),slxr);
        _outfanis_colxr(fnt, nox[el] , xtepl+1 , ytepl+tyx*fhe , xtepr , xrep, slxr);
        _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+tyx*fhe , xtepr2 , xrep, slxr);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+tyx*fhe , xtepr3 , xrep, slxr);
        //_outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr3 , xrep, slxr);     
        refresh();
        /*
         if (pers[i].mob) {
             mytext_tonorm (pers[i].ktex,nktex,140);
            show_help (nktex, infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);
        }
        */
        if (rcr[i].anast) {show_help (" Σε αναστολή ", infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);}
        else {
            sprintf (str1kb,"Από %02d-%02d-%02d έως %02d-%02d-%02d-", rcr[i].enardate , rcr[i].enarmonth , rcr[i].enaryear ,  rcr[i].perasdate , rcr[i].perasmonth , rcr[i].perasyear ) ;
            switch (rcr[i].basic_option) {
                
                case 0 : // Κάθε τόσες ημέρες
                    sprintf(str1024,"%sΚάθε %d ημέρες",str1kb,rcr[i].step);
                    break;
                    
                case 1 : // Κάθε εβδομάδα ημέρα τάδε
                    sprintf(str1024,"%sΚάθε εβδομ. ημέρα %s",str1kb,mera[rcr[i].weekday]);
                    break;
                    
                case 2 : // Κάθε μήνα στις ...
                    sprintf(str1024,"%sΚάθε μήνα στις %d",str1kb,rcr[i].enardate);
                    break;
                    
                case 3 : // Κάθε μήνα τελ. ημέρα
                    sprintf(str1024,"%sΚάθε μήνα τελευτ. ημέρα",str1kb);
                    break;
                    
                case 4 : // Κάθε μήνα το τάδε Σάββατο ή την τάδε Κυριακή
                    if (rcr[i].which == 5) {
                        sprintf(str1024,"%sΚάθε μήνα τελευτ. %s",str1kb,mera[rcr[i].weekday]);
                    }
                    else {
                        if (rcr[i].weekday==7) {
                            sprintf(str1024,"%sΚάθε μήνα %do Σάββατο",str1kb,rcr[i].which);
                        }
                        else {
                    sprintf(str1024,"%sΚάθε μήνα %dη %s",str1kb,rcr[i].which,mera[rcr[i].weekday]);}
                    }
                    break ;
                    
                case 5 : // Κάθε τόσους μήνες τάδε του μηνός
                    sprintf(str1024,"%sΚάθε %d μήνες στις %d",str1kb,rcr[i].step,rcr[i].enardate);
                    break;
                    
                case 6 : // Κάθε χρόνο στις τάδε του μηνός τάδε
                    sprintf(str1024,"%sΚάθε χρόνο στις %d %s",str1kb,rcr[i].enardate , omonth[rcr[i].enarmonth]);
                    break ;
                    
                case 7: // Κάθε χρόνο , τελευταία ημέρα του μηνός τάδε
                    sprintf(str1024,"%sΚάθε χρόνο τελευτ. ημέρα %s",str1kb,omonth[rcr[i].enarmonth]);
                    break ;
                    
                case 8 : // Κάθε χρόνο την τρίτη Κυριακή του μήνα τάδε
                    if (rcr[i].which == 5) {
                        sprintf(str1024,"%sΚάθε χρόνο τελευτ. %s %s",str1kb,mera[rcr[i].weekday],omonth[rcr[i].enarmonth] );
                    }
                    else {
                        if (rcr[i].weekday==7) {
                            sprintf(str1024,"%sΚάθε χρόνο %do Σάββατο %s",str1kb,rcr[i].which,omonth[rcr[i].enarmonth]);
                        }
                        else {
                    sprintf(str1024,"%sΚάθε χρόνο %dη %s %s",str1kb,rcr[i].which,mera[rcr[i].weekday],omonth[rcr[i].enarmonth]);}
                    }
                    break ;
                    
                case 9 : // Κάθε τόσα χρόνια τάδε ημερομ.
                    sprintf(str1024,"%sΚάθε %d χρόνια στις %d %s",str1kb,rcr[i].step, rcr[i].enardate , omonth[rcr[i].enarmonth]);
                    break ;
                    
                case 10 : // Κάθε τόσα χρόνια τελευταία ημέρα μηνός τάδε
                    sprintf(str1024,"%sΚάθε %d χρόνια τελευτ. ημέρα %s",str1kb,rcr[i].step,  omonth[rcr[i].enarmonth]);
                    break ;
            } 
            show_help (str1024, infmobxt , infmobyt , &hdhlpxt , &hdhlpyt);
        }
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);       
        refresh();
        if (mem_small) hide_help (hdhlpxt , hdhlpyt);
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help(" Εναλλαγή Ταξινόμησης ", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help(" ReSorting ", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0;_bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    if (elem!=-1) show_help (" Μετάβαση..",xok-20 , yok-22, &hdhlpxt , &hdhlpyt);
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        mytext_tonorm (neodeigma1_text,file_2,45) ;
        sprintf (str1024,"Δεξί κλικ:Εισαγωγή στοιχείων αναζήτησης / Αριστερό κλικ:Αναζήτηση [%s]",file_2); 
        show_help(str1024, searx, yb , &hdhlpxt , &hdhlpyt) ;
        
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        else if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>neaepxt && mx<neaepxb && my>neaepyt && my<neaepyb) { // PONTIKI STO NEA EPILOGH
    
        ektos=0;
        if (probar) probar=0;
        else if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
        else if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
        
        if (neaepcl) continue ;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        neaepcl=1;
        _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , tropbkxr);
        _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , tropchxr, tropbkxr);
        refresh();
        continue ;
    }
    
    if (neaepcl) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();}
    
    if (mx>tropxt && mx<tropxb && my>tropyt && my<tropyb) { // PONTIKI STHN TROPOPOIHSH
    
        ektos=0;
        if (probar) probar=0;
        else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
        
        if (tropcl) continue ;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        tropcl=1;
        _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , tropbkxr);
        _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , tropchxr, tropbkxr);
        refresh();
        continue ;
    }
    
    if (tropcl) {tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();}
    
    if (mx>goxt && mx<goxt+94 && my>goyt && my<goyt+36) {
        ektos=0;
        if (probar) probar=0;
        
        if (cancel) continue ;
        cancel=1;
        RNputicon(goxt,goyt,mem_go,black);
        continue ;
    }
    
    if (cancel) {cancel=0 ; Rputicon(goxt,goyt,mem_go,black);}
    
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}
    
    

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        
        if (cancel) {
            fyge=1;
            kati=-2;
            continue ;
        }
            
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -5);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) && (!neaepcl) && (!tropcl) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
        _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
         if (krit[ar_dom[el]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr3-1, ytepl+protyx*fhe+(fhe-1)); }
            protyx=lines;
            refresh();
            continue ;
        }

        //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),slkl);
        _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),slkl);
        _outfanis_colxr(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr ,xrkl, slkl);
        _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2 , xrkl, slkl);
        _outfanis_colxr(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3 , xrkl, slkl);
        //_outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3 , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+1,ytepl+protyx*fhe+(fhe-1),xtepr3-1, ytepl+protyx*fhe+(fhe-1)); }
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
              
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            user_ans=alert(0,"Θέλετε να διαγραφεί η υπόμνηση ;" ,"Σίγουρα ;");
            if (user_ans != 1) continue;
            i=ar_dom[elem];
            ar_clue--; plbut=ar_clue;
            key_1=sort_1=65000;
            sparky=0;
            
            if (!plbut) { fyge=1; kati=-3; continue ;}
            
            for (f=i ; f<plbut ; f++) {

                rcr[f].freq = rcr[f+1].freq ; 
                rcr[f].enaryear = rcr[f+1].enaryear ;
                rcr[f].enarmonth =  rcr[f+1].enarmonth;
                rcr[f].enardate =  rcr[f+1].enardate ;
                rcr[f].enarday = rcr[f+1].enarday ;
                rcr[f].perasyear = rcr[f+1].perasyear ;
                rcr[f].perasmonth =  rcr[f+1].perasmonth ;
                rcr[f].perasdate = rcr[f+1].perasdate  ;
                rcr[f].perasday = rcr[f+1].perasday ;
                rcr[f].alarm = rcr[f+1].alarm ;
                rcr[f].step = rcr[f+1].step ;
                rcr[f].monthlast = rcr[f+1].monthlast ;
                rcr[f].weekday =  rcr[f+1].weekday ;
                rcr[f].which = rcr[f+1].which ;
                rcr[f].anast = rcr[f+1].anast ;
                rcr[f].extra1 = rcr[f+1].extra1 ;
                rcr[f].basic_option = rcr[f+1].basic_option ;
                mystrcpy (rcr[f].keim , rcr[f+1].keim) ;
                mystrcpy(gbut[f],gbut[f+1]);      
                krit[f]=0;
                but[f]=rcr[f].keim;
                if (!rcr[f].anast) {
                    gsee.dm[0] = rcr[f].enardate;
                    gsee.dm[1] = rcr[f].enarmonth;
                    dasi[f].daye[0]=gsee.tog ;
                    dasi[f].daye[1]=rcr[f].enaryear;
                    sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , rcr[f].enaryear);
                }
                else {
                    dasi[f].ak = 0 ;
                    strcpy (dadm[f],"Σε αναστολή");
                }
                normtext_tomy(dadm[f],0);

            }
            
        
            key=*sorton;
            for (f=0;f<plbut;f++) ar_dom[f]=f;
            if (key) {
                item_mem=malloc(plbut*24);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                item=item_mem;
                for (f=0;f<plbut;f++) {
                    bitem[0].big=bitem[1].big=bitem[2].big=0;
                    i=0;by=23;
                    do {
                    what=but[f][i];
                    if (what>163) break;
                    if (keyb_gr){
                            switch (what) {

                                case 96:
                                case 101:
                                case 104:
                                case 107:
                                case 116:
                                case 122:
                                case 129:
                                case 132:
                                case 137:
                                case 140:
                                case 143:
                                case 151:
                                case 157:
                                case 163:
                                what--;
                                break;

                                case 108:
                                case 123:
                                case 144:
                                case 158:
                                what-=2;
                                break;


                                case 109:
                                case 124:
                                what-=3;
                                break;

                                case 130:
                                what=119;

                            }

                    }
                    rby=by%8; low=(2-(by/8));
                    //if (by>7) {low=0;rby=by-8;} else low=1;
                    bitem[low].sma[rby]=what;
                    by-- ; i++;
                    } while (by>=0);
                    item[f].fg=bitem[0].big;
                    item[f].sg=bitem[1].big;
                    item[f].tg=bitem[2].big;
                }

            // SORTING !!
                pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            else {
                item_mem=malloc(plbut*4);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                shoitem=item_mem;
                for (f=0;f<plbut;f++) {
                shoitem[f]=dasi[f].ak;
                }

            // SORTING DATES!!
                pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            elem=proelem=-1 ; 
            protyx=lines;
            if (pano==plbut) pano--;
            c = pano;
            telos = (sort) ? c+1 : plbut-c ; 
            goto emfan ;
            
        }
        
        else if (tropcl) {
            if (elem==-1) {information(0,"Δεν έχετε επιλέξει υπόμνηση !",0); continue; }
            f = ar_dom[elem];
            for (i=0 ; i<3 ; i++) {
                chxrc[i]=chxr[i];
                bkxrc[i]=bkxr[i];
                slxrc[i]=slxr[i];
            }
            
            dx = pers_rec_inp (-1, f ,uday, umonth, uyear );
            
            for (i=0 ; i<3 ; i++) {
                chxr[i] = chxrc[i] ;
                bkxr[i] = bkxrc[i] ;
                slxr[i] = slxrc[i] ;
            }
            
            if (!dx) {
                tropcl=0;
                _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();
                continue ; }
            mystrcpy (gbut[f] , but[f]);
            atona (gbut[f]);
            if (!rcr[f].anast) {
                gsee.dm[0] = rcr[f].enardate;
                gsee.dm[1] = rcr[f].enarmonth;
                dasi[f].daye[0]=gsee.tog ;
                dasi[f].daye[1]=rcr[f].enaryear;
                sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , rcr[f].enaryear);
            }
            else {
                dasi[f].ak = 0 ;
                strcpy(dadm[f],"Σε αναστολή");
            }
            
            normtext_tomy(dadm[f],0);
            key_1=sort_1=65000;
            sparky=0;
            // ΑΝΑΤΑΞΙΝΟΜΗΣΗ
            key=*sorton;
            for (f=0;f<plbut;f++) {ar_dom[f]=f;krit[f]=0;}
            if (key) {
                item_mem=malloc(plbut*24);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                item=item_mem;
                for (f=0;f<plbut;f++) {
                    bitem[0].big=bitem[1].big=bitem[2].big=0;
                    i=0;by=23;
                    do {
                    what=but[f][i];
                    if (what>163) break;
                    if (keyb_gr){
                            switch (what) {

                                case 96:
                                case 101:
                                case 104:
                                case 107:
                                case 116:
                                case 122:
                                case 129:
                                case 132:
                                case 137:
                                case 140:
                                case 143:
                                case 151:
                                case 157:
                                case 163:
                                what--;
                                break;

                                case 108:
                                case 123:
                                case 144:
                                case 158:
                                what-=2;
                                break;


                                case 109:
                                case 124:
                                what-=3;
                                break;

                                case 130:
                                what=119;

                            }

                    }
                    rby=by%8; low=(2-(by/8));
                    //if (by>7) {low=0;rby=by-8;} else low=1;
                    bitem[low].sma[rby]=what;
                    by-- ; i++;
                    } while (by>=0);
                    item[f].fg=bitem[0].big;
                    item[f].sg=bitem[1].big;
                    item[f].tg=bitem[2].big;
                }

            // SORTING !!
                pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            else {
                item_mem=malloc(plbut*4);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                shoitem=item_mem;
                for (f=0;f<plbut;f++) {
                shoitem[f]=dasi[f].ak;
                }

            // SORTING DATES!!
                pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            tropcl=0; _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr); _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            c=pano ;
            telos = (sort) ? c+1 : plbut-c ; 
            goto emfan ;
        }
        
        else if (neaepcl) {
            if (ar_clue==250) continue ;
            for (i=0 ; i<3 ; i++) {
                chxrc[i]=chxr[i];
                bkxrc[i]=bkxr[i];
                slxrc[i]=slxr[i];
            }
            
            dx = pers_rec_inp (ar_clue, -1 , uday, umonth, uyear );
            
            for (i=0 ; i<3 ; i++) {
                chxr[i] = chxrc[i] ;
                bkxr[i] = bkxrc[i] ;
                slxr[i] = slxrc[i] ;
            }
            if (!dx) {neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();continue ;}
            f=ar_clue;
            ar_clue++; plbut=ar_clue;
         
            but[f]=rcr[f].keim;
            mystrcpy (gbut[f] , but[f]);
            atona (gbut[f]);
            
            //gsee.tog=pers[f].when ;
            //dasi[f].daye[0]=pers[f].when ;
            //dasi[f].daye[1]=pers[f].year ;
            //sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , pers[f].year);
            if (!rcr[f].anast) {
                gsee.dm[0] = rcr[f].enardate;
                gsee.dm[1] = rcr[f].enarmonth;
                dasi[f].daye[0]=gsee.tog ;
                dasi[f].daye[1]=rcr[f].enaryear;
                sprintf(dadm[f],"%02d %s %04d", gsee.dm[0], omonth[gsee.dm[1]] , rcr[f].enaryear);
            }
            else {
                dasi[f].ak = 0 ;
                strcpy(dadm[f],"Σε αναστολή");
            }
            normtext_tomy(dadm[f],0);
            sprintf (nox[f] , "%03d" , f+1) ; 
            normtext_tomy(nox[f],0);
            
            // ΑΝΑΤΑΞΙΝΟΜΗΣΗ
            key=*sorton;
            for (f=0;f<plbut;f++) {ar_dom[f]=f;krit[f]=0;}
            if (key) {
                item_mem=malloc(plbut*24);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                item=item_mem;
                for (f=0;f<plbut;f++) {
                    bitem[0].big=bitem[1].big=bitem[2].big=0;
                    i=0;by=23;
                    do {
                    what=but[f][i];
                    if (what>163) break;
                    if (keyb_gr){
                            switch (what) {

                                case 96:
                                case 101:
                                case 104:
                                case 107:
                                case 116:
                                case 122:
                                case 129:
                                case 132:
                                case 137:
                                case 140:
                                case 143:
                                case 151:
                                case 157:
                                case 163:
                                what--;
                                break;

                                case 108:
                                case 123:
                                case 144:
                                case 158:
                                what-=2;
                                break;


                                case 109:
                                case 124:
                                what-=3;
                                break;

                                case 130:
                                what=119;

                            }

                    }
                    rby=by%8; low=(2-(by/8));
                    //if (by>7) {low=0;rby=by-8;} else low=1;
                    bitem[low].sma[rby]=what;
                    by-- ; i++;
                    } while (by>=0);
                    item[f].fg=bitem[0].big;
                    item[f].sg=bitem[1].big;
                    item[f].tg=bitem[2].big;
                }

            // SORTING !!
                pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            else {
                item_mem=malloc(plbut*4);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                shoitem=item_mem;
                for (f=0;f<plbut;f++) {
                shoitem[f]=dasi[f].ak;
                }

            // SORTING DATES!!
                pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
            neaepcl=0; _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr); _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            c=pano ;
            telos = (sort) ? c+1 : plbut-c ; 
            goto emfan ;
        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            elem=proelem=-1 ; 
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}
else {
    item_mem=malloc(plbut*4);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    shoitem=item_mem;
    for (f=0;f<plbut;f++) {
    shoitem[f]=dasi[f].ak;
    }

// SORTING DATES!!
    pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                    _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
                    _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                    _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
                     //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
                    refresh();
                    elem=proelem=-1 ; 
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr3-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
                _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
                _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
                _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
                _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
                //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
                refresh();
                elem=proelem=-1 ; 
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }

                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }

                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;

            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    
            }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer);  mem_zer=0; yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer); mem_zer=0;

            xtepr3=xb-9;
            xtepl=xt+9; xtepr = xtepl+9*myfont_wid[fnt]/4;
            xtepl2 = xtepr+3;
            xtepl3=xtepr3-3*13*myfont_wid[fnt]/4;
            xtepr2=xtepl3-3; 
                        
            ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            goxt = xok-80 ; goyt = ysort +14 ;
            
            neaepxt = tropxt= xvice + 60 ; neaepyt = ybarb+8 ;
            neaepxb = tropxb= neaepxt+100 ; neaepyb = neaepyt+18; 
            tropyt=neaepyb+8; tropyb = tropyt+18;
            infmobxt = neaepxb+35 ; infmobyt = neaepyt+13 ;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            neaepyt = ybarb+8 ;
            neaepyb = neaepyt+18; 
            tropyt=neaepyb+8;
            tropyb = tropyt+18;
            infmobyt = neaepyt+13 ;
            goyt = ysort +14 ;
            _areacls (xtepl,ytepl,xtepr3,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr3,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr3);

            refresh();

            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            
            _bareacls (xtepl,ytepl,xtepr3,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr3,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            Rputicon(goxt,goyt,mem_go,black);
            
            setcolor(1);
            rectangle (neaepxt , neaepyt, neaepxb, neaepyb) ;
            setcolor(2) ;
            rectangle (neaepxt-1 , neaepyt-1, neaepxb+1, neaepyb+1) ;
            _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr);
            _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);

            setcolor(1);
            rectangle (tropxt , tropyt, tropxb, tropyb) ;
            setcolor(2) ;
            rectangle (tropxt-1 , tropyt-1, tropxb+1, tropyb+1) ;
            _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr);
            _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);


            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(fnt, Header, dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            ektos=1;
            if (user_ans<0) continue;
            gouv=myfont[user_ans];
            fnt = user_ans ; personal_font = fnt ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            
            i=orio*2*myfont_wid[fnt]/3;
            f=info.right-info.left;
            fhe=myfont_hei[fnt]+2;
            if (i <320) width = 320 ; else {width=(i>f-18) ? f-18 : i ;} 
            
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-16) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(0);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(0);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            
            xtepr3=xb-9;
            xtepl=xt+9; xtepr = xtepl+9*myfont_wid[fnt]/4;
            xtepl2 = xtepr+3;
            xtepl3=xtepr3-3*13*myfont_wid[fnt]/4;
            xtepr2=xtepl3-3; 
            
            ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19 ;
            goxt = xok-80 ; goyt = ysort +14 ;
            
            neaepxt = tropxt= xvice + 60 ; neaepyt = ybarb+8 ;
            neaepxb = tropxb= neaepxt+100 ; neaepyb = neaepyt+18; 
            tropyt=neaepyb+8; tropyb = tropyt+18;
            infmobxt = neaepxb+35 ; infmobyt = neaepyt+13 ;
            
            _areacls (xtepl,ytepl,xtepr3,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(notosans_14b, but_name , xtepl, yt1+1, xtepr3);

            
            chxr[0]=0 ; chxr[1]=0; chxr[2]=0;
            bkxr[0]=159 ; bkxr[1]=155; bkxr[2]=116;
            slxr[0]=20; slxr[1]=140; slxr[2]=80;
            _bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr3,ytepr,0,0,0);
            refresh();
            
            _puticon (xdel,ydel,mem_del,255);
            
            _puticon(searx,seary,mem_search,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _Rputicon(goxt,goyt,mem_go,black);
            
            setcolor(1);
            rectangle (neaepxt , neaepyt, neaepxb, neaepyb) ;
            setcolor(2) ;
            rectangle (neaepxt-1 , neaepyt-1, neaepxb+1, neaepyb+1) ;
            _bareacls (neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , bkxr);
            _outmystr_center_col(2, epeteios, neaepxt+1 , neaepyt+1, neaepxb-1, neaepyb-1 , chxr, bkxr);

            setcolor(1);
            rectangle (tropxt , tropyt, tropxb, tropyb) ;
            setcolor(2) ;
            rectangle (tropxt-1 , tropyt-1, tropxb+1, tropyb+1) ;
            _bareacls (tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , bkxr);
            _outmystr_center_col(2, tropop, tropxt+1 , tropyt+1, tropxb-1, tropyb-1 , chxr, bkxr);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           

        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           
        _outfanis_col(fnt, nox[c] , xtepl+1 , ytepl+k*fhe , xtepr);
        _outfanis_col(fnt, but[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
        _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl3+1 , ytepl+k*fhe , xtepr3);
        //_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr3);
        if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr3-1, ytepl+k*fhe+(fhe-1)); }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(0);
    line (xtepr+2,ytepl,xtepr+2,ytepl+k*fhe+1);
    line (xtepr2+2,ytepl,xtepr2+2,ytepl+k*fhe+1);
    line(xtepl,ytepl+k*fhe+1,xtepr3,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if (a1==2 || a1==1) a1=0 ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            //_bareacls(xtepl+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl2+1, ytepl+protyx*fhe,xtepr2,ytepl+protyx*fhe+(fhe-2),bkxr);
            _bareacls (xtepl3+1, ytepl+protyx*fhe,xtepr3,ytepl+protyx*fhe+(fhe-2),bkxr);
            _outfanis_col(fnt, nox[el] , xtepl+1 , ytepl+protyx*fhe , xtepr);
            _outfanis_col(fnt, but[ar_dom[el]] , xtepl2+1 , ytepl+protyx*fhe , xtepr2);
            _outfanis_col(fnt, dadm[ar_dom[el]] , xtepl3+1 , ytepl+protyx*fhe , xtepr3);
            //_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr3);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr3,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                _outfanis_col(fnt, nox[c] , xtepl+1 , ytepl+k*fhe , xtepr);
                _outfanis_col(fnt, but[ar_dom[c]] , xtepl2+1 , ytepl+k*fhe , xtepr2);
                _outfanis_col(fnt, dadm[ar_dom[c]] , xtepl3+1 , ytepl+k*fhe , xtepr3);
                //_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr3);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr3-1, ytepl+k*fhe+(fhe-1)); }
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(0);
            line (xtepr+2,ytepl,xtepr+2,ytepl+k*fhe+1);
            line (xtepr2+2,ytepl,xtepr2+2,ytepl+k*fhe+1);
            line(xtepl,ytepl+k*fhe+1,xtepr3,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);  
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if (mem_go) free(mem_go);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);
return kati ;
}



short int check_diary_notes (unsigned short int uyear , short int *mo, short int *yeno)
 {

struct dirent *fold_entry;
DIR *fold_diary;
register int i , f ;
char c ;
char ddate[20] ;
char mer_t[4];
char mhn_t[4];
char xro_t[6];
int a ;
unsigned short int fyear , fmonth , fdate ,yn ;

        *yeno = 0 ;
        yn = 0 ;
        
        for (f=1 ; f<13 ; f++) {
            for (i=1 ; i<32 ; i++) {
                DIaryn[f][i] = 0 ;
            }
        }

        // Άνοιγμα του φακέλου έτους
        sprintf(str1kb,"%s%d",Diary_path,(int) uyear);
        fold_diary = opendir (str1kb);
        if (fold_diary == NULL) {
            
            return 0;
        }

        // Διάβασμα στοιχείων καταλόγου - αποκωδικοποίηση
        
        mer_t[2] = mhn_t[2] = xro_t[4] = '\0';

        while ((fold_entry = readdir(fold_diary)) != NULL) {
            i=0;
            c = fold_entry->d_name[i] ;
            while ( c != '\0' && i<15) {ddate[i] = c ; i++; c = fold_entry->d_name[i] ; }
            ddate[i]='\0';
            a = strlen(ddate);
            if (a!=14) continue ;
            if (strstr(ddate,".dry")) {
                xro_t[0] = ddate[0];
                xro_t[1] = ddate[1];
                xro_t[2] = ddate[2];
                xro_t[3] = ddate[3];
                a = atoi(xro_t) ;
                fyear = (unsigned short int) a ;
                if (fyear != uyear) {
                    information (0 , "Κάποια παρέμβαση έχει συμβεί στο φάκελο :..", str1kb);
                    continue ;
                }
                mhn_t[0] = ddate[5];
                mhn_t[1] = ddate[6];
                a = atoi(mhn_t) ;
                fmonth = (unsigned short int) a ;
                if (fmonth<1 || fmonth>12 ) {
                    information (0 , "Κάποια παρέμβαση έχει συμβεί στο φάκελο :..", str1kb);
                    continue ;
                }
                mer_t[0] = ddate[8];
                mer_t[1] = ddate[9];
                a = atoi(mer_t) ;
                fdate = (unsigned short int) a ;
                if (fdate<1 || fdate>mo[fmonth] ) {
                    information (0 , "Κάποια παρέμβαση έχει συμβεί στο φάκελο :..", str1kb);
                    continue ;
                }
                
                DIaryn[fmonth][fdate]=1 ;
                yn++;
            }
            
        }
        
        *yeno = yn ;

        // Close directory and exit.

        closedir (fold_diary);
        return 1;
    }

    

void ROputicon (int x1,int y1,void *mem1 , int *bkxr)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;

float alfa , enaejoa , nr , ng , nb ;

unsigned char ed , en, ue ;

mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    

    for (f=0;f<height;f++) {
        
        for(i=0 ; i < width; i++) {
            
            co.lor= *(mem_int++);
    
            if (co.rgb[3]==255) {  
                ed = co.rgb[2]+196; en = co.rgb[1]+196 ; ue = 0;
                if (ed>255) ed-=255;
                if (en>255) en-=255;
                setcolor (COLOR ( (int) ed ,(int) en,(int) ue) );
            }
            
            else if (!co.rgb[3]) {
                continue;
            }
            
            else {
                ed = ~co.rgb[2]; en = ~co.rgb[1] ; ue = ~co.rgb[0];
                //setcolor (COLOR ( (int) bkxr[0], (int) bkxr[1], (int) bkxr[2] ) );
                //_putpixel (x1+i,y1+f);
                alfa =  ((float)co.rgb[3] / 255.0) ;
                enaejoa = ((float)1.0 - alfa);
                nr = ( (ed * alfa) + (enaejoa * bkxr[0]) );
                ng = ( (en * alfa) + (enaejoa * bkxr[1]) );
                nb = ( (ue * alfa) + (enaejoa * bkxr[2]) );
                ed = (unsigned char) nr;
                en = (unsigned char) ng;
                ue = (unsigned char) nb;
                setcolor (COLOR ( (int) ed,(int) en,(int) ue ) );     
            }
    
        _putpixel (x1+i,y1+f);
        
        }
    }
    refresh();    
}



void change_col (int x1,int y1,void *mem1 , int *apocol , int* proscol)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;


mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    for (f=0;f<height;f++) {
        
        for(i=0 ; i < width; i++) {
            
            co.lor= *(mem_int++);
    
            if (co.rgb[3]>0) {  
                if ( (apocol[0] == (int) co.rgb[2])  &&  (apocol[1] == (int) co.rgb[1]) && (apocol[2] == (int) co.rgb[0]) ) {
                setcolor (COLOR ( proscol[0] ,proscol[1],proscol[2]) );
                }
                else {continue ;}
            }           
            else { continue ; }

        _putpixel (x1+i,y1+f);
        
        }
    }
    refresh();    
}


void show_help_inp(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1)
// To text_help δείχνει ένα κανονικό στριγκ το οποίο η συνάρτηση  μετατρέπει σε δικό μου , στο str1024.
//Δείχνει με μικρά γράμματα κάποιο βοηθητικό κείμενο.
// Δίνουμε συντεταγμένες  xt , yt αλλά σβήνουμε το βοηθητικό κείμενο και αποκαθιστούμε οθόνη με τις συντεταγμένες xt1, yt1 !!! (Μπορεί να αλλάξουν οι αρχικές συν/νες!)
{
register int i=0,f=0 ;
unsigned char what ;
unsigned short int wid ;
int colxr[3] , colbk[3] ;
unsigned char str1025[1026];

if (mem_small) {free(mem_small) ; mem_small=0;}
normtext_tomy (text_help , str1025);
what = str1025[f];
while (what != 255) {
    i += sarial[what].wid;
    what = str1025[++f];
    }
wid=i+4;
if ( xt+wid >= info.right ) {
    if (xt>wid) xt-=wid;
    else xt=info.left+1;
} 
if (yt+15>info.bottom) return;
*xt1=xt ; *yt1=yt ;
setrgbcolor(dbred);
mem_small=malloc(imagesize(xt,yt,xt+wid-1,yt+15));
if (!mem_small) return;

shlp=1;

colxr[0]=colxr[1]=colxr[2]=0;
colbk[0]=colbk[1]=255 ; colbk[2]=0;
getimage (xt,yt,xt+wid-1,yt+15,mem_small);
rectangle (xt,yt,xt+wid-1,yt+15);
setrgbcolor(dbhelpcol); 
for (f=yt+1 ; f<=yt+14 ; f++) {
    for (i=xt+1; i<=xt+wid-2 ; i++) {
        _putpixel (i,f);
    }
}

//setalpha (getcolor (), 255); 
//_bareacls(xt+1,yt+1,xt+wid-2,yt+14,colbk);
_outmystr_center_col(notosans_11b,str1025,xt+1,yt+1,xt+wid-2,yt+15,colxr,colbk);
refresh();
}


void hide_help_inp(unsigned short int xt1, unsigned short int yt1)
{
    if (!mem_small) return;
    shlp=0;
    putimage (xt1,yt1,mem_small,0);
    refresh();
    free(mem_small);mem_small=0;
    return;
}



int fastmenu_show_opt (short int plbut, short int *op, char menu[][120], char *but_name, unsigned short int moux, unsigned short int mouy )
// Βλέπε array submenu...
// Λειτουργεί με myfont0...χρειάζεται αλλαγές για να λειτουργήσει και με άλλα.
{
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0;
int *mem_int ;
int bkxrepi[3] , chxrepi[3] , bkxrsel[3], chxrsel[3] , bkxrkef[3] , chxrkef[3] , bkxrm[3] , chxrm[3] ;
int bkxrepi_1[3] , chxrepi_1[3] , bkxrsel_1[3], chxrsel_1[3] , bkxrm_1[3] , chxrm_1[3] ;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k  ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int pano, kato , telos ,sort , protyx ;
unsigned short int tyx ,fyge , yicob ,el ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , el_pl, c ;
unsigned char what ;
unsigned int size;
unsigned short int orio;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned short int xt;
int yt1;
unsigned char ektos=1;
unsigned char but[plbut][120];

short int mf ; 

mf = notosans_16n ;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[mf];
orio=0;

for (f=0 ; f<plbut ; f++) {
    normtext_tomy(menu[f],but[f]);
    i=0;
    while (but[f][i]!=255) i++;
    if (orio<i) orio=i;
}

// Sorting Procedure !!

sort=0;

// Κεφαλίδα
bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
chxrkef[0]=240 ; chxrkef[1]=240 ; chxrkef[2]=240 ; 

// Χρώματα Ενεργών Επιλογών
chxrm[0]=chxrm[1]=chxrm[2]=255;
// notesbkxr[0]=68 ; notesbkxr[1] = 70; notesbkxr[2] = 71 ;
bkxrm[0]=68 ; bkxrm[1]= 70; bkxrm[2]=71 ;

// Χρώματα Ενεργών Επιλογών κατά την κίνηση του ποντικιού 
chxrepi[0]=50; chxrepi[1]=0; chxrepi[2]=0;
bkxrepi[0]=170 ; bkxrepi[1]=170 ; bkxrepi[2]=0 ;

// Χρώματα Τελικής Επιλογής
chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
bkxrsel[0]= 0;  bkxrsel[1]=130  ; bkxrsel[2]=0 ;

// Χρώματα Μη ενεργών Επιλογών
chxrm_1[0]=chxrepi_1[0]=chxrsel_1[0]=40 ; 
chxrm_1[1]=chxrepi_1[1]=chxrsel_1[1]=120 ; 
chxrm_1[2]=chxrepi_1[2]=chxrsel_1[2]=130 ;  
bkxrm_1[0]=bkxrepi_1[0]=bkxrm[0]; 
bkxrm_1[1]=bkxrepi_1[1]=bkxrm[1]; 
bkxrm_1[2]=bkxrepi_1[2]=bkxrm[2];
bkxrsel_1[0]=50; bkxrsel_1[1]=0;  bkxrsel_1[2]=0;  

i=2*orio*myfont_wid[mf]/3;
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,(plbut*20+38));
mem0=malloc(size); //250 x ... ( όσο βγει το ύψος...προσοχή λίγο όμως...)
if (!mem0) {information(2-keyb_gr,NULL,NULL);return -1;}
xt=moux ; yt1=mouy ;
while ( (yt1+(plbut*20+38)>info.bottom-1) && (yt1>info.top) ) yt1--;
yt=yt1+20;  yb=yt+(plbut*20+18);
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+19,bkxrkef); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
_areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
setcolor(3);
line (xt+1,yt1+20,xb-1,yt1+20);
setcolor(0);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*20;
yicob = yb-9;


//_outfanis_center_col(0, but_name , xtepl, yt1+2, xtepr);
_outmystr_center_col(notosans_14b, but_name , xtepl, yt1+2, xtepr, yt1+20, chxrkef , bkxrkef);
_bareacls (xtepl,ytepl,xtepr,ytepl+(plbut*20),bkxrm);
//_areacls(xtepl,ytepl+ybarb,xtepr,ybarb+1,30,30,30);

// TELOS EPIKEFALIDAS

// EMFANISH EIKONIDIVN


a=0;k=0; a1=plbut; telos=0 ; 

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
        
        if (op[a]) _outmystr_center_col(mf, but[a] , xtepl+1, ytepl+k*20, xtepr-1, ytepl+k*20+20, chxrm , bkxrm);
        else _outmystr_center_col(mf, but[a] , xtepl+1, ytepl+k*20, xtepr-1, ytepl+k*20+20, chxrm_1 , bkxrm_1);
        a++; a1--;k++;
    
}while (a1 && k<plbut);

refresh();
c=a;
kato=--a;
telos=a1;
 
fyge=0;
protyx=tyx=25; elem=el_pl=-1 ;
bima= 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 15 (το πολύ) επιλογών !!
        ektos=0;
        el_pl=-1;
       
     tyx=(my-ytepl)/20;
    
            
        if (tyx>plbut-1) {
            
            if (protyx!=25) {
                
                el = (sort) ? pano-protyx : pano+protyx;
                if (op[el]) { _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);}
                else  { _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm_1);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm_1 , bkxrm_1);}
                refresh();
                protyx=25;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>plbut-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==25) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        if (op[el]) {
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);}
        else {
            _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi_1);
            _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi_1 , bkxrepi_1);
        }
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        if (op[el]) {
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);}
        else  {
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm_1);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm_1 , bkxrm_1);}
        
        el = (sort) ? pano-tyx : pano+tyx;
        if (op[el]) {
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);}
        else {
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi_1);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi_1 , bkxrepi_1);}
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 15 EPILOGVN
    
    if (protyx!=25) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        
        
        el = (sort) ? pano-protyx : pano+protyx;
        if (op[el]) {
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);}
        else {
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm_1);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm_1 , bkxrm_1);}
        refresh();
        protyx=25;
                }
                                 
       

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:

       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            {kati=-2; fyge=1; continue;}
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
        if ( mx1<xt || mx1>xb || my1<yt1 || my1>yb ) {kati=-2; fyge=1; continue;}
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( protyx!=25 ) { // Επιλογή κάποιου από τα 15 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (op[el]) {
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel , bkxrsel);}
        else {
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel_1);
        _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel_1 , bkxrsel_1);}
        refresh(); 
        goto DIPLO_KLIK ;
        //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                    
                if (tyx>=plbut-1 || tyx==25 || protyx==25 ) tyx=0; else tyx=tyx+1;
       
                    
                if (protyx==25) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl= (sort) ? pano-tyx : pano+tyx;
                    if (op[el]) {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);}
                    else {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi_1);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi_1 , bkxrepi_1);}
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    if (op[el]) {
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);}
                    else {
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm_1);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm_1 , bkxrm_1);}
                    
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    if (op[el]) {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);}
                    else {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi_1);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi_1 , bkxrepi_1);}
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_UP :
                    
                if ( !tyx || tyx==25 || protyx==25) tyx=plbut-1; else tyx-=1;
                        
                if (protyx==25) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    if (op[el]) {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);}
                    else {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi_1);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi_1 , bkxrepi_1);}
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    if (op[el]) {
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);}
                    else {
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm_1);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm_1 , bkxrm_1);}
                    
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                     if (op[el]) {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);}
                    else {
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi_1);
                    _outmystr_center_col(mf, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi_1 , bkxrepi_1);}
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :              
                if (elem!=-1) {
                fyge=1;
                kati = elem ;
                }
                else if (el_pl!=1) {
                    kati=el_pl;
                    fyge=1;
                }
               continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
if(mem0) { putimage(xt,yt1,mem0,0); free(mem0) ; } //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
refresh();
gouv=whouv;
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return kati ;
}


short int find_note (unsigned char *nelement, unsigned short int uyear , short int *mo)
{
FILE *fp ;
register int f,i ;
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0=0 , *mem_go=0 , *mem_arrs =0 ,*mem_zer=0 ;
short int xb,yb ;
unsigned char what ;
short int yesx,yesy,yesx1,yesy1,goxt,goyt,goxb,goyb,arrsxt,arrsyt,dist ;
int mx,my,mx1, my1, xt1, yt1, xb1, yb1, dx ;
short int fyge = 0 ;
unsigned int size ;
int chobkxr[3] , boxbkxr[3] , chochxr[3] , monbkxr[3] ;
short int loop=1 , ektos=1 , yes=0, cancel=0 , marrs=0 ;
static short int xt,yt ;
static short int fiti;
int bkxr2[3] , chxr2[3] , slxr2[3] , black[3] , galazio[3] , white[3] , kitr[3] , dark[3] , blue[3] ;
short int stx , sty , stx1 , sty1 , w1 , w , h , a , b , c, x , y , rx ;
unsigned short int ch_scan ;
short int galmo[13];
char elem_1[50];
short int stox , stoxp, stoxep, meta_stoxep , tx , ty , tx1 , ty1 ;
short int area[4] , goup[4] , godown[4], kleise[4] ;
unsigned short int hcur , hmany , horio , parous=0 , displ = 0 ;
short int parx, pary, parx1 , pary1 ;
void *mem_scr = NULL ;
char emfan1[90] , pigene[40] , emfan[150] ;
short int protxron , dd  ;
char day[8][10];

 //do {
   //     SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

    SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
    for (f=0;f<3;f++) {
        bkxr2[f]=bkxr[f] ; chxr2[f]=chxr[f] ; slxr2[f]=slxr[f];
    }

    
    whouv = gouv ;
    strcpy (day[1],"Κυρ."); strcpy (day[2],"Δευ.");  strcpy (day[3],"Τρί."); strcpy (day[4],"Τετ."); strcpy (day[5],"Πέμ.");
    strcpy (day[6],"Παρ."); strcpy (day[7],"Σαβ."); 
    mytext_tonorm(nelement , elem_1, 42 ) ;
    strcpy (emfan1 , "Παρουσίαση Καταχώρησης Ημερολογίου");
    strcpy (pigene , "Μ ε τ ά β α σ η"); normtext_tomy (pigene,0);
    size=imagesize(0,0,999,469);
    mem0=malloc(size);
    if (!mem0) {information (2-keyb_gr,0,0); goto FYGE;}

    protxron = find_dayname(uyear , 1 , 1) ;
    //printf ("Πρωτοχρονιά %d = %s\n" , uyear , day[protxron]);
    //chxrepi[0]=0; chxrepi[1]=0; chxrepi[2]=255;
    //bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
    //boxchxr[0]=boxchxr[1]=0 ; boxchxr[2]=255;
    //boxslxr[0]=255; boxslxr[1]=110; boxslxr[2]=234; 
    chochxr[0]=0 ; chochxr[1]=0 ; chochxr[2]=200 ; 
    galazio[0]=100; galazio[1]=149; galazio[2]=237;
    white[0] = white[1] = white[2] = 255 ;   
    kitr[0] = 196; kitr[1] = 255 ; kitr[2] = 123 ;
    dark[0] = 33 ; dark[1] = 45 ; dark[2] = 63 ;
    blue[0] = 167 ; blue[1] = 255 ; blue[2] = 255 ;

    if (!fiti) {
    xt=(info.right-info.left-999) / 2 ; yt=(info.bottom-info.top-469) / 2 ;}
    fiti=1;
    while ( (xt+999)>info.right-2 ) xt--;
    if (yt<info.top) yt=(info.bottom-info.top-469) / 2 ;
    while (yt+469 > info.bottom-2) yt--;
    xb=xt+999;
    yb=yt+469;
    getimage(xt,yt,xb,yb,mem0);


    // ΕΠΙΚΕΦΑΛΙΔΑ
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/hand_17.ico");
    mem_arrs=icontomem(file_1,255);
    if (!mem_arrs) {information(2-keyb_gr,file_1,NULL); goto FYGE;} 

    // Cancel : 94 Χ 36
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_40.ico");
    mem_go = icontomem (file_1,255);
    if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }



    chobkxr[0]=159; chobkxr[1]=155;  chobkxr[2]=116;
    black[0]=0; black[1]=0;  black[2]=0;
    boxbkxr[0]=251 ; boxbkxr[1]=148 ; boxbkxr[2]=130 ; 
    monbkxr[0]=159 ; monbkxr[1] = 188; monbkxr[2] = 116 ;   
    whouv=gouv;



    _bareacls(xt,yt,xb,yb,chobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    refresh();

    //EPIKEFALIDA

    sprintf (str1024,"Αναζήτηση <%s> στις Καταχωρήσεις Ημερολογίου %04d)" , elem_1, uyear );
    normtext_tomy (str1024,0);
    //_outmystr_center_col(bookman_16n, nelement , xt+8, yt+7, xb-8, yt+34, chochxr , chobkxr);
    _outmystr_center_col(bookman_16n, str1024 , xt+8, yt+7, xb-8, yt+34, chochxr , chobkxr);
    i=0;f=0;
    gouv=myfont[bookman_16n];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+30, xb-i, yt+30);
    //foh = myfont_hei[notosans_14b] ;
    
    w1 = 50 ; w = 29 ; h = 31 ;
    refresh();
    // Αρχή παραλληλογράμου
    stx = xt + 25 ; sty = yt + 40 ;
    stx1 = stx + w1 + 31*w ;
    sty1 = sty + 12*h ;
    rx = stx+w1 ;
    

    arrsxt = xt+9 ; arrsyt = yt+8 ;
    yesx=xb-160; yesy=yb-40; yesx1=xb-24; yesy1=yesy+22;
    goxt=xt+10; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;
    parx = goxb+130 ; pary = yesy ; parx1 = parx + 500 ; pary1 = pary+22 ;
    area[0] = rx + 30 ; area [1] = sty + 1 ; area[2] = stx1 ; area[3] = pary1+5 ;
    tx = area[0] ; ty = area[1]+1 ; tx1 = stx1-44 ; ty1 = sty1-h-1 ;
    goup[0] = rx + 360 ; goup[1] = sty1 - 24 ; goup[2] = goup[0] + 18 ;  goup[3] = goup[1] + 18 ;  
    godown[0] = goup[2] + 80 ; godown[1] = goup[1] ; godown[2] = godown[0] + 18 ;  godown[3] = godown[1] + 18 ;
    kleise[0] = tx1-140 ; kleise[1] = goup[1]-1 ; kleise[2] = tx1-20 ;  kleise[3] = kleise[1] + 20 ;
    
    _puticon(arrsxt,arrsyt,mem_arrs,255);
    _puticon(goxt,goyt,mem_go,255);
    
    refresh() ;
    setcolor (0);


    for (f=0 ; f<13 ; f++) {
        line (stx,sty+f*h,stx1,sty+f*h);
    }
    
    a=0;
    for (i=0 ; i<33 ; i++) {
        if (!i) {line (stx+i*w , sty , stx+i*w , sty1);}
        else {line (stx+w1+(i-1)*w , sty , stx+w1+(i-1)*w , sty1);}
    }

    
    for (f=1 ; f<13 ; f++) {
        galmo[f]=0;
        for (i=1 ; i<32 ; i++) {
            
            if (i<=mo[f]) {
                x = stx+w1+(i-1)*w ; y = sty+(f-1)*h ;
                sprintf (str1kb , "%02d" , i) ; normtext_tomy (str1kb,0) ;
                if (!vrika_note[f][i]) {
                _outmystr_center_col(notosans_14n, str1kb , x , y , x + w, y + h, black , chobkxr);
                }
                else {
                    galmo[f]=1 ;
                    _bareacls (x+1 , y+1 , x + w -1 , y + h - 1 , galazio);
                    _outmystr_center_col(notosans_14b, str1kb , x , y , x + w, y + h, black , galazio);
                }
            }
            
            
        }
    }
    

    
            for (f=0 ; f<12 ; f++) {
                
                strcpy (str1kb , omonth[f+1]);
                normtext_tomy (str1kb,0);
                if (!galmo[f+1]) {_outmystr_center_col(neohell_20n, str1kb , stx+1, sty+f*h, stx+w1, sty+f*h+h, black , chobkxr);}
                else {
                    _bareacls(stx+1, sty+f*h+1, stx+w1-1, sty+f*h+h-1,monbkxr);
                    _outmystr_center_col(neohell_20n, str1kb , stx+1, sty+f*h, stx+w1, sty+f*h+h, black , monbkxr);
                }
            }
            
    refresh();
    stox = stoxp = stoxep = meta_stoxep = 0 ;
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor); 

    do {

    if (!SDL_PollEvent(&sdlev)) continue;
            switch (sdlev.type) {
            
            case SDL_MOUSEMOTION:
            //while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            SDL_FlushEvent(SDL_MOUSEMOTION);
            if (mx<0 || my<0 || mx>xb || my>yb) continue ;
                
            if (mx>=rx && mx<=stx1 && my>=sty && my<=sty1) { // Μέσα στις ημερομηνίες
                
                if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
                else if (marrs) {
                marrs=0;
                puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                else if ( (displ) && (yes) ){yes=0; _bareacls (yesx+1 , yesy+1 , yesx1-1 , yesy1-1, dark );
                      _outmystr_center_col(notosans_12b, pigene , yesx , yesy , yesx1 , yesy1, white , dark);
                     refresh();
                    }
                else if ( (displ) && (parous) ) {
                parous = 0 ;
                _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , dark );
                _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, white, dark);
                refresh();
                }
                
                x = mx-rx ; y = my - sty ;
                a = (x / w) + 1 ;
                b = (y / h) + 1 ;
                
                if (b>12) b=12;
                if (a>31) a=31;
                
                if (a <= mo[b]) {
                    if (vrika_note[b][a]) {
                        gsee.dm[0] = (char) a ;
                        gsee.dm[1] = (char) b ;
                        stox = gsee.tog ;
                        
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                        if (stox == stoxp) continue ;
                        
                        if ( (stoxp) && (stoxep!=stoxp) ) { // Αποκατάσταση προηγούμενης ημερομηνίας
                         
                        gsee.tog = stoxp ;
                        a = (short int) gsee.dm[0];
                        b = (short int) gsee.dm[1];
                        x = rx + (a-1) * w ;
                        y = sty + (b-1) * h ;
                        setcolor ( COLOR(galazio[0] , galazio[1], galazio[2])) ;
                        rectangle (x+1,y+1,x+w-1,y+h-1);
                        rectangle (x+2,y+2,x+w-2,y+h-2);
                            
                        }
                        
                        // Τσεκάρισμα επιλεγείσης ημερομηνίας
                        stoxp = stox ;
                        gsee.tog = stoxp ;
                        a = (short int) gsee.dm[0];
                        b = (short int) gsee.dm[1];
                        x = rx + (a-1) * w ;
                        y = sty + (b-1) * h ;
                        setcolor (0) ;
                        rectangle (x+1,y+1,x+w-1,y+h-1);
                        rectangle (x+2,y+2,x+w-2,y+h-2);
                        refresh();
                        continue ;
                    }
                    else if ( (stoxp) && (stoxep!=stoxp) ) { // Αποκατάσταση προηγούμενης ημερομηνίας
                    gsee.tog = stoxp ;
                    a = (short int) gsee.dm[0];
                    b = (short int) gsee.dm[1];
                    x = rx + (a-1) * w ;
                    y = sty + (b-1) * h ;
                    setcolor ( COLOR(galazio[0] , galazio[1], galazio[2])) ;
                    rectangle (x+1,y+1,x+w-1,y+h-1);
                    rectangle (x+2,y+2,x+w-2,y+h-2);
                    refresh();
                    stoxp=0;
                    }
                }
                else if ((stoxp) && (stoxep!=stoxp)) { // Αποκατάσταση προηγούμενης ημερομηνίας
                
                    gsee.tog = stoxp ;
                    a = (short int) gsee.dm[0];
                    b = (short int) gsee.dm[1];
                    x = rx + (a-1) * w ;
                    y = sty + (b-1) * h ;
                    setcolor ( COLOR(galazio[0] , galazio[1], galazio[2])) ;
                    rectangle (x+1,y+1,x+w-1,y+h-1);
                    rectangle (x+2,y+2,x+w-2,y+h-2);
                    refresh();
                    stoxp=0;
                }
                
                stox = 0 ;
                if (!ektos) {
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                ektos=1;
                }
                continue ;
            }
            
            
            // Έξω από τις ημερομηνίες
            if ((!stoxp) && (stoxep!=stoxp)) { // Αποκατάσταση προηγούμενης ημερομηνίας
                
                    gsee.tog = stoxp ;
                    a = (short int) gsee.dm[0];
                    b = (short int) gsee.dm[1];
                    x = rx + (a-1) * w ;
                    y = sty + (b-1) * h ;
                    setcolor ( COLOR(chobkxr[0] , chobkxr[1], chobkxr[2])) ;
                    rectangle (x+1,y+1,x+w-1,y+h-1);
                    rectangle (x+2,y+2,x+w-2,y+h-2);
                    refresh();
                    stox = stoxp = 0;
                }

            
        if (displ) {
            
            if (mx>yesx && mx<yesx1 && my>yesy && my<yesy1) {    // Μετάβαση σε ημερομηνία
                
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                }
                
                if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
                else if (marrs) {
                marrs=0;
                puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (parous) {
                parous = 0 ;
                _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , dark );
                _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, white, dark);
                refresh();
                }

                if (yes) continue ;
                yes = 1 ;
                _bareacls (yesx+1 , yesy+1 , yesx1-1 , yesy1-1, boxbkxr );
                _outmystr_center_col(notosans_12b, pigene , yesx , yesy , yesx1 , yesy1, black , boxbkxr );
                refresh ();
                continue ;
            }
            
            if (yes) {yes=0; _bareacls (yesx+1 , yesy+1 , yesx1-1 , yesy1-1, dark );
                      _outmystr_center_col(notosans_12b, pigene , yesx , yesy , yesx1 , yesy1, white , dark);
                     refresh();
                    }
         
            if (mx>=parx && mx<=parx1 && my>=pary && my<=pary1) { // Παρουσίαση Καταχ.
                
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                }
                
                if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
                else if (marrs) {
                marrs=0;
                puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                
                if (parous) continue ;
                parous=1;
                _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , boxbkxr );
                _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, black , boxbkxr);
                refresh();
                continue;
            }
            
            if (parous) {
                parous = 0 ;
                _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , dark );
                _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, white, dark);
                refresh();
            }
         
        }
            
            
            if (mx>goxt && mx<goxb && my>goyt && my<goyb) {
                
                if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
                }
                
                if (marrs) {
                marrs=0;
                puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                
                if (cancel) continue ;
                cancel=1;
                putNOTicon(goxt,goyt,mem_go);
                continue ;
            }
            
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
        
        if (mx>arrsxt && mx<arrsxt+18 && my>arrsyt && my<arrsyt+18) {
            
            if (ektos) {
                
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            
            if (!marrs) {
            marrs=1;
            putNOTicon(arrsxt,arrsyt,mem_arrs);
            if (keyb_gr) show_help("Μετακίνηση παραθύρου", arrsxt, arrsyt+18 , &hdhlpxt , &hdhlpyt) ;
            else show_help("Move the window", arrsxt, arrsyt+18 , &hdhlpxt , &hdhlpyt) ;
            continue ;}
            else continue ;
            
        }
        
            if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                
            
        // ΤΕΛΟΣ ΤΑ ΠΙΘΑΝΑ ΣΗΜΕΙΑ !!
            if (!ektos) {
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
            ektos=1;
            }
            
            break ; // break of SDL_MOUSEMOTION
            
            case SDL_MOUSEBUTTONDOWN:
            
            if(sdlev.button.button==SDL_BUTTON_LEFT) {   
                mx1 = sdlev.button.x ; my1= sdlev.button.y ;
                if ( (abs (mx1-mx) > 40) || (abs (my1-my) > 40) ) {
                    SDL_FlushEvent(SDL_MOUSEBUTTONDOWN);
                    continue ;
                }
                
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                stoxp = 0 ;
                
                if ( (displ) && (parous) ) {

                    if (meta_stoxep != stoxep ) {
                        meta_stoxep = stoxep ;
                        hcur = 0 ;
                        gsee.tog = stoxep ;
                        sprintf(str1kb,"%s%d/%04d_%02d_%02d.dry",Diary_path,(int) uyear, (int) uyear , (int) gsee.dm[1] ,(int) gsee.dm[0]);
                        fp=fopen(str1kb,"rb");
                        if (fp!=NULL) {
                            i=0;
                            fread (&what,1,1,fp);
                            do {
                                if (what<164 || what==200) {temp_notes[i++]=what ;}
                                fread(&what,1,1,fp);
                            }while (what!=255 && i<60000);
                            temp_notes[i]=255;
                            horio = (unsigned short int) i;
                            fclose(fp);
                            convert_and_strstr(temp_notes, nelement, &hmany, &hcur) ;
                        }
                        else {
                            temp_notes[0] = 255 ;
                            information (0,"Πρόβλημα στο αρχείο!","Προτείνεται ο έλεγχος του δίσκου..");
                            stox=0;
                            meta_stoxep = 0 ;
                            parous = 0 ;
                            _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , dark );
                            _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, white, dark);
                            refresh();
                            continue ;
                        }
                    }
                    
                    mem_scr = malloc (imagesize(tx,ty,stx1,sty1)) ;
                    if (mem_scr==NULL) {
                        printf ("Ανεπαρκής Μνήμη !\n"); 
                    }
                    else {
                    getimage (tx,ty,stx1,sty1,mem_scr) ;
                    _bareacls(tx,ty,stx1-30,ty1,white) ;
                    _bareacls(tx,sty1-h,stx1-30,sty1,dark) ;
                    setcolor(5) ;
                    rectangle (tx,sty1-h,stx1-30,sty1);
                    refresh();
                    gouv = myfont[notosans_16n];
                    hcur = field_txt_scrollsearch (area, goup, godown, kleise, temp_notes, hcur, tx , ty , tx1 , ty1 , horio , black, white, blue) ;
                    putimage (tx,ty,mem_scr,0);
                    refresh();
                    if (mem_scr!=NULL) free (mem_scr) ;
                    }
                    stox=0;
                    meta_stoxep = 0 ;
                    parous = 0 ;
                    _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , dark );
                    _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, white, dark);
                    refresh();
                    ektos=1;
                    continue ;
                }

                
                
                if ( (displ) && (yes) ) {
                                 
                
                    fyge=stoxep;
                    loop=0;
                    break ;
                   
                }
                
                if (stox) {
                    
                    if (stoxep == stox) continue ;
                    else if (!stoxep) {
                        stoxep = stox ;
                        gsee.tog = stox ;
                        a = (short int) gsee.dm[0];
                        b = (short int) gsee.dm[1];
                        x = rx + (a-1) * w ;
                        y = sty + (b-1) * h ;
                        _bareacls(stx+1, y+1, stx+w1-1, y+h-1 , boxbkxr);
                        normtext_tomy (omonth[b] , str1kb) ;
                        _outmystr_center_col(neohell_20n, str1kb , stx+1, y, stx+w1, y+h, black , boxbkxr);
                        sprintf (str1kb , "%02d" , a) ; normtext_tomy (str1kb,0) ;
                        _bareacls(x+1 , y+1 , x+w-1 , y+h-1 , boxbkxr) ;
                        _outmystr_center_col(notosans_14b, str1kb , x , y , x + w, y + h, black , boxbkxr);
                        setcolor(0);
                        rectangle (x+1,y+1,x+w-1,y+h-1);
                        rectangle (x+2,y+2,x+w-2,y+h-2);
                        
                        displ = 1 ;
                        setcolor(3);
                        c=0;
                        dd = (protxron==1) ? 7 : protxron-1; 
                        for (f=1 ; f<=12 ; f++) {
                            for (i=1 ; i <= mo[f] ; i++) {
                                //if (i>mo[f]) break ;
                                dd = (dd==7) ? 1 : dd+1 ;
                                if ( (f == (int) b) && (i == (int) a) ) { c=1 ; break;  }
                            }
                            if (c) break ;
                        }
                        sprintf (emfan , "%s της %02d/%02d/%04d , %s" , emfan1 , (int) a , (int) b , (int) uyear , day[dd]) ;
                        normtext_tomy (emfan,0);
                        rectangle (parx , pary , parx1 , pary1);
                        _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , dark );
                        _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, white , dark);
                        
                        setcolor(3);
                        rectangle (yesx , yesy , yesx1 , yesy1);
                        _bareacls (yesx+1 , yesy+1 , yesx1-1 , yesy1-1, black );
                        _outmystr_center_col(notosans_12b, pigene , yesx , yesy , yesx1 , yesy1, white , dark);
                        
                    }
                    else {
                        // Αποκατάσταση προηγούμενου stoxep
                        gsee.tog = stoxep ;
                        a = (short int) gsee.dm[0];
                        b = (short int) gsee.dm[1];
                        x = rx + (a-1) * w ;
                        y = sty + (b-1) * h ;
                        _bareacls(stx+1, y+1, stx+w1-1, y+h-1 , monbkxr);
                        normtext_tomy (omonth[b] , str1kb) ;
                        _outmystr_center_col(neohell_20n, str1kb , stx+1, y, stx+w1, y+h, black , monbkxr);
                        sprintf (str1kb , "%02d" , a) ; normtext_tomy (str1kb,0) ;
                        _bareacls(x+1 , y+1 , x+w-1 , y+h-1 , galazio) ;
                        _outmystr_center_col(notosans_14b, str1kb , x , y , x + w, y + h, black , galazio);
                        
                        // Τσεκάρισμα τωρινού stoxep
                        stoxep = stox ;
                        gsee.tog = stox ;
                        a = (short int) gsee.dm[0];
                        b = (short int) gsee.dm[1];
                        x = rx + (a-1) * w ;
                        y = sty + (b-1) * h ;
                        _bareacls(stx+1, y+1, stx+w1-1, y+h-1 , boxbkxr);
                        normtext_tomy (omonth[b] , str1kb) ;
                        _outmystr_center_col(neohell_20n, str1kb , stx+1, y, stx+w1, y+h, black , boxbkxr);
                        sprintf (str1kb , "%02d" , a) ; normtext_tomy (str1kb,0) ;
                        _bareacls(x+1 , y+1 , x+w-1 , y+h-1 , boxbkxr) ;
                        _outmystr_center_col(notosans_14b, str1kb , x , y , x + w, y + h, black , boxbkxr);
                        setcolor(0);
                        rectangle (x+1,y+1,x+w-1,y+h-1);
                        rectangle (x+2,y+2,x+w-2,y+h-2);
                        
                        c=0;
                        dd = (protxron==1) ? 7 : protxron-1; 
                        for (f=1 ; f<=12 ; f++) {
                            for (i=1 ; i <= mo[f] ; i++) {
                                //if (i>mo[f]) break ;
                                dd = (dd==7) ? 1 : dd+1 ;
                                if ( (f == (int) b) && (i == (int) a) ) { c=1; break; }
                            }
                            if (c) break ;
                        }
                        sprintf (emfan , "%s της %02d/%02d/%04d , %s" , emfan1 , (int) a , (int) b , (int) uyear , day[dd]) ;
                        normtext_tomy (emfan,0);
                        _bareacls (parx+1 , pary+1 , parx1-1 , pary1-1 , black );
                        _outmystr_center_col(notosans_12b, emfan , parx , pary , parx1 , pary1, white , dark);
                        stox=0;
                    }
                    refresh();
                    
                }
                
                if (marrs) {
                
                xt1=xt;
                yt1=yt;
                xb1=xb;
                yb1=yb;
                change_pos(&xt1, &yt1 ,&xb1 , &yb1);

                mem_zer=malloc(size);
                if (!mem_zer) {information(2-keyb_gr,NULL,NULL); continue ;}

                getimage(xt,yt,xb,yb,mem_zer);
                putimage(xt,yt,mem0,0); 
                
                getimage (xt1,yt1,xb1,yb1,mem0);
                
                xt=xt1 ; yt=yt1; xb=xb1; yb=yb1;
                putimage (xt,yt,mem_zer,0);
                free(mem_zer) ; mem_zer=0;
                w1 = 50 ; w = 29 ; h = 31 ;
                stx = xt + 25 ; sty = yt + 40 ;
                stx1 = stx + w1 + 31*w ;
                sty1 = sty + 12*h ;
                rx = stx+w1 ;
                    
                arrsxt = xt+9 ; arrsyt = yt+8 ;           
                yesx=xb-160; yesy=yb-40; yesx1=xb-24; yesy1=yesy+22;
                goxt=xt+10; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;
                parx = goxb+130 ; pary = yesy ; parx1 = parx + 500 ; pary1 = pary+22 ;
                area[0] = rx + 30 ; area [1] = sty + 1 ; area[2] = stx1 ; area[3] = pary1+5 ;
                tx = area[0] ; ty = area[1]+1 ; tx1 = stx1-44 ; ty1 = sty1-h-1 ;
                goup[0] = rx + 360 ; goup[1] = sty1 - 24 ; goup[2] = goup[0] + 18 ;  goup[3] = goup[1] + 18 ;  
                godown[0] = goup[2] + 80 ; godown[1] = goup[1] ; godown[2] = godown[0] + 18 ;  godown[3] = godown[1] + 18 ;
                kleise[0] = tx1-140 ; kleise[1] = goup[1]-1 ; kleise[2] = tx1-20 ;  kleise[3] = kleise[1] + 20 ;
                refresh();
                continue ;
                }
                
                
                if (cancel) {
                    fyge=0;
                    loop=0;
                    break ;
                }
                
            }
            else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
                continue ;
            }
            break ;
            
        case SDL_KEYDOWN:
            
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            ch_scan=sdlev.key.keysym.scancode;
                        
            if (ch_scan == SDL_SCANCODE_ESCAPE ) {  
                   
                    fyge=0;
                    loop=0;
            }
            break ;
            
        }
        
    } while (loop);

    FYGE:

    if (mem0) {
        fidicls(xt,yt,xb,yb,55,84,112); 
        putimage (xt,yt,mem0,0);
        refresh();
        free (mem0) ;
    }

    if (mem_go) free (mem_go);
    if (mem_arrs) free(mem_arrs);
    if (mem_zer) free (mem_zer) ;

    gouv=whouv;
    for (f=0;f<3;f++) {
        bkxr[f]=bkxr2[f] ; chxr[f]=chxr2[f] ; slxr[f]=slxr2[f];
    }
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);

    //do {
      //      SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);
    return fyge;
}



unsigned char *convert_and_strstr  (unsigned char *mainstr, unsigned char *deigma_txt, unsigned short int *how_many, unsigned short int *cur)

{

register int i,f ,w ;
int start_point , a ;
unsigned short int sefl , dem_len , sample_len , big_len ;
unsigned char deigma[22];
unsigned char *big_text , *mybigstr ;
unsigned char what ;
void *mem=0 ;

// Προυπόθεση ένας global void *mem_atono
// Δημιουργώ ένα αντίγραφο του string κειμένου στη μνήμη - εκεί θα περαστούν άτονα και μη κεφαλαία γράμματα για να γίνει το ψάξιμο του δείγματος μέσα σε αυτό.
//Μετά το ψάξιμο θα υπάρχουν μηδενικά και άσσοι στο αντίγραφο (mem_atono). Όπου είναι οι άσσοι θα έχουμε ισότητα με το δοθέν δείγμα !!!
// Επιστρέφει τη θέση μνήμης με τα μηδενικά και τους άσσους αν βρει ταυτίσεις με το δείγμα αλλιώς επιστρέφει 0 !!
// Στη μεταβλητή how_many επιστρέφει το πόσες ταυτίσεις βρέθηκαν !
// Στη μεταβλητή cur περνάει τη πρώτη θέση ταύτισης του δείγματος μέα στο bigstr (αν υπάρξει τάυτιση , ειδεμή περνάει 0 )!
// Eνημερώνεται ο δείκτης mem_atono δείχοντας τη θέση μνήμης που επιστρέφεται αν βρεθεί κάποια ταύτιση. (..και περιέχει άσσους και μηδενικά).
// PROSOXH : Αν ο επιστρεφόμενος unsigned char δείκτης ΔΕΝ είναι 0 , τότε θα πρέπει κάποτε να γίνει free(mem_atono) !!!!!!

    if (mem_atono!=NULL) {free (mem_atono); mem_atono=NULL;}

    mybigstr=mainstr;
    if (mybigstr[0]==255) { *cur=0; return 0; }
        
    mystrcpy(deigma,deigma_txt);
    if (deigma[0]==255) { *cur=0; return 0; }
    atona(deigma);
    
    i=0;
    while (mybigstr[i]!=255) { i++; }
    big_len=i;
    mem=malloc(i+1);
    if (!mem) {information (2-keyb_gr,0,0); return 0;}
    big_text= (unsigned char *) mem;
    for (f=0;f<=i;f++) big_text[f]=mybigstr[f] ;
    
       
     i=0;
    while (deigma[i]!=255) { i++; }
    sample_len = i ;

    //Όλα μικρά και χωρίς τόνους !
    // To big_text είναι το μεγάλο κείμενο 

    
    for (f=0;f<big_len;f++) {
        if (keyb_gr) {
            switch (big_text[f]) {

                case 96:
                case 131:
                case 132:
                big_text[f]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                big_text[f]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                big_text[f]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                big_text[f]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                big_text[f]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                big_text[f]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                big_text[f]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                big_text[f]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                big_text[f]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                big_text[f]=128;
                break;

                case 130:
                big_text[f]=119;
            }
        }
        if ( (big_text[f]>68) && (big_text[f]<95) ) big_text[f]-=26;
    }


    sefl=0; // Πόσα βρέθηκαν .... 
    i=0;
    do {
        what=big_text[i];
        f=0; w=sample_len; dem_len=0; start_point=-1; a=i ; // sample_len : μήκος δείγματος , dem_len : demanded len
        while( (what!=255) && (w) ) {
            if (what==deigma[f++]) {
                if (start_point==-1) start_point=i; 
                dem_len++; 
                w--; 
                what=big_text[++i];
                continue;
            }
            else break;
        }
            
        if (dem_len==sample_len) { 
            sefl++;  
            if (sefl==1) {*cur = (unsigned short int) start_point ;}
            for(f=start_point;f<i;f++) big_text[f]=1;
            continue ;
        }
        else { big_text[a]=0; i=a+1; }
        
    }while (what!=255);
    
    *how_many=sefl;
    if (sefl) {
        mem_atono=mem; return big_text;
    } 
    else {mem_atono=NULL; *cur=0; free(mem); return 0; }
}



unsigned short int field_txt_scrollsearch ( short int *area, short int *goup , short int *godown, short int *kleise, unsigned char *mainstr, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *cochxr , int *cobkxr, int *coslxr)
{

// Θα έχει προηγηθεί η convert_and_strstr !!
// Κάνει scroll - show και search συνάμα .
// Προυπόθεση ένας global void *mem_atono
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,ar,a2=0,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_mod , ch_scan; 
int diaf1,diaf2 ;
short int wrap  ;
unsigned short int wherp ;
unsigned char what ;
unsigned char *str , *ghost ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue;
void *mem_bar=0;
int *mem_int ;
int pos[orio+1][2] ;
float neg, alfa ;
union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;
void *mem_goup = NULL ,*mem_godown = NULL ;
short int sup = 0 , sdown = 0 , shut = 0 ;
char ejodo[32] , anazit[32] ;
int black[3] , white[3] , kitr [3] ;
int wherp_old = -1 ;

black[0] = black[1] = black[2] = 0 ;
white[0] = white[1] = white[2] = 255; 
kitr[0] = 220 ; kitr[1] = 220 ; kitr[2] = 0 ;

strcpy (ejodo , "Κλείσε Αρχείο"); normtext_tomy(ejodo,0);
strcpy (anazit , "ΕΝΤΟΠΙΣΜΟΣ"); normtext_tomy(anazit,0);
str = mainstr;
ghost = (unsigned char *) mem_atono ;
//if (ghost!=NULL) printf ("Ghost ok\n") ; else printf ("Ghost Empty!\n");
elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

//setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
//rectangle (xl,yt,xr,yb);
//_bareacls (xr+2,yt,xr+11,yb,dbbkxr);refresh();

//xl++ ; yt++ ; xr-- ; yb--;
//if (xr+13>info.right)  bar=2;
if (!bar) {mem_bar=malloc((imagesize (xr+2,yt,xr+13,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; return (0); }
getimage (xr+2,yt,xr+13,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
//_bareacls (xl,yt,xr,yb,cobkxr);

    // GoUp icon
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/go_up_18.ico");
    mem_goup=icontomem(file_1,255);
    if (!mem_goup) {information(2-keyb_gr,file_1,NULL); goto stokalo;} 

    // Go Down Icon
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_down_18.ico");
    mem_godown = icontomem (file_1,255);
    if (!mem_godown) {information(2-keyb_gr,file_1,NULL);goto stokalo ; }
    
    // KLEISE
    setcolor(4);
    rectangle (kleise[0] , kleise[1] , kleise[2] , kleise[3] ); 
    
    _bareacls (kleise[0]+1 , kleise[1]+1 , kleise[2]-1 , kleise[3]-1 , black ); 
    _outmystr_center_col(bookman_16n, ejodo , kleise[0] , kleise[1] , kleise[2] , kleise[3] , white , black);
    
    _puticon(goup[0],goup[1],mem_goup,255);
    _puticon(godown[0],godown[1],mem_godown,255);
    
    setcolor(4);
    rectangle (goup[0]-3 , goup[1]-3 , godown[2]+3 , godown[3]+3) ;
    _outmystr_center_col(notosans_11b, anazit , goup[2] , kleise[1] , godown[0] , kleise[3] , white , black);
    
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; goto stokalo ; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
        
        x1=xl; y1=yt;
        if (!ghost) {
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;

            if (!co.lor) continue;
                        // Gia MENA 
            alfa =  ((float)co.rgb[0] / 255) ;
            neg = ((float)1 - alfa);
            red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
            green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
            blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            //neg=255-co.rgb[0];
            //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
        }
        else {
            
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            
            if (!co.lor)  {
                if (!ghost[a]) continue ; 
                else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                 // Gia MENA 
                    alfa =  ((float)co.rgb[0] / 255) ;
                    neg = ((float)1 - alfa);
                    red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                    green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                    blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            //neg=255-co.rgb[0];
            //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            
            if (ghost[a]) {
                while (f<bh) {
                    setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                    for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
            }
        }
    }
        x=pos[cur][0] ; y=pos[cur][1];
        a2=a;
        
         // ELEGXOS GIA PLEYRIKH MPARA
        proyt=abs(pos[0][1]-yt) ;
        metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (0,255,0) );  
        line (xr+2,yt,xr+2,yb);
        setcolor (COLOR (255,255,255) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        
//enbar= (bar) ? 17 : 0;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);       
Enarjh :
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        //while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        SDL_FlushEvent(SDL_MOUSEMOTION);
         if (mx<info.left || my<info.top) continue ;
               
         
    //_puticon(goup[0],goup[1],mem_goup,255);
    //_puticon(godown[0],godown[1],mem_godown,255);
    
        if (mx>area[2] || mx<area[0] || my<area[1] || my>area[3]) goto stokalo ;
        
        if (mx>=goup[0] && my>=goup[1] && mx<=goup[2] && my<=goup[3]) {  // Search Up
            
            if (sdown) {sdown=0 ; puticon(godown[0],godown[1],mem_godown,255); }
            else if (shut) { shut=0 ; _bareacls (kleise[0]+1 , kleise[1]+1 , kleise[2]-1 , kleise[3]-1 , black ); 
                _outmystr_center_col(bookman_16n, ejodo , kleise[0] , kleise[1] , kleise[2] , kleise[3] , white ,black);
                refresh();
            }
            
            if (sup) continue ;
            sup = 1 ;
            putNOTicon(goup[0],goup[1],mem_goup);
            continue ;
        }
        
        if (sup) {sup=0 ; puticon(goup[0],goup[1],mem_goup,255); }
        
        
        if (mx>=godown[0] && my>=godown[1] && mx<=godown[2] && my<=godown[3]) {  // Search Down
            
            if (shut) {shut=0 ; _bareacls (kleise[0]+1 , kleise[1]+1 , kleise[2]-1 , kleise[3]-1 , black ); 
                _outmystr_center_col(bookman_16n, ejodo , kleise[0] , kleise[1] , kleise[2] , kleise[3] , white ,black);
                refresh();
            }
            
            if (sdown) continue ;
            sdown = 1 ;
            putNOTicon(godown[0],godown[1],mem_godown);
            continue ;
        }
        
        if (sdown) {sdown=0 ; puticon(godown[0],godown[1],mem_godown,255); }
        
        
        if (mx>=kleise[0] && my>=kleise[1] && mx<=kleise[2] && my<=kleise[3]) {  // Ejodos - shut
            
            if (shut) continue ;
            shut = 1 ;
            _bareacls (kleise[0]+1 , kleise[1]+1 , kleise[2]-1 , kleise[3]-1 , kitr ); 
            _outmystr_center_col(bookman_16n, ejodo , kleise[0] , kleise[1] , kleise[2] , kleise[3] , black , kitr);
            refresh();
            continue ;
        }
        
        if (shut) {shut=0 ; _bareacls (kleise[0]+1 , kleise[1]+1 , kleise[2]-1 , kleise[3]-1 , black ); 
            _outmystr_center_col(bookman_16n, ejodo , kleise[0] , kleise[1] , kleise[2] , kleise[3] , white ,black);
            refresh();
        }
        

        continue ;
        
        case SDL_MOUSEWHEEL :
            //while (SDL_PollEvent(&sdlev)) continue ;
            wherp_old = -1;
            if(sdlev.wheel.y > 0) { // scroll up
                SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if (!ghost){
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                                        // Gia MENA 
                    alfa =  ((float)co.rgb[0] / 255) ;
                    neg = ((float)1 - alfa);
                    red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                    green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                    blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    //neg=255-co.rgb[0];
                    //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                                            // Gia MENA 
                        alfa =  ((float)co.rgb[0] / 255) ;
                        neg = ((float)1 - alfa);
                        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                        //neg=255-co.rgb[0];
                        //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    refresh();
                    a2=a;
                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
                SDL_FlushEvent(SDL_MOUSEWHEEL);
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if (!ghost) {
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                                        // Gia MENA 
                    alfa =  ((float)co.rgb[0] / 255) ;
                    neg = ((float)1 - alfa);
                    red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                    green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                    blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    //neg=255-co.rgb[0];
                    //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                                            // Gia MENA 
                        alfa =  ((float)co.rgb[0] / 255) ;
                        neg = ((float)1 - alfa);
                        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                        //neg=255-co.rgb[0];
                        //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }                    
                    refresh();
                     a2=a;               
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>area[2] || mx<area[0] || my<area[1] || my>area[3]) goto stokalo ;
            
            if (shut) goto stokalo ;
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) {

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }

                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar-1][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if(!ghost) {
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                                        // Gia MENA 
                    alfa =  ((float)co.rgb[0] / 255) ;
                    neg = ((float)1 - alfa);
                    red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                    green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                    blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    //neg=255-co.rgb[0];
                    //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }}
                    
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                            // Gia MENA 
                        alfa =  ((float)co.rgb[0] / 255) ;
                        neg = ((float)1 - alfa);
                        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                        //neg=255-co.rgb[0];
                        //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    refresh();
                     a2=a;               

                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt,mem_bar,0);
                refresh();
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (255,255,255) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
        }   // END bar !!
        
        if (sdown && ghost) {
            
            //sdown=0 ; puticon(godown[0],godown[1],mem_godown,255);
                wherp_old = -1 ;
                sdlev.button.button = 0 ;
                f=a2;
                if (f!=ar) {
                    while ( (!ghost[f]) && (f<ar) ) f++;
                }
                
                  if (f!=ar) cur=f; else continue ;
                
                        f=0;
                        while (pos[cur-f][0] !=xl)  f++;
                        diaf1=pos[cur-f][1]-yt;
                        for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
                        wherp=cur-f;
                        
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                        
                    for (a=wherp; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ;
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    
                    if (!co.lor)  {
                        if (!ghost[a]) continue ; 
                        else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                        // Gia MENA 
                    alfa =  ((float)co.rgb[0] / 255) ;
                    neg = ((float)1 - alfa);
                    red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                    green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                    blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    
                    //neg=255-co.rgb[0];
                    //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    
                    if (ghost[a]) {
                        while (f<bh) {
                            setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                            for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                    }
                }
                
                    x=pos[cur][0] ; y=pos[cur][1];
                    a2=a;
                    goto barovios ;
                    
                }

            if (sup && ghost) {
                auto short int qui ;
                
                //sup=0 ; puticon(goup[0],goup[1],mem_goup,255); 
                sdlev.button.button = 0 ;
                
                
                if (wherp_old==-1) {
                    if (cur) f=cur-1 ; else continue ;
                    while ( (!ghost[f]) && (f) ) { f--; }
                    if ( (!ghost[f]) && (!f) ) {wherp_old = -1; continue ;} 
                    if (f) {
                        while ( (ghost[f]) && (f) ) { f--; }
                        if (f) f++;
                    }
                
                                    
                    cur=f;
                    
                    f=0;
                    while (pos[cur-f][0] !=xl)  { f++; }
                    diaf1=pos[cur-f][1]-yt;
                    for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
                    wherp=cur-f;
                    wherp_old = wherp ;
                }
                else {
                    
                    qui = 0 ;
                    
                    do {
                    if (cur) f=cur-1 ; else { qui=1; break ; }
                    while ( (!ghost[f]) && (f) ) { f--; }
                    if ( (!ghost[f]) && (!f) ) { qui=1 ; break ; } 
                    if (f) {
                        while ( (ghost[f]) && (f) ) { f--; }
                        if (f) f++;
                    }
                
                                    
                    cur=f;
                    
                    f=0;
                    while (pos[cur-f][0] !=xl)  { f++; }
                    diaf1=pos[cur-f][1]-yt;
                    for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
                    wherp=cur-f;
                    
                    } while (wherp_old == wherp);
                    
                    if (qui) continue ;
                    wherp_old = wherp ;
                }

            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            
            if (!co.lor)  {
                if (!ghost[a]) continue ; 
                else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                // Gia MENA 
            alfa =  ((float)co.rgb[0] / 255) ;
            neg = ((float)1 - alfa);
            red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
            green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
            blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            //neg=255-co.rgb[0];
            //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            
            if (ghost[a]) {
                while (f<bh) {
                    setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                    for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
            }
        }
        
            x=pos[cur][0] ; y=pos[cur][1];
            a2=a;
            goto barovios ;
                
            }
            continue ;                      // END Case buttondown
        }
                                     // END Button Left
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
            goto stokalo ;
            
        } // Τελος Button Right
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
            ch_mod=SDL_GetModState();
            
                    switch (ch_scan) { 
                        
        case SDL_SCANCODE_ESCAPE :  
                    fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) continue;
            wherp_old = -1 ;
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            if(!ghost) {
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
                                // Gia MENA 
            alfa =  ((float)co.rgb[0] / 255) ;
            neg = ((float)1 - alfa);
            red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
            green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
            blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            //neg=255-co.rgb[0];
            //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                            // Gia MENA 
                        alfa =  ((float)co.rgb[0] / 255) ;
                        neg = ((float)1 - alfa);
                        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                        //neg=255-co.rgb[0];
                        //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
            refresh();
            a2=a;
            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
            wherp_old = -1 ;
            if (cur==ar) continue;

            if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            if(!ghost) {
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
                                // Gia MENA 
            alfa =  ((float)co.rgb[0] / 255) ;
            neg = ((float)1 - alfa);
            red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
            green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
            blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
            //neg=255-co.rgb[0];
            //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }}
            
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                            // Gia MENA 
                        alfa =  ((float)co.rgb[0] / 255) ;
                        neg = ((float)1 - alfa);
                        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                        //neg=255-co.rgb[0];
                        //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
            refresh();
             a2=a;               
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                    wherp_old = -1 ;
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if (!ghost) {
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                                        // Gia MENA 
                    alfa =  ((float)co.rgb[0] / 255) ;
                    neg = ((float)1 - alfa);
                    red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                    green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                    blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    //neg=255-co.rgb[0];
                    //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                            // Gia MENA 
                        alfa =  ((float)co.rgb[0] / 255) ;
                        neg = ((float)1 - alfa);
                        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                        //neg=255-co.rgb[0];
                        //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    refresh();
                    a2=a;
                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :
                    wherp_old = -1 ;
                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if(!ghost){
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                                        // Gia MENA 
                    alfa =  ((float)co.rgb[0] / 255) ;
                    neg = ((float)1 - alfa);
                    red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                    green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                    blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                    //neg=255-co.rgb[0];
                    //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                                            // Gia MENA 
                        alfa =  ((float)co.rgb[0] / 255) ;
                        neg = ((float)1 - alfa);
                        red = (int) ( (alfa * (float)cochxr[0]) + (neg * (float) cobkxr[0]) );
                        green = (int) ( (alfa * (float)cochxr[1]) + (neg * (float) cobkxr[1]) );
                        blue = (int) ( (alfa * (float)cochxr[2]) + (neg * (float) cobkxr[2]) );
                        //neg=255-co.rgb[0];
                        //red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        //green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        //blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    a2=a;
                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (0,255,0) );  
                        line (xr+2,yt,xr+2,yb);
                        setcolor (COLOR (255,255,255) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt,mem_bar,0);
                bar=0;
                refresh();
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (255,255,255) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;     
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_WINDOWEVENT :
        refresh(); continue;
        
        case SDL_QUIT :
            fyge=1 ; break ;
            
        }                                    // END sdlev type 

        
    } while (!fyge);

stokalo :
if (cur) {
    i=cur;
    while (pos[i][1]>yt) i--;
    if(i) {
        while (pos[i][0]>xl) i--;}

    cur=i;
}
if (bar==1) { putimage (xr+2,yt,mem_bar,0); refresh();}
if (mem_bar) free (mem_bar);
if (mem_goup) free(mem_goup);
if (mem_godown) free(mem_godown);
if (mem_atono) { free(mem_atono) ; mem_atono = NULL; }

cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 

return cur ;
}


int proodos(char *str, int cur, int hm , int fun)

// Επιστρέφει 0 όταν υπάρχει έλλειψη μνήμης...
// Στον str περνάμε κανονικό κείμενο επικεφαλίδας !
// Στέλνουμε έναν δείκτη mem όπου διαφυλάττει την mem0 για να μπορεί στο τέλος να αποκαθιστά την οθόνη. (OXI!!)
// Αν έχουμε μια λούπα που ξεκινάει από το 0 και τελειώνει στο 5000 for (f=0;f<5000;f++) ...τότε cur=με το κάθε φορά f... και hm=5000 !
// Αν ο fun=0 λειτουργεί κανονικά αλλιώς είτε αποκαθιστά οθόνη άμεσα , είτε δεν κάνει τίποτε !! 
// Αρχικά ο δείκτης mem να είναι 0 ! Μετά τον μηδενίζει η συνάρτηση κάθε φορά που πρέπει .
{

void *mem0=0;
static int sxed , vima ,ppl ,ypl , plus;
static int nxt,nyt,nyb ;
static int xt,yt ;
int paspro[3] , pblack[3] , pyellow[3];
int f , nxb , xb, yb , wid , cur1 ;
short int w1 , h1 , h2 ;

    
    w1=399 ; h1 = 50 ; h2 = 30 ;
    
    if (fun) {
        mem0=pomem;
        if (mem0) {putimage(xt,yt,mem0,0); refresh(); pomem=0;}
        sxed=0;plus=0;
        return 0;
    }

    if (!hm) return 0;    
    
    if (!sxed) {
        

        mem0=malloc(imagesize(0,0,w1,h1));
        if (!mem0) {sxed=0; pomem=0; plus=0; return 0;}
        paspro[0]=paspro[1]=paspro[2]=255;
        pblack[0]=pblack[1]=pblack[2]=0;
        pyellow[0]=255 ; pyellow[1]=255 ; pyellow[2]=153 ;
        pomem=mem0;
        sxed=1;
        vima=1 ;
        xt=(info.right-info.left-w1) / 2 ; yt=(info.bottom-info.top-h1) / 2 ;
        xb=xt+w1;
        yb=yt+h1;
        getimage(xt,yt,xb,yb,mem0);

        setrgbcolor (dbred) ;
        rectangle (xt,yt,xb,yb);
        rectangle (xt+1,yt+1,xb-1,yb-1);
        setrgbcolor (dbaspro) ;
        rectangle (xt+2,yt+2,xb-2,yb-2);
        rectangle (xt+3,yt+3,xb-3,yb-3);
        setrgbcolor (dbblack) ;
        rectangle (xt+4,yt+4,xb-4,yb-4);
        rectangle (xt+5,yt+5,xb-5,yb-5);
        setrgbcolor (dbyel) ;
        rectangle (xt+6,yt+6,xb-6,yb-6);
        //refresh();
        _bareacls (xt+7, yt+7, xb-7, yt+h2-2,pyellow) ;
        setrgbcolor (dbred) ;
        line (xt+8,yt+h2-1,xb-7,yt+h2-1);
        line (xt+8,yt+h2,xb-7,yt+h2);
        normtext_tomy(str,file_3);
        _outmystr_center_col(notosans_12b, file_3 , xt+7, yt+7, xb-7, yt+h2-2, pblack , pyellow);
        nxt=xt+7 ;
        nyt=yt+h2+1; nxb=xb-7; nyb=yb-7 ;
        _bareacls(nxt,nyt,nxb,nyb,paspro);
        _outmystr_center_col(notosans_11b, please_wait , nxt,nyt,nxb,nyb, pblack , paspro);
        wid=nxb-nxt+1 ;
        while ( ((vima*wid)/hm) < 1 ) vima++; 
        if (vima>1) { ypl= (vima*wid) % hm ; }
        else { ppl=wid/hm; ypl = wid % hm ; }
        refresh ();
        return 1;
    }
    
    cur1=cur;
    setrgbcolor (dbgreen);
    if (vima==1) {
        for (f=0;f<ppl;f++) {
            line (nxt,nyt,nxt,nyb);
            nxt++;
        }
        plus+=ypl;
        if (plus>=hm) {
            line (nxt,nyt,nxt,nyb);
            nxt++;
            plus-=hm;
        }
        refresh ();
    }
    else {
        cur++;
        cur = cur % vima ;
            if (!cur) {
                line (nxt,nyt,nxt,nyb);
                nxt++;
            
            plus+=ypl;
            if (plus>=hm) {
                line (nxt,nyt,nxt,nyb);
                nxt++;
                plus-=hm;
            }
            refresh();
        }
    }
       
    
    if (cur1==hm-1) {
        mem0=pomem;
        if (mem0) {putimage(xt,yt,mem0,0); refresh();}
        sxed=0;plus=0;
        pomem=0;
        return 3;
    }
    else return 2;
}

int inp_fonts_show(char *header, void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon, int *proxchxr, int *proxbkxr , int *proxslxr)
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3];
int chxrep[3] , bkxrep[3] , bkxryes[3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , pano, kato , telos ,sort ,bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , proelem ,c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby;
Uint8 klik;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
int cls_xro[3] ;
short int hfont , hfontm1 , arbox , mahe ;
char kefali [160] ;

cls_xro[0]=31 ; cls_xro[1]=131 ; cls_xro[2]=170 ; mahe=480 ;
hfont = 40 ; hfontm1=hfont-1 ;

    for (f=0;f<3;f++) {
        chxrep[f]=proxchxr[f];
        bkxrep[f]=proxbkxr[f];
        bkxryes[f]=proxslxr[f];
    }
kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[0];
str=mem_str;
plbut=0;    


for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;

i=0; a=0;
for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       but[i++]=mem_str+a;
       a=f+1; 
        }
}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

cbrown[0]=132 ; cbrown[1]=130 ; cbrown[2]=0;
chrprnt[0]=0 ; chrprnt[1]=0 ; chrprnt[2]=0 ; 

f=0;
for (i=0; i<ttf; i++) {
    if (myfont_wid[i]>f) f=myfont_wid[i];
}
i=orio*f;
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,mahe);
mem0=malloc(size); //width x 550
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; 
if (!yt1) yt1=(info.bottom-info.top-(mahe+1) ) / 2 ;
if (yt1) {
    if (yt1+mahe>info.bottom-5) yt1 = info.bottom - mahe -5  ;
}
yt=yt1+19;  yb=yt1+mahe;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(0);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,cls_xro[0],cls_xro[1],cls_xro[2]);
setcolor(0);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);

arbox = ((mahe-83) / hfont) + 1 ;

xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+arbox*hfont+1;
xok=xb-46 ; yok=ysort = ydel = yb-40;
xdel = xtepl+2 ;  
xfrba = (delon) ? xdel+55 : xdel +2 ; 
yfrba = yb-50 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
//_areacls (xtepl,ytepl,xtepr,ytepl+(mahe-85),0,89,0);
//_areacls(xtepl,ytepl+(mahe-83),xtepr,ytepr,0,0,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
if (header!=NULL) {
 normtext_tomy (header , kefali);
 _outfanis_center_col(0, kefali , xtepl, yt1+2, xtepr);
}
else {
_outfanis_center_col(notosans_14b, but_name , xtepl, yt1+2, xtepr);
}
refresh();

chxr[0]=255 ; chxr[1]=255; chxr[2]=255;
bkxr[0]=30 ; bkxr[1]=30; bkxr[2]=30;
slxr[0]=0; slxr[1]=60; slxr[2]=0;
_bareacls (xtepl,ytepl,xtepr,ytepl+(mahe-83),bkxr);
_areacls(xtepl,ytepl+(mahe-82),xtepr,ytepr,0,0,0);


// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

a=0;k=0; a1=plbut; telos=0 ; sort=0;bar=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;


do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ
        _outmystr_center_col(ar_dom[a], but[ar_dom[a]] , xtepl+1 , ytepl+k*hfont , xtepr-1, ytepl+k*hfont+hfontm1,chxr,bkxr);
        a++; a1--;k++;
    
}while (a1 && k<arbox);


if (plbut<arbox) {
setcolor(0);
line(xtepl,ytepl+k*hfont+1,xtepr,ytepl+k*hfont+1);
}
refresh();



c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=0;
protyx=tyx=arbox; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
        if ( (secwin) && (sdlev.motion.windowID == sdlwin2) ) { continue ;}
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    SDL_FlushEvent(SDL_MOUSEMOTION);
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός arbox επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
       
     tyx=(my-ytepl)/hfont;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 12 χρώματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>(arbox-1) ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==arbox) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1 , ytepl+tyx*hfont , xtepr-1 , ytepl+tyx*hfont+hfontm1,bkxrep);
        _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+tyx*hfont , xtepr-1, ytepl+tyx*hfont+hfontm1,chxrep,bkxrep);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1 , ytepl+tyx*hfont , xtepr-1 , ytepl+tyx*hfont+hfontm1,bkxrep);
       _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+tyx*hfont , xtepr-1, ytepl+tyx*hfont+hfontm1,chxrep,bkxrep);    
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS arbox EPILOGVN
    
    if (protyx!=arbox && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);      
        refresh();
        protyx=arbox;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ονομάτων γραμματοσειρών ή , όχι", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting Font names or , not", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        if (probar) probar=0;
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
    }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (32-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) {
                if (keyb_gr) information (0,"Διαγραφή γραμματοσειράς από τη Μνήμη !",0); else information (0,"Unload a Font from the Memory!",0);
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=arbox) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) ) { // Επιλογή κάποιου από τα arbox κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
            protyx=arbox;
            refresh();
            continue ;
        }
        //el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxryes);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxrep,bkxryes);
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                elem=proelem=-1 ;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);refresh();
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            if (keyb_gr) user_ans=alert(0,"Θέλετε να διαγραφεί η γραμματοσειρά από τη μνήμη ;" ,"Δεν διαγράφεται από το δίσκο !! \nΜπορείτε να τη φορτώσετε ξανά όποτε θέλετε."); else user_ans=alert(0,"Do you want this font to be unloaded?" , "The font remains in the disk !! \n You can reload it any time you want.");
            if (user_ans != 1) continue;
            kati=ar_dom[elem];
            data[0]=255;
            fyge=1;
            // Διαγραφή κάποιου font - Μάλλον return με συγκεκριμένη τιμή
        }
        
        else if (profrba) {
            
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                elem=proelem=-1 ;
            }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+mahe;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+arbox*hfont+1;
            xok=xb-46 ; yok=ysort = ydel = yb-40;
            xdel = xtepl+2 ; 
            xfrba = (delon) ? xdel+55 : xdel+2 ;
            yfrba = yb-50 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;
            bary1=y1 ; bary2=y2;}
            

            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (probar) {
            
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                 elem=proelem=-1 ;
            }

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*arbox); telos+=hfont;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            my= sdlev.button.y ;
                            SDL_FlushEvent(SDL_MOUSEMOTION);
                            break ;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           

        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*arbox) / plbut )+y1;    
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*arbox) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*arbox) / plbut );}
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+arbox-1)>plbut-1) {
            if ( (plbut-arbox)>=0)  { c=plbut-arbox ; telos=arbox;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-(arbox-1))<0 ) { 
            c=arbox-1; telos=arbox; 
            if (plbut<arbox) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           
        _bareacls(xtepl+1, ytepl+k*hfont,xtepr-1,ytepl+k*hfont+hfontm1,bkxr);
        _outmystr_center_col(ar_dom[c], but[ar_dom[c]] , xtepl+1 , ytepl+k*hfont , xtepr-1, ytepl+k*hfont+hfontm1,chxr,bkxr);
        c+=bima ; telos--; k++;
        
    }while (telos && k<arbox);

    if (plbut<arbox) {
    setcolor(0);
    line(xtepl,ytepl+k*hfont+1,xtepr,ytepl+k*hfont+1);
    
    }
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        //if ((!sort) && (pano==a1)) continue;
        //else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
                 elem=proelem=-1 ;
            }    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos+=18;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos+=12;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=arbox) {
                _bareacls(xtepl+1, ytepl+protyx*hfont,xtepr-1,ytepl+protyx*hfont+hfontm1,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*hfont , xtepr-1, ytepl+protyx*hfont+hfontm1,chxr,bkxr);
                refresh();
                protyx=arbox;
            }
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos+=(arbox-1);
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos+=16;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*arbox); telos+=hfont;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ytepl+(mahe-83),bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+(arbox-1))>plbut-1) {
                    if ( (plbut-arbox)>=0)  { c=plbut-arbox ; telos=arbox;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-(arbox-1))<0 ) { 
                    c=(arbox-1); telos=arbox; 
                    if (plbut<arbox) {c=plbut-1; telos=plbut; }}}
                    
            pano=c;
            do {                                           

                _outmystr_center_col(ar_dom[c], but[ar_dom[c]] , xtepl+1 , ytepl+k*hfont , xtepr-1, ytepl+k*hfont+hfontm1,chxr,bkxr);
                c+=bima ; telos--; k++;
                
            }while (telos && k<arbox);

            if (plbut<arbox) {
            setcolor(0);
            line(xtepl,ytepl+k*hfont+1,xtepr,ytepl+k*hfont+1);
            
            }
            refresh();
            kato = (sort) ? c+1 : c-1;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    refresh();
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*arbox) / plbut ); y2+=y1;    
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; ;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                    data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);

    refresh(); continue;
                
     //default :
       //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       //SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :

// do {
  //      SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

SDL_FlushEvent(SDL_MOUSEBUTTONDOWN); SDL_FlushEvent(SDL_KEYDOWN);  
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if (mem_front) free(mem_front);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return kati ;
}
